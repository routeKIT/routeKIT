% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands
\usepackage{xspace} % \xspace for use in commands: put a space only if no punctuation follows
\usepackage{enumitem} % for controlling indentation in list environments

\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\newcommand{\none}[0]{
%  % see http://tex.stackexchange.com/questions/61155/linespacing-without-packages
%  \setlength\lineskiplimit{-1000pt} % allow overflowing of lines
%  \linespread{0}\selectfont % don’t advance line after empty item
  \item[] keine.
}

\makeatletter

\newcommand{\@packagelabel}[1]{P:#1}
\newcommand{\@typelabel}[1]{T:#1} % for classes and enums
\newcommand{\@attrlabel}[2]{A:#1.#2}
\newcommand{\@methodlabel}[2]{M:#1.#2}
\newcommand{\@paramlabel}[3]{P:#1.#2.#3}
\newcommand{\@constantlabel}[2]{C:#1.#2}

% evaluate #2 if the label #1 exists, else #3.
\newcommand{\ifhaslabel}[3]{%
  \@ifundefined{r@#1}%
               {#3}%
               {#2}%
}

% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Klassen (ein oder mehrere \class)
\newcommand{\package}[3]{%
  \subsection{Paket #1}\label{\@packagelabel{#1}}
  #2
  \begin{description}
   #3%
  \end{description}
}
% Argumente:
% 1. Klassenname
% 2. Beschreibung
% 3. Attribute (ein oder mehrere \attr, oder \none)
% 4. Methoden (ein oder mehrere \method, oder \none)
\newcommand{\class}[4]{%
  \newcommand{\currentclass}[0]{#1}%
  \item[\namedlabel{\@typelabel{#1}}{\code{#1}}] #2
    \ifstrequal{#3#4}{\none\none}{%
      % \none attributes and \none methods, skip
    }{%
      \begin{description}[leftmargin=0em,itemindent=0em]
        \ifstrequal{#3}{\none}{%
          % \none attributes, skip
        }{%
        \item[Attribute] \hfill % \hfill forces the following description into the next line
          \begin{description}
            #3%
          \end{description}
        }%
        \ifstrequal{#4}{\none}{%
          % \none methods, skip
        }{%
        \item[Methoden] \hfill% \hfill forces the following description into the next line
          \begin{description}
            #4%
          \end{description}
        }%
      \end{description}
    }%
  \let\currentclass=\undefined%
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\attr}[3]{%
  \item[\namedlabel{\@attrlabel{\currentclass}{#1}}{\code{#1}}] #3 Typ:~\reftype{#2}
}
% Argumente:
% 1. Name
% 2. (optional) Typ – default: void (wird nicht angezeigt); wird automatisch gelinkt, falls vorhanden
% 3. Parameter (ein oder mehrere \param, oder \none)
% 4. Beschreibung
\NewDocumentCommand{\method}{m o m +m}{% the ‘+m’ means that parameter 4 can contain several paragraphs, see http://tex.stackexchange.com/questions/64328/blank-lines-break-xparse-or-ifthen-macro
  \newcommand{\currentmethod}[0]{#1}%
  \item[\namedlabel{\@methodlabel{\currentclass}{#1}}{\code{#1}}] #4%
    \ifstrequal{#3}{\none}{%
      % \none parameters, skip
    }{%
      \\Parameter:
      \begin{description}[leftmargin=0em,itemindent=0em]
        #3%
      \end{description}
    }%
    \IfValueTF{#2}% if the optional “type” argument is given...
              { Rückgabetyp:~\reftype{#2}}% then show the return type...
              {}% else don’t.
  \let\currentmethod=\undefined%
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\param}[3]{%
  \item[\namedlabel{\@paramlabel{\currentclass}{\currentmethod}{#1}}{\code{#1}}] #3 Typ:~\reftype{#2}%
}
% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Konstanten (ein oder mehrere \constant, oder \none)
\newcommand{\enum}[3]{%
  \newcommand{\currentenum}[0]{#1}%
  \item[\namedlabel{\@typelabel{#1}}{\code{#1}}] #2
    \ifstrequal{#3}{\none}{%
      % \none cases, skip
    }{%
      Instanzen:
      \begin{description}
        #3
      \end{description}
    }%
  \let\currentenum=\undefined%
}
% Argumente:
% 1. Name
% 2. Beschreibung
\newcommand{\constant}[2]{%
  \item[\namedlabel{\@constantlabel{\currentenum}{#1}}{\code{#1}}] #2
}

\NewDocumentCommand{\refpackage}{mO{#1}}{%
  \hyperref[\@packagelabel{#1}]{\code{#2}}\xspace%
}
% Argumente:
% 1. Typ (Klasse oder Enum)
% 2. (optional) Text – default: Typ
\NewDocumentCommand{\reftype}{mO{#1}}{%
  \ifhaslabel{\@typelabel{#1}}{% if the label exists...
    \hyperref[\@typelabel{#1}]{\code{#2}}}{% then reference it...
    \code{#2}}\xspace% else just print the text.
}
% DEPRECATED
\NewDocumentCommand{\refclass}{mO{#1}}{%
  \GenericWarning{}{The command \refclass is deprecated -- use \reftype instead}%
  \reftype{#1}[#2]%
}
% Argumente:
% 1. Klasse
% 2. Attribut
% 3. (optional) Text – default: Attribut innerhalb der Klasse, sonst Klasse.Attribut
\NewDocumentCommand{\refattr}{mmO{__DEFAULT__}}{%
  \hyperref[\@attrlabel{#1}{#2}]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the attribute name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. (optional) Text – default: Methode innerhalb der Klasse, sonst Klasse.Methode
\NewDocumentCommand{\refmethod}{mmO{__DEFAULT__}}{%
  \hyperref[\@methodlabel{#1}{#2}]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the method name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. Parameter
% 4. (optional) Text – default: Parameter innerhalb der Methode, sonst Methode.Parameter innerhalb der Klasse, sonst Klasse.Methode.Parameter
\NewDocumentCommand{\refparam}{mmmO{__DEFAULT__}}{%
  \hyperref[\@paramlabel{#1}{#2}{#3}]{\code{%
      \ifthenelse{\equal{#4}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          \ifthenelse{\equal{\currentmethod}{#2}}{%
            #3% we’re inside the same method, only use the parameter name
          }{%
            #2.#3% we’re inside the same class, only use the method and parameter name
        }}{%
          #1.#2.#3%
      }}{%
        #4%
  }}}\xspace%
}
% Argumente:
% 1. Enum
% 2. Konstante
% 3. (optional) Text – default: Konstante innerhalb der Enum, sonst Enum.Konstante
\NewDocumentCommand{\refconstant}{mmO{__DEFAULT__}}{%
  \hyperref[\@constantlabel{#1}{#2}]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentenum}{#1}}{%
          #2% we’re inside the same enum, only use the constant name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}


\makeatother

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{%
  \glsdoifexists{#2}{%
    \def\@glsnumberformat{glsgobblenumber}%
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}%
    \setkeys{glossadd}{#1}%
    \@gls@saveentrycounter%
    \@do@wrglossary{#2}%
  }%
}
\newcommand{\glsaddallunused}[1][]{%
  \edef\@glo@type{\@glo@types}%
  \setkeys{glossadd}{#1}%
  \forallglsentries[\@glo@type]{\@glo@entry}{%
    \ifglsused{\@glo@entry}{}{%
      \typeout{****Glossary entry '\@glo@entry' unused****}%
      \glsaddnp[#1]{\@glo@entry}}}%
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

\makeatletter

\begin{document}
\shorthandoff{"}

\sloppy % fix overfull hboxes

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\emph{routeKIT}\xspace}


% alle Glossareinträge
\newglossaryentry{profil}{
  name={Profil},
  description={enthält für die Routenplanung relevante Informationen, z.\,B. die Höhe und das Gewicht des Fahrzeugs},
  plural={Profile}
}
\newglossaryentry{karte}{
  name={Karte},
  description={enthält die Daten aus \gls{osm} sowie einen Namen},
  plural={Karten}
}
\newglossaryentry{osmkachel}{
  name={OSM-Kachel},
  description={die öffentlichen gerenderten \gls{osm}-Kacheln z.\,B. auf\\\mbox{\url{http://a.tile.openstreetmap.org/}}},
  plural={OSM-Kacheln}
}
\newglossaryentry{route}{
  name={Route},
  description={ein Weg von einem Start- zu einem Zielpunkt},
  plural={Routen}
}
\newglossaryentry{vorberechnung}{
  name={Vorberechnung},
  description={verbindet die \gls{karte} mit den auf einem \gls{profil} basierenden Informationen und ermöglicht, unter anderem mittels \gls{arc}, später eine Beschleunigung der Berechnung einer \gls{route}; muss für jede neue \gls{karte}/\gls{profil}-Kombination einmal ausgeführt werden},
  plural={Vorberechnungen},
  see={arc}
}
\newglossaryentry{rendern}{
  name={rendern},
  description={Berechnung einer Bildkachel aus den zu rendernden Daten}
}
\newglossaryentry{wegbeschreibung}{
  name={Wegbeschreibung},
  description={Beschreibung einer \gls{route} durch eine Liste von Abbiegeanweisungen}
}
\newglossaryentry{dijkstra}{
  name={Dijkstra’s Algorithmus},
  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
}
\newglossaryentry{arc}{
 name={Arc-Flags},
 description={eine Technik, um eine Routenberechnung zu beschleunigen}
}
\newglossaryentry{verlauf}{
  name={Verlauf},
  description={speichert Routenanfragen für spätere Wiederverwendung. Es existiert nur ein Verlauf für die gesamte Anwendung}
}
\newglossaryentry{mercator}{
  name={Mercator-Projektion},
  description={die Zylinderprojektion der Weltkugel}
}
\newglossaryentry{entwurfsmuster}{
  name={Entwurfsmuster},
  description={Eine Schablone, die eine Lösung für ein oder mehrere Entwurfsprobleme darstellt. Ihre Verwendung erleichtert Änderungen im Entwurf}
}
\newglossaryentry{beobachter}{
  name={Beobachter},
  description={Ein \gls{entwurfsmuster}, das bei Änderung des Zustands eines Objektes alle abhängenden Objekte banachrichtigt}
}
\newglossaryentry{einzelstueck}{
  name={Einzelstück},
  description={Ein \gls{entwurfsmuster}, das zusichert, dass eine Klasse genau ein Exemplar besitzt und stellt einen globalen Zugriffspunkt darauf bereit}
}
\newglossaryentry{dekorierer}{
  name={Dekorierer},
  description={Ein \gls{entwurfsmuster}, das dynamisch neue Funktionalität zum Objekt hinzufügt}
}
\newglossaryentry{strategie}{
  name={Strategie},
  description={Ein \gls{entwurfsmuster}, das eine Familie von Algorithmen definiert, sie kapselt und austauschbar macht}
}
\newglossaryentry{G_smt}{
  name={Slippy Map Tile},
  description={
    Koordinaten, durch die Kartenkacheln einer graphischen Darstellung (mit \gls{mercator}) adressiert werden können.
    Drei Bestandteile: x, y, zoom.
    Mit nicht-ganzzahligen Werten für x und y können nicht nur Kacheln, sondern auch Geokoordinaten adressiert werden}
}
\newglossaryentry{smt}{
  type=\acronymtype,
  name={SMT},
  description={Slippy Map Tile},
  first={Slippy Map Tile (SMT)},
  see=[Glossareintrag:]{G_smt}
}
\newglossaryentry{opaque}{
  name={deckend},
  description={
    Die innere Implementierung wird vor anderen Klassen verborgen; Zugriff ist nur über das definierte Interface der Klasse/Methode möglich. (engl. “opaque”)}
}

\newacronym[longplural=Personenkraftwagen]{pkw}{PKW}{Personenkraftwagen}
\newacronym[longplural=Lastkraftwagen]{lkw}{LKW}{Lastkraftwagen}
\newacronym{osm}{OSM}{OpenStreetMap}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{gpx}{GPX}{GPS Exchange Format}
\newacronym{mvc}{MVC}{Model View Controller}



\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Implementierungsbericht}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage


\section{Einleitung}
Dieses Dokument erläutert die Implementierung der Anwendung \routeKIT. Es dokumentiert die durchgeführten Änderungen am Entwurf, die zur Realisierung der Implementierung notwendig waren. Außerdem beschreibt es die automatisierten Komponententests, soweit diese nicht erst in der Qualitätssicherungsphase erstellt werden.

\routeKIT ist eine Anwendung zur Routenplanung; durch Verwendung von \glslink{profil}{Profilen} kann sie dem Benutzer die optimalen \glspl{route} für sein spezielles Fahrzeug angeben.
Um die Routenberechnung zu beschleunigen, wird pro \gls{profil} und \gls{karte} eine zeitaufwändige \gls{vorberechnung} durchgeführt.

\section{Änderungen am Entwurf}
Im Folgenden sind die gegenüber dem ursprünglichen Entwurf geänderten und neu hinzugefügten Klassen, Methoden und Attribute aufgeführt.

\package{Controllers}{
  Es wurden drei neue Klassen eingeführt: \reftype{ProfileManager}, \reftype{MapManager} und \reftype{ProfileMapManager}, die jeweils alle dem Programm bekannten \glspl{profil}, \glspl{karte} und \glspl{vorberechnung} halten und sie speichern und laden.
}
{
  \class{ProfileManager}
        {
          Der \code{ProfileManager} verwaltet alle \glspl{profil}: er lädt sie beim Programmstart von der Festplatte, löscht sie auf Anfrage, speichert sie und hält eine Liste aller \glspl{profil}.
        }
        {\none}
        {
          \method{init}
                 {
                   \param{rootDirectory}{File}{siehe \refparam{ProfileMapManager}{init}{rootDirectory}.}
                 }
                 {
                   (statisch) Initialisiert den \code{ProfileManager}, indem alle in \refparam{ProfileManager}{init}{rootDirectory} liegenden \code{.profile}-Dateien \refmethod{Profile}{load}[geladen] werden.
                   Darf nur einmal aufgerufen werden.
                 }
          \method{getInstance}
                 {\none}
                 {
                   (statisch) Gibt die \code{ProfileManager}-Instanz zurück.
                   \refmethod{ProfileManager}{init} muss zuvor aufgerufen worden sein.

                   Für die Diskussion des \gls{einzelstueck}-Entwurfsmusters siehe \refmethod{ProfileMapManager}{init}.
                 }
          \method{getProfiles}[Set<Profile>]
                 {\none}
                 {
                   Gibt alle dem \code{ProfileManager} bekannten \glspl{profil} zurück.
                 }
          \method{saveProfile}
                 {
                   \param{profile}{Profile}{Das Profil, das gespeichert werden soll.}
                 }
                 {
                   Speichert \refparam{ProfileManager}{saveProfile}{profile} in der internen Liste an Profilen (siehe \refmethod{ProfileManager}{getProfiles}) und auf der Festplatte.
                   Alle bereits vorhandenen \glspl{vorberechnung} für ein Profil mit dem gleichen Namen werden gelöscht.
                 }
          \method{deleteProfile}
                 {
                   \param{profile}{Profile}{Das Profil, das gelöscht werden soll.}
                 }
                 {
                   Entfernt \refparam{ProfileManager}{deleteProfile}{profile} aus der internen Liste an Profilen (siehe \refmethod{ProfileManager}{getProfiles}) und löscht das Profil sowie alle seine Vorberechnungen von der Festplatte.
                 }
        }
  \class{MapManager}
        {
          Der \code{MapManager} verwaltet alle \glspl{karte}: er lädt sie beim Programmstart von der Festplatte, löscht sie auf Anfrage, speichert sie und hält eine Liste aller \glspl{karte}.
        }
        {\none}
        {
          \method{init}
                 {
                   \param{rootDirectory}{File}{siehe \refparam{ProfileMapManager}{init}{rootDirectory}}
                 }
                 {
                   (statisch) Initialisiert den \code{MapManager}, indem alle in \refparam{MapManager}{init}{rootDirectory} liegenden Ordner \refmethod{StreetMap}{load}[geladen] werden.
                   Darf nur einmal aufgerufen werden.
                 }
          \method{getInstance}
                 {\none}
                 {
                   (statisch) Gibt die \code{MapManager}-Instanz zurück.
                   \refmethod{ProfileManager}{init} muss zuvor aufgerufen worden sein.
                   
                   Für die Diskussion des \gls{einzelstueck}-Entwurfsmusters siehe \refmethod{ProfileMapManager}{init}.
                 }
          \method{getMaps}[Set<StreetMap>]
                 {\none}
                 {
                   Gibt alle dem \code{MapManager} bekannten \glspl{karte} zurück.
                 }
          \method{saveMap}
                 {
                   \param{map}{StreetMap}{Die Karte, die gespeichert werden soll.}
                 }
                 {
                   Speichert \refparam{MapManager}{saveMap}{map} in der internen Liste an Karten (siehe \refmethod{MapManager}{getMaps}) und auf der Festplatte.
                   Alle bereits vorhandenen \glspl{vorberechnung} für eine Karte mit dem gleichen Namen werden gelöscht.
                 }
          \method{deleteMap}
                 {
                   \param{map}{StreetMap}{Die Karte, die gelöscht werden soll.}
                 }
                 {
                   Entfernt \refparam{MapManager}{deleteMap}{map} aus der internen Liste an Karten (siehe \refmethod{MapManager}{getMaps}) und löscht die Karte sowie alle ihre Vorberechnungen von der Festplatte.
                 }
        }
  \class{ProfileMapManager}
        {
          Der \code{ProfileMapManager} verwaltet alle \glspl{vorberechnung}: er lädt sie beim Programmstart von der Festplatte, löscht sie auf Anfrage, speichert sie und hält eine Liste aller \glspl{vorberechnung}.
          Außerdem kennt er die aktuell ausgewählte \reftype{ProfileMapCombination} (die nicht zwangsläufig vorberechnet ist).
        }
        {\none}
        {
          \method{init}[ProfileMapCombination]
                 {
                   \param{rootDirectory}{File}{Das Verzeichnis, in dem die Daten dieser \routeKIT-Installation liegen.}
                 }
                 {
                   (statisch) Initialisiert den \code{ProfileMapManager}, indem der \reftype{ProfileManager} und der \reftype{MapManager} initialisiert werden und eine Index-Datei (\code{routeKIT.idx}) gelesen wird, die alle Vorberechnungen auflistet und die aktuelle \reftype{ProfileMapCombination} angibt.
                   
                   Der Rückgabewert ist die aktuelle \reftype{ProfileMapCombination}.
                 }
          \method{getInstance}
                 {\none}
                 {
                   (statisch) Gibt die \code{ProfileMapManager}-Instanz zurück.
                   \refmethod{ProfileMapManager}{init} muss zuvor aufgerufen worden sein.
                   
                   
                   Es handelt sich hierbei um eine Variante des \gls{einzelstueck}-Entwurfsmusters:
                   \refmethod{ProfileMapManager}{init} wird normalerweise durch \refmethod{ProfileMapManager}{getInstance} implizit durchgeführt, wenn noch keine Instanz vorhanden ist.
                   Hier wurden die beiden Methoden getrennt, da es sich bei \refmethod{ProfileMapManager}{init} um eine verhältnismäßig teure Operation handelt (beinhaltet Festplattenaktivität), die nicht beliebig beim ersten Aufruf von \refmethod{ProfileMapManager}{getInstance} stattfinden sollte, sondern nur an einer bestimmten Stelle während des Programmstarts.
                 }
          \method{getPrecalculations}[Set<ProfileMapCombination>]
                 {\none}
                 {
                   Gibt alle dem \code{ProfileMapManager} bekannten \glspl{vorberechnung} zurück.
                 }
          \method{getCurrentCombination}[ProfileMapCombination]
                 {\none}
                 {
                   Gibt die aktuell ausgewählte \reftype{ProfileMapCombination} zurück.
                   Diese muss nicht unbedingt ein Element aus \refmethod{ProfileMapManager}{getPrecalculations} sein, da sie möglicherweise nicht vorberechnet ist.
                 }
          \method{addCurrentCombinationListener}
                 {
                   \param{listener}{CurrentCombinationListener}{Der Listener, der benachrichtigt werden soll.}
                 }
                 {
                   Registriert einen \reftype{CurrentCombinationListener}, der bei Änderungen der aktuellen \reftype{ProfileMapCombination} benachrichtigt werden soll.
                 }
          \method{selectProfileAndMap}[ProfileMapCombination]
                 {
                   \param{profile}{Profile}{Das aktuelle \gls{profil}.}
                   \param{map}{StreetMap}{Die aktuelle \gls{karte}.}
                 }
                 {
                   Wählt das angegebene Profil und die angegebene Karte aus.
                   Existiert eine \gls{vorberechnung} für dieses Profil und diese Karte, so wird sie verwendet, ansonsten wird eine neue \reftype{ProfileMapCombination} erstellt.
                   
                   Gibt die ausgewählte \reftype{ProfileMapCombination} zurück.
                 }
          \method{getPrecalculation}[ProfileMapCombination]
                 {
                   \param{profile}{Profile}{Das aktuelle \gls{profil}.}
                   \param{map}{StreetMap}{Die aktuelle \gls{karte}.}
                 }
                 {
                   Sucht nach einer Vorberechnung für dieses Profil und diese Karte und gibt sie zurück, ansonsten wird \code{null} zurückgegeben.
                 }
          \method{setCurrentCombination}
                 {
                   \param{combination}{ProfileMapCombination}{Die ausgewählte \reftype{ProfileMapCombination}.}
                 }
                 {
                   Setzt die angegebene \reftype{ProfileMapCombination} als aktuelle Kombination.
                   Ist sie vorberechnet, so wird sie gespeichert und eine neue Index-Datei wird geschrieben.
                   Außerdem werden registrierte \reftype{CurrentCombinationListener} benachrichtigt.
                 }
          \method{savePrecalculation}
                 {
                   \param{precalculation}{ProfileMapCombination}{Die \reftype{ProfileMapCombination}, die gespeichert werden soll.}
                 }
                 {
                   Speichert die angegebene Vorberechnung in der internen Liste und auf der Festplatte.
                   Dies ist nur zulässig, wenn es sich dabei überhaupt um eine Vorberechnung handelt (und nicht etwa um eine \reftype{ProfileMapCombination} ohne Vorberechnung).
                   Schreibt eine neue Index-Datei.
                 }
          \method{deletePrecalculation}
                 {
                   \param{precalculation}{ProfileMapCombination}{Die \reftype{ProfileMapCombination}, die gelöscht werden soll.}
                   \param{deleteFromDisk}{boolean}{\emph{optional}: Wenn \code{false}, wird die \gls{vorberechnung} nicht von der Festplatte gelöscht.}
                 }
                 {
                   Löscht die angegeben Vorberechnung aus der internen Liste und, falls nicht anders angegeben, von der Festplatte.
                   Dies ist nur zulässig, wenn es sich dabei überhaupt um eine Vorberechnung handelt (und nicht etwa um eine \reftype{ProfileMapCombination} ohne Vorberechnung).
                   Schreibt eine neue Index-Datei.
                   
                   Die zweite Variante ist nur dann sinnvoll, wenn alle \glspl{vorberechnung} einer \gls{karte} zusammen mit der Karte gelöscht werden sollen;
                   da sie in Unterordnern der Karte gespeichert sind, würden sie durch das Löschen des Karten-Ordners ohnehin gelöscht.
                 }
        }
\class{MainController}{~}
{\none}
	{
	   \method{getInstance}
		{\none}
		{Neu: Gibt eine Instance des \reftype{MainControllers} zurück, da der er ein Einzelstück ist.}
	}
\class{MapManager}{~}
{\none}
	{
	   \method{getInstance}
		{\none}
		{Neu: Gibt eine Instance des \reftype{MapManager} zurück, da der er ein Einzelstück ist.}
	}
}

\package{Precalculation}{}
{
\class{ArcFlagsCalculator}{Geändert: Ein Interface für die Berechnung der \gls{arc}}
  {\none}
        {
	\method{calculateArcFlags}
		{
			\param{reporter}{ProgressReporter}{Neu: Wird zum Anzeigen des Fortschritts bei der \gls{arc}-Berechnung gebraucht.}
		}
		{Berechnet die \gls{arc} für die angegebene Kombination und setzt sie entsprechend.}
        }
\class{ArcFlagsCalculatorImpl}{Geändert: Erstzt die Klasse \code{ArcFlagsCalculator} aus dem Entwurf. Implementiert das Interface \reftype{ArcFlagsCalculator}}
  {\none}
        {
	\method{calculateArcFlags}
		{
			\param{reporter}{ProgressReporter}{Neu: Wird zum Anzeigen des Fortschritts bei der \gls{arc}-Berechnung gebraucht.}
		}
		{Berechnet die \gls{arc} für die angegebene Kombination und setzt sie entsprechend.}
        }
\class{EdgeWeighter}{Geändert: Ein Interface für die Berechnung der Kantengewichte.}
  {\none}
        {
	\method{weightEdges}
		{
			\param{reporter}{ProgressReporter}{Neu: Wird zum Anzeigen des Fortschritts bei der Gewichte-Berechnung gebraucht.}
		}
		{Versieht den kantenbasierten Graphen mit Kantengewichten.}
        }
\class{EdgeWeighterImpl}{Geändert: Erstzt die Klasse \code{EdgeWeighter} aus dem Entwurf. Implementiert das Interface \reftype{ArcFlagsCalculator}}
  {\none}
        {
	\method{calculateArcFlags}
		{
			\param{reporter}{ProgressReporter}{Neu: Wird zum Anzeigen des Fortschritts bei der Gewichte-Berechnung gebraucht.}
		}
		{Versieht den kantenbasierten Graphen mit Kantengewichten.}
        }
  \class{OSMParser}{~}
        {\none}
        {
          \method{parseOSM}
                 {\none}
                 {Geändert: Der Parameter \code{name} wurde entfernt. Der Name der Karte wird erst später vom \reftype{MapImporter} gesetzt.}
        }
  \class{OSMWay}{~}
        {\none}
        {
          \method{isReversedOneway}[boolean]
                 {\none}
                 {Bestimmt, ob es sich um eine Einbahnstraße entgegen der Wegrichtung handelt (OSM-Tag \code{oneway=-1}).}
        }
  \class{MapEdge}{~}
        {
          \attr{targetNode}{Node}{Geändert: Speichert nun direkt den Zielknoten und nicht mehr dessen ID in der OSM-Datei. Dadurch werden unnötige Hashtabellenabfragen in \reftype{OSMParser} vermieden.}
          \attr{Id}{Edge}{Der interne Bezeichner der Kante.}
        }
        {\none}
        
  \class{TurnRestriction}{~}
        {
          \attr{from}{int}{Die OSM-Way-ID des Wegs, von dem die Abbiegebeschränkung definiert ist.}
          \attr{to}{MapEdge}{Die Kante, auf die die Abbiegebeschränkung definiert ist.}
        }
        {
          \method{allowsTo}[boolean]
                 {
                   \param{to}{MapEdge}{Die Kante, auf die abgebogen werden soll.}
                 }
                 {Gibt an, ob diese Abbiegebeschränkung das Abbiegen auf die angegebene Kante erlaubt oder nicht.}
        }
}

\package{RouteCalculator}{}
{
  \class{Route}{Diese Klasse implementiert nun die Schnittstelle \code{Iterable}.}
        {\none}
        {
          \method{iterator}[Iterator<Coordinates>]
                 {\none}
                 {Gibt einen Iterator über die Koordinaten der Routenpunkte einschließlich Start- und Zielpunkt zurück. Diese Methode ersetzt \code{getNodeIterator}.}
        }
}

\package{Models}{}
{
  \class{Weights}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert die \reftype{Weights} in die angegebene Datei.}
          \method{load}[Weights]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt \reftype{Weights} aus der angegebenen Datei.}
        }
  \class{ArcFlags}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert die \reftype{ArcFlags} in die angegebene Datei.}
          \method{load}[ArcFlags]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt \reftype{ArcFlags} aus der angegebenen Datei.}
        }
  \class{ProgressReporter}
        {
          Neue Klasse, um den Fortschritt bei verschiedenen Aktionen, etwa der Vorberechnung, dem Benutzer anzeigen zu können.
          
          Der \reftype{ProgressReporter} ist Aufgaben-basiert: Es gibt eine „Basis“-Aufgabe, die in verschiedene Teilaufgaben unterteilt wird, welche wieder in unterschiedliche Teilaufgaben unterteilt wird und so weiter.
          Für Aufgaben ohne Teilaufgaben kann dann der Fortschritt auch direkt gesetzt werden.
        }
        {\none}
        {
          \method{pushTask}
                 {
                   \param{name}{String}{Der Name der Aufgabe.}
                 }
                 {Beginnt eine neue (Teil-)Aufgabe mit dem angegeben Namen.}
          \method{setSubTasks}
                 {
                   \param{weights}{float[]}{Die Gewichte der Teilaufgaben, jeweils im Intervall $[0,1]$.}
                   \item[] \emph{oder}
                   \param{count}{int}{Die Anzahl der Teilaufgaben.}
                 }
                 {
                   Legt fest, wie viele Teilaufgaben die aktuelle Aufgabe hat und wie sie gewichtet werden sollen.
                   In der zweiten Variante wird nur die Anzahl der Teilaufgaben festgelegt und sie werden als gleich gewichtet angenommen (jeweils Gewicht $\frac{1}{\refparam{ProgressReporter}{setSubTasks}{count}}$).
                 }
          \method{popTask}
                 {
                   \param{name}{String}{\emph{optional}: Der Name der Aufgabe, die entfernt werden soll.}
                 }
                 {
                   Beendet die Aufgabe mit dem angegebenen Namen und ihre Teilaufgaben, wenn \refparam{ProgressReporter}{popTask}{name} gegeben ist, sonst die aktuelle Aufgabe.
                   
                   Die Variante mit \refparam{ProgressReporter}{popTask}{name} erlaubt es, sich von Fehlern in Teilaufgaben zu erholen:
                   Wenn eine Aufgabe Exceptions in ihren Teilaufgaben abfängt, kann sie durch Angabe von \refparam{ProgressReporter}{popTask}{name} auch die Teilaufgaben beenden, die wegen der Exception nicht von den Teilaufgaben selbst beendet werden konnten.
                 }
          \method{nextTask}
                 {
                   \param{name}{String}{Der Name der neuen Aufgabe.}
                 }
                 {
                   Abkürzung für \code{\refmethod{ProgressReporter}{popTask}(); \refmethod{ProgressReporter}{pushTask}(name);}.
                 }
          \method{openTask}[CloseableTask]
                 {
                   \param{name}{String}{Der Name der Aufgabe.}
                 }
                 {
                   Beginnt eine neue (Teil-)Aufgabe mit dem angegebenen Namen und gibt eine \reftype{CloseableTask} zurück, die in einem try-with-resources Statement verwendet werden kann, um die Aufgabe auf jeden Fall abzuschließen, selbst wenn eine Teilaufgabe eine Exception wirft.
                 }
          \method{addProgressListener}
                 {
                   \param{listener}{ProgressListener}{Der \reftype{ProgressListener}, der bei Fortschritten benachrichtigt werden soll.}
                 }
                 {
                   Registriert einen \reftype{ProgressListener}, der bei Fortschritten benachrichtigt wird.
                 }
          \method{setProgress}
                 {
                   \param{progress}{float}{Der aktuelle Fortschritt.}
                 }
                 {
                   Setzt den Fortschritt der aktuellen Aufgabe direkt.
                   Darf nicht für Aufgaben verwendet werden, die Teilaufgaben haben (siehe \refmethod{ProgressReporter}{setSubTasks}).
                 }
          \method{getProgress}
                 {\none}
                 {
                   Gibt den aktuellen Gesamtfortschritt zurück.
                 }
          \method{getCurrentTask}
                 {\none}
                 {
                   Gibt den Namen der aktuellen Aufgabe zurück.
                 }
        }
  \class{CloseableTask}
        {
          Hilfsklasse für \refmethod{ProgressReporter}{openTask}.
          Implementiert \code{AutoCloseable}, kann also in try-with-resources Statements verwendet werden.
        }
        {\none}
        {
          \method{close}
                 {\none}
                 {
                   Beendet die Aufgabe, die mit dem zugehörigen \refmethod{ProgressReporter}{openTask} begonnen wurde.
                 }
        }
  \class{ProgressListener}
        {
          Interface, um bei Änderungen den Fortschritts in \reftype{ProgressReporter} benachrichtigt zu werden.
        }
        {\none}
        {
          \method{startRoot}
                 {
                   \param{name}{String}{Der Name der Basisaufgabe.}
                 }
                 {
                   Wird aufgerufen, wenn die Basisaufgabe des \reftype{ProgressReporter}s begonnen wird (erster Aufruf von \refmethod{ProgressReporter}{pushTask}).
                 }
          \method{beginTask}
                 {
                   \param{name}{String}{Der Name der (Teil-)Aufgabe.}
                 }
                 {
                   Wird aufgerufen, wenn eine neue (Teil-)Aufgabe begonnen wird (Aufruf von \refmethod{ProgressReporter}{pushTask} oder \refmethod{ProgressReporter}{nextTask}).
                   Für die Basisaufgabe wird diese Methode \emph{nach} \refmethod{ProgressListener}{startRoot} aufgerufen.
                 }
          \method{progress}
                 {
                   \param{progress}{float}{Der aktuelle Gesamtfortschritt.}
                   \param{name}{String}{Der Name der aktuellen (Teil)-Aufgabe.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Fortschritt ändert.
                   Bei Beenden einer Aufgabe wird diese Methode \emph{nach} \refmethod{ProgressListener}{endTask} aufgerufen.
                 }
          \method{endTask}
                 {
                   \param{name}{String}{Der Name der beendeten (Teil)-Aufgabe.}
                 }
                 {
                   Wird aufgerufen, wenn eine (Teil-)Aufgabe beendet wird (Aufruf von \refmethod{ProgressReporter}{popTask} oder \refmethod{ProgressReporter}{nextTask}).
                   Für die Basisaufgabe wird diese Methode \emph{vor} \refmethod{ProgressListener}{finishRoot} aufgerufen.
                 }
          \method{finishRoot}
                 {
                   \param{name}{String}{Der Name der beendeten Basisaufgabe.}
                 }
                 {
                   Wird aufgerufen, wenn die Basisaufgabe des \reftype{ProgressReporter}s beendet wird.
                 }
        }
}

\package{Map}{}
{
  \class{StreetMap}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert die Karte in den angegebenen Ordner.}
          \method{load}[StreetMap]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt eine Karte aus dem angegebenen Ordner.}
        }
  \class{Graph}{~}
        {\none}
        {
          \method{getNumberOfEdges}[int]
                 {\none}
                 {Gibt die Anzahl der Kanten zurück. Dies ermöglicht es, über alle Kanten zu iterieren.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert den Graphen in die angegebene Datei.}
          \method{load}[Graph]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt einen Graphen aus der angegebenen Datei.}
        }
  \class{EdgeBasedGraph}{~}
        {\none}
        {
          \method{getNumberOfTurns}[int]
                 {\none}
                 {Gibt die Anzahl der Abbiegemöglichkeiten zurück. Dies ermöglicht es, über alle Abbiegemöglichkeiten zu iterieren.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert den kantenbasierten Graphen in die angegebene Datei.}
          \method{load}[EdgeBasedGraph]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt einen kantenbasierten Graphen aus der angegebenen Datei.}
        }
  \class{NodeProperties}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert die \reftype{NodeProperties} in die angegebene Datei.}
          \method{load}[NodeProperties]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt \reftype{NodeProperties} aus der angegebenen Datei.}
        }
  \class{EdgeProperties}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert die \reftype{EdgeProperties} in die angegebene Datei.}
          \method{load}[EdgeProperties]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt \reftype{EdgeProperties} aus der angegebenen Datei.}
        }
  \class{Restriction}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {
                   Speichert die \reftype{Restriction}s in die angegebene Datei.
                   
                   Dazu wird zunächst der Typ der Restriction geschrieben und dann die Methode \code{saveInternal} aufgerufen, welche die einzelnen Unterklassen überschreiben.
                 }
          \method{load}[Restriction]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {
                   (statisch) Lädt \reftype{Restriction}s aus der angegebenen Datei.
                   
                   Dazu wird zunächst der Typ der Restriction gelesen und dann die Methode \code{loadInternal} aufgerufen, welche die einzelnen Unterklassen definieren.
                 }
        }
}

\package{Util}{}
{
  \class{Coordinates}{~}
        {\none}
        {
          \method{toString}[String]
                 {\none}
                 {Gibt eine String-Repräsentation der Koordinaten zurück, die von \refmethod{Coordinates}{fromString} wieder geparst werden kann.}
          \method{fromString}[Coordinates]
                 {
                   \param{coords}{String}{Der Koordinaten-String.}
                 }
                 {(statisch) Parst einen Koordinaten-String wie er von \refmethod{Coordinates}{toString} zurückgegeben wird.}
          \method{parseLatitude}[float]
                 {
                   \param{lat}{String}{Die Breitengrad-Angabe.}
                 }
                 {(statisch) Parst eine Breitengrad-Angabe aus einer Zeichenkette.}
          \method{parseLongitude}[float]
                 {
                   \param{lon}{String}{Die Längengrad-Angabe.}
                 }
                 {(statisch) Parst eine Längengrad-Angabe aus einer Zeichenkette.}
        }
}

\section{Komponententests}

\section{Arbeitsplanung}


\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
