% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands
\usepackage{xspace} % \xspace for use in commands: put a space only if no punctuation follows
\usepackage{enumitem} % for controlling indentation in list environments

\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\newcommand{\none}[0]{
%  % see http://tex.stackexchange.com/questions/61155/linespacing-without-packages
%  \setlength\lineskiplimit{-1000pt} % allow overflowing of lines
%  \linespread{0}\selectfont % don’t advance line after empty item
  \item[] keine.
}

\makeatletter

\newcommand{\@packagelabel}[1]{P:#1}
\newcommand{\@typelabel}[1]{T:#1} % for classes and enums
\newcommand{\@attrlabel}[2]{A:#1.#2}
\newcommand{\@methodlabel}[2]{M:#1.#2}
\newcommand{\@paramlabel}[3]{P:#1.#2.#3}
\newcommand{\@constantlabel}[2]{C:#1.#2}

% evaluate #2 if the label #1 exists, else #3.
\newcommand{\ifhaslabel}[3]{%
  \@ifundefined{r@#1}%
               {#3}%
               {#2}%
}

% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Klassen (ein oder mehrere \class)
\newcommand{\package}[3]{%
  \subsection{Paket #1}\label{\@packagelabel{#1}}
  #2
  \begin{description}
   #3%
  \end{description}
}
% Argumente:
% 1. Klassenname
% 2. Beschreibung
% 3. Attribute (ein oder mehrere \attr, oder \none)
% 4. Methoden (ein oder mehrere \method, oder \none)
\newcommand{\class}[4]{%
  \newcommand{\currentclass}[0]{#1}%
  \item[\namedlabel{\@typelabel{#1}}{\code{#1}}] #2
    \ifstrequal{#3#4}{\none\none}{%
      % \none attributes and \none methods, skip
    }{%
      \begin{description}[leftmargin=0em,itemindent=0em]
        \ifstrequal{#3}{\none}{%
          % \none attributes, skip
        }{%
        \item[Attribute] \hfill % \hfill forces the following description into the next line
          \begin{description}
            #3%
          \end{description}
        }%
        \ifstrequal{#4}{\none}{%
          % \none methods, skip
        }{%
        \item[Methoden] \hfill% \hfill forces the following description into the next line
          \begin{description}
            #4%
          \end{description}
        }%
      \end{description}
    }%
  \let\currentclass=\undefined%
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\attr}[3]{%
  \item[\namedlabel{\@attrlabel{\currentclass}{#1}}{\code{#1}}] #3 Typ:~\reftype{#2}
}
% Argumente:
% 1. Name
% 2. (optional) Typ – default: void (wird nicht angezeigt); wird automatisch gelinkt, falls vorhanden
% 3. Parameter (ein oder mehrere \param, oder \none)
% 4. Beschreibung
\NewDocumentCommand{\method}{m o m +m}{% the ‘+m’ means that parameter 4 can contain several paragraphs, see http://tex.stackexchange.com/questions/64328/blank-lines-break-xparse-or-ifthen-macro
  \newcommand{\currentmethod}[0]{#1}%
  \item[\namedlabel{\@methodlabel{\currentclass}{#1}}{\code{#1}}] #4%
    \ifstrequal{#3}{\none}{%
      % \none parameters, skip
    }{%
      \\Parameter:
      \begin{description}[leftmargin=0em,itemindent=0em]
        #3%
      \end{description}
    }%
    \IfValueTF{#2}% if the optional “type” argument is given...
              { Rückgabetyp:~\reftype{#2}}% then show the return type...
              {}% else don’t.
  \let\currentmethod=\undefined%
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\param}[3]{%
  \item[\namedlabel{\@paramlabel{\currentclass}{\currentmethod}{#1}}{\code{#1}}] #3 Typ:~\reftype{#2}%
}
% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Konstanten (ein oder mehrere \constant, oder \none)
\newcommand{\enum}[3]{%
  \newcommand{\currentenum}[0]{#1}%
  \item[\namedlabel{\@typelabel{#1}}{\code{#1}}] #2
    \ifstrequal{#3}{\none}{%
      % \none cases, skip
    }{%
      Instanzen:
      \begin{description}
        #3
      \end{description}
    }%
  \let\currentenum=\undefined%
}
% Argumente:
% 1. Name
% 2. Beschreibung
\newcommand{\constant}[2]{%
  \item[\namedlabel{\@constantlabel{\currentenum}{#1}}{\code{#1}}] #2
}

\NewDocumentCommand{\refpackage}{mO{#1}}{%
  \hyperref[\@packagelabel{#1}]{\code{#2}}\xspace%
}
% Argumente:
% 1. Typ (Klasse oder Enum)
% 2. (optional) Text – default: Typ
\NewDocumentCommand{\reftype}{mO{#1}}{%
  \def\@reftype@tmp@text{\code{#2}}%
  \ifhaslabel{\@typelabel{#1}}{% if the label exists...
    \hyperref[\@typelabel{#1}]{\@reftype@tmp@text}}{% then reference it...
    \@reftype@tmp@text}% else just print the text.
  \let\@reftype@tmp@text=\undefined%
}
% DEPRECATED
\NewDocumentCommand{\refclass}{mO{#1}}{%
  \GenericWarning{}{The command \refclass is deprecated -- use \reftype instead}%
  \reftype{#1}[#2]%
}
% Argumente:
% 1. Klasse
% 2. Attribut
% 3. (optional) Text – default: Attribut innerhalb der Klasse, sonst Klasse.Attribut
\NewDocumentCommand{\refattr}{mmO{__DEFAULT__}}{%
  \def\@refattr@tmp@text{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the attribute name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}\xspace}
  \ifhaslabel{\@attrlabel{#1}{#2}}{% if the label exists...
    \hyperref[\@attrlabel{#1}{#2}]{\@refattr@tmp@text}}{% the reference it...
    \@refattr@tmp@text}% else just print the text.
  \let\@refattr@tmp@text=\undefined%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. (optional) Text – default: Methode innerhalb der Klasse, sonst Klasse.Methode
\NewDocumentCommand{\refmethod}{mmO{__DEFAULT__}}{%
  \def\@refmethod@tmp@text{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the method name
        }{%
          #1.#2%
        }%
      }{%
        #3%
    }}\xspace}%
  \ifhaslabel{\@methodlabel{#1}{#2}}{% if the label exists...
    \hyperref[\@methodlabel{#1}{#2}]{\@refmethod@tmp@text}}{% then reference it...
    \@refmethod@tmp@text}% else just print the text.
  \let\@refmethod@tmp@text=\undefined%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. Parameter
% 4. (optional) Text – default: Parameter innerhalb der Methode, sonst Methode.Parameter innerhalb der Klasse, sonst Klasse.Methode.Parameter
\NewDocumentCommand{\refparam}{mmmO{__DEFAULT__}}{%
  \def\@refparam@tmp@text{\code{%
      \ifthenelse{\equal{#4}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          \ifthenelse{\equal{\currentmethod}{#2}}{%
            #3% we’re inside the same method, only use the parameter name
          }{%
            #2.#3% we’re inside the same class, only use the method and parameter name
        }}{%
          #1.#2.#3%
      }}{%
        #4%
  }}\xspace}%
  \ifhaslabel{\@paramlabel{#1}{#2}{#3}}{% if the label exists...
    \hyperref[\@paramlabel{#1}{#2}{#3}]{\@refparam@tmp@text}}{% then reference it...
      \@refparam@tmp@text}% else just print the text.
  \let\@refparam@tmp@text=\undefined%
}
% Argumente:
% 1. Enum
% 2. Konstante
% 3. (optional) Text – default: Konstante innerhalb der Enum, sonst Enum.Konstante
\NewDocumentCommand{\refconstant}{mmO{__DEFAULT__}}{%
  \def\@refconstant@tmp@text{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentenum}{#1}}{%
          #2% we’re inside the same enum, only use the constant name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}\xspace}%
  \ifhaslabel{\@constantlabel{#1}{#2}}{% if the label exists...
    \hyperref[\@constantlabel{#1}{#2}]{\@refconstant@tmp@text}}{% then reference it...
    \@refconstant@tmp@text}% else just print the text.
  \let\@refconstant@tmp@text=\undefined%
}


\makeatother

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{%
  \glsdoifexists{#2}{%
    \def\@glsnumberformat{glsgobblenumber}%
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}%
    \setkeys{glossadd}{#1}%
    \@gls@saveentrycounter%
    \@do@wrglossary{#2}%
  }%
}
\newcommand{\glsaddallunused}[1][]{%
  \edef\@glo@type{\@glo@types}%
  \setkeys{glossadd}{#1}%
  \forallglsentries[\@glo@type]{\@glo@entry}{%
    \ifglsused{\@glo@entry}{}{%
      \typeout{****Glossary entry '\@glo@entry' unused****}%
      \glsaddnp[#1]{\@glo@entry}}}%
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

\makeatletter

\begin{document}
\shorthandoff{"}

\sloppy % fix overfull hboxes

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\emph{routeKIT}\xspace}


% alle Glossareinträge
\newglossaryentry{profil}{
  name={Profil},
  description={enthält für die Routenplanung relevante Informationen, z.\,B. die Höhe und das Gewicht des Fahrzeugs},
  plural={Profile}
}
\newglossaryentry{karte}{
  name={Karte},
  description={enthält die Daten aus \gls{osm} sowie einen Namen},
  plural={Karten}
}
\newglossaryentry{osmkachel}{
  name={OSM-Kachel},
  description={die öffentlichen gerenderten \gls{osm}-Kacheln z.\,B. auf\\\mbox{\url{http://a.tile.openstreetmap.org/}}},
  plural={OSM-Kacheln}
}
\newglossaryentry{route}{
  name={Route},
  description={ein Weg von einem Start- zu einem Zielpunkt},
  plural={Routen}
}
\newglossaryentry{vorberechnung}{
  name={Vorberechnung},
  description={verbindet die \gls{karte} mit den auf einem \gls{profil} basierenden Informationen und ermöglicht, unter anderem mittels \gls{arc}, später eine Beschleunigung der Berechnung einer \gls{route}; muss für jede neue \gls{karte}/\gls{profil}-Kombination einmal ausgeführt werden},
  plural={Vorberechnungen},
  see={arc}
}
\newglossaryentry{rendern}{
  name={rendern},
  description={Berechnung einer Bildkachel aus den zu rendernden Daten}
}
\newglossaryentry{wegbeschreibung}{
  name={Wegbeschreibung},
  description={Beschreibung einer \gls{route} durch eine Liste von Abbiegeanweisungen}
}
\newglossaryentry{dijkstra}{
  name={Dijkstra’s Algorithmus},
  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
}
\newglossaryentry{arc}{
 name={Arc-Flags},
 description={eine Technik, um eine Routenberechnung zu beschleunigen}
}
\newglossaryentry{verlauf}{
  name={Verlauf},
  description={speichert Routenanfragen für spätere Wiederverwendung. Es existiert nur ein Verlauf für die gesamte Anwendung}
}
\newglossaryentry{mercator}{
  name={Mercator-Projektion},
  description={die Zylinderprojektion der Weltkugel}
}
\newglossaryentry{entwurfsmuster}{
  name={Entwurfsmuster},
  description={Eine Schablone, die eine Lösung für ein oder mehrere Entwurfsprobleme darstellt. Ihre Verwendung erleichtert Änderungen im Entwurf}
}
\newglossaryentry{beobachter}{
  name={Beobachter},
  description={Ein \gls{entwurfsmuster}, das bei Änderung des Zustands eines Objektes alle abhängenden Objekte banachrichtigt}
}
\newglossaryentry{einzelstueck}{
  name={Einzelstück},
  description={Ein \gls{entwurfsmuster}, das zusichert, dass eine Klasse genau ein Exemplar besitzt und stellt einen globalen Zugriffspunkt darauf bereit}
}
\newglossaryentry{dekorierer}{
  name={Dekorierer},
  description={Ein \gls{entwurfsmuster}, das dynamisch neue Funktionalität zum Objekt hinzufügt}
}
\newglossaryentry{strategie}{
  name={Strategie},
  description={Ein \gls{entwurfsmuster}, das eine Familie von Algorithmen definiert, sie kapselt und austauschbar macht}
}
\newglossaryentry{G_smt}{
  name={Slippy Map Tile},
  description={
    Koordinaten, durch die Kartenkacheln einer graphischen Darstellung (mit \gls{mercator}) adressiert werden können.
    Drei Bestandteile: x, y, zoom.
    Mit nicht-ganzzahligen Werten für x und y können nicht nur Kacheln, sondern auch Geokoordinaten adressiert werden}
}
\newglossaryentry{smt}{
  type=\acronymtype,
  name={SMT},
  description={Slippy Map Tile},
  first={Slippy Map Tile (SMT)},
  see=[Glossareintrag:]{G_smt}
}
\newglossaryentry{opaque}{
  name={deckend},
  description={
    Die innere Implementierung wird vor anderen Klassen verborgen; Zugriff ist nur über das definierte Interface der Klasse/Methode möglich. (engl. “opaque”)}
}

\newacronym[longplural=Personenkraftwagen]{pkw}{PKW}{Personenkraftwagen}
\newacronym[longplural=Lastkraftwagen]{lkw}{LKW}{Lastkraftwagen}
\newacronym{osm}{OSM}{OpenStreetMap}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{gpx}{GPX}{GPS Exchange Format}
\newacronym{mvc}{MVC}{Model View Controller}
\newacronym{cli}{CLI}{Command Line Interface}



\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Implementierungsbericht}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage


\section{Einleitung}
Dieses Dokument erläutert die Implementierung der Anwendung \routeKIT. Es dokumentiert die durchgeführten Änderungen am Entwurf, die zur Realisierung der Implementierung notwendig waren. Außerdem beschreibt es die Arbeitsplanung und den tatsächlichen Arbeitsablauf der Implementierung.

\routeKIT ist eine Anwendung zur Routenplanung; durch Verwendung von \glslink{profil}{Profilen} kann sie dem Benutzer die optimalen \glspl{route} für sein spezielles Fahrzeug angeben.
Um die Routenberechnung zu beschleunigen, wird pro \gls{profil} und \gls{karte} eine zeitaufwändige \gls{vorberechnung} durchgeführt.

\section{Änderungen am Entwurf}
Im Folgenden sind die gegenüber dem ursprünglichen Entwurf geänderten und neu hinzugefügten Klassen, Methoden und Attribute aufgeführt.

\subsection{(ohne Paket)}
\begin{description}
  \class{routeKIT}
        {
          Diese neue Klasse existiert ausschließlich, um den kurzen Aufruf
          \code{java routeKIT}
          zu ermöglichen.
        }
        {\none}
        {
          \method{main}
                 {
                   \param{args}{String[]}{Kommandozeilenargumente.}
                 }
                 {
                   Leitet weiter auf \refmethod{MainController}{main}.
                 }
        }
\end{description}

\package{Controllers}{
  Es wurde eine neue Klasse \reftype{ProfileMapManager} eingeführt, die alle dem Programm bekannten \glspl{vorberechnung} halten und sie speichern und laden.
}
{
  \class{ProfileManager}{~}
        {\none}
        {
          \method{init}
                 {
                   \param{rootDirectory}{File}{siehe \refparam{ProfileMapManager}{init}{rootDirectory}.}
                 }
                 {
                   (statisch) Initialisiert den \code{ProfileManager}, indem alle in \refparam{ProfileManager}{init}{rootDirectory} liegenden \code{.profile}-Dateien \refmethod{Profile}{load}[geladen] werden.
                   Darf nur einmal aufgerufen werden.
                 }
          \method{getInstance}[ProfileManager]
                 {\none}
                 {
                   (statisch) Gibt die \code{ProfileManager}-Instanz zurück.
                   \refmethod{ProfileManager}{init} muss zuvor aufgerufen worden sein.

                   Für die Diskussion des \gls{einzelstueck}-Entwurfsmusters siehe \refmethod{ProfileMapManager}{init}.
                 }
        }
  \class{MapManager}{~}
        {\none}
        {
          \method{init}
                 {
                   \param{rootDirectory}{File}{siehe \refparam{ProfileMapManager}{init}{rootDirectory}}
                 }
                 {
                   (statisch) Initialisiert den \code{MapManager}, indem alle in \refparam{MapManager}{init}{rootDirectory} liegenden Ordner \refmethod{StreetMap}{load}[geladen] werden.
                   Darf nur einmal aufgerufen werden.
                 }
          \method{getInstance}[MapManager]
                 {\none}
                 {
                   (statisch) Gibt die \code{MapManager}-Instanz zurück.
                   \refmethod{ProfileManager}{init} muss zuvor aufgerufen worden sein.
                   
                   Für die Diskussion des \gls{einzelstueck}-Entwurfsmusters siehe \refmethod{ProfileMapManager}{init}.
                 }
        }
  \class{ProfileMapManager}
        {
          Der \code{ProfileMapManager} verwaltet alle \glspl{vorberechnung}: er lädt sie beim Programmstart von der Festplatte, löscht sie auf Anfrage, speichert sie und hält eine Liste aller \glspl{vorberechnung}.
          Außerdem kennt er die aktuell ausgewählte \reftype{ProfileMapCombination} (die nicht zwangsläufig vorberechnet ist).
        }
        {\none}
        {
          \method{init}[ProfileMapCombination]
                 {
                   \param{rootDirectory}{File}{Das Verzeichnis, in dem die Daten dieser \routeKIT-Installation liegen.}
                 }
                 {
                   (statisch) Initialisiert den \code{ProfileMapManager}, indem der \reftype{ProfileManager} und der \reftype{MapManager} initialisiert werden und eine Index-Datei (\code{routeKIT.idx}) gelesen wird, die alle Vorberechnungen auflistet und die aktuelle \reftype{ProfileMapCombination} angibt.
                   
                   Der Rückgabewert ist die aktuelle \reftype{ProfileMapCombination}.
                 }
          \method{getInstance}[ProfileMapManager]
                 {\none}
                 {
                   (statisch) Gibt die \code{ProfileMapManager}-Instanz zurück.
                   \refmethod{ProfileMapManager}{init} muss zuvor aufgerufen worden sein.
                   
                   
                   Es handelt sich hierbei um eine Variante des \gls{einzelstueck}-Entwurfsmusters:
                   \refmethod{ProfileMapManager}{init} wird normalerweise durch \refmethod{ProfileMapManager}{getInstance} implizit durchgeführt, wenn noch keine Instanz vorhanden ist.
                   Hier wurden die beiden Methoden getrennt, da es sich bei \refmethod{ProfileMapManager}{init} um eine verhältnismäßig teure Operation handelt (beinhaltet Festplattenaktivität), die nicht beliebig beim ersten Aufruf von \refmethod{ProfileMapManager}{getInstance} stattfinden sollte, sondern nur an einer bestimmten Stelle während des Programmstarts.
                 }
          \method{getPrecalculations}[Set<ProfileMapCombination>]
                 {\none}
                 {
                   Gibt alle dem \code{ProfileMapManager} bekannten \glspl{vorberechnung} zurück.
                 }
          \method{getCurrentCombination}[ProfileMapCombination]
                 {\none}
                 {
                   Gibt die aktuell ausgewählte \reftype{ProfileMapCombination} zurück.
                   Diese muss nicht unbedingt ein Element aus \refmethod{ProfileMapManager}{getPrecalculations} sein, da sie möglicherweise nicht vorberechnet ist.
                 }
          \method{addCurrentCombinationListener}
                 {
                   \param{listener}{CurrentCombinationListener}{Der Listener, der benachrichtigt werden soll.}
                 }
                 {
                   Registriert einen \reftype{CurrentCombinationListener}, der bei Änderungen der aktuellen \reftype{ProfileMapCombination} benachrichtigt werden soll.
                 }
          \method{selectProfileAndMap}[ProfileMapCombination]
                 {
                   \param{profile}{Profile}{Das aktuelle \gls{profil}.}
                   \param{map}{StreetMap}{Die aktuelle \gls{karte}.}
                 }
                 {
                   Wählt das angegebene Profil und die angegebene Karte aus.
                   Existiert eine \gls{vorberechnung} für dieses Profil und diese Karte, so wird sie verwendet, ansonsten wird eine neue \reftype{ProfileMapCombination} erstellt.
                   
                   Gibt die ausgewählte \reftype{ProfileMapCombination} zurück.
	        Diese Methode ersetzt die im Entwurf in \code{MainController} angegebenen Methoden selectProfile(:Profile) und selectMap(:StreetMap).
                 }
          \method{getPrecalculation}[ProfileMapCombination]
                 {
                   \param{profile}{Profile}{Das aktuelle \gls{profil}.}
                   \param{map}{StreetMap}{Die aktuelle \gls{karte}.}
                 }
                 {
                   Sucht nach einer Vorberechnung für dieses Profil und diese Karte und gibt sie zurück, ansonsten wird \code{null} zurückgegeben.
                 }
          \method{setCurrentCombination}
                 {
                   \param{combination}{ProfileMapCombination}{Die ausgewählte \reftype{ProfileMapCombination}.}
                 }
                 {
                   Setzt die angegebene \reftype{ProfileMapCombination} als aktuelle Kombination.
                   Ist sie vorberechnet, so wird sie gespeichert und eine neue Index-Datei wird geschrieben.
                   Außerdem werden registrierte \reftype{CurrentCombinationListener} benachrichtigt.
                 }
          \method{savePrecalculation}
                 {
                   \param{precalculation}{ProfileMapCombination}{Die \reftype{ProfileMapCombination}, die gespeichert werden soll.}
                 }
                 {
                   Speichert die angegebene Vorberechnung in der internen Liste und auf der Festplatte.
                   Dies ist nur zulässig, wenn es sich dabei überhaupt um eine Vorberechnung handelt (und nicht etwa um eine \reftype{ProfileMapCombination} ohne Vorberechnung).
                   Schreibt eine neue Index-Datei.
                 }
          \method{deletePrecalculation}
                 {
                   \param{precalculation}{ProfileMapCombination}{Die \reftype{ProfileMapCombination}, die gelöscht werden soll.}
                   \param{deleteFromDisk}{boolean}{\emph{optional}: Wenn \code{false}, wird die \gls{vorberechnung} nicht von der Festplatte gelöscht.}
                 }
                 {
                   Löscht die angegeben Vorberechnung aus der internen Liste und, falls nicht anders angegeben, von der Festplatte.
                   Dies ist nur zulässig, wenn es sich dabei überhaupt um eine Vorberechnung handelt (und nicht etwa um eine \reftype{ProfileMapCombination} ohne Vorberechnung).
                   Schreibt eine neue Index-Datei.
                   
                   Die zweite Variante ist nur dann sinnvoll, wenn alle \glspl{vorberechnung} einer \gls{karte} zusammen mit der Karte gelöscht werden sollen;
                   da sie in Unterordnern der Karte gespeichert sind, würden sie durch das Löschen des Karten-Ordners ohnehin gelöscht.
                 }
        }
  \class{MapManagerController.MapManagementDiff}
        {
          Innere Klasse von \reftype{MapManagerController}, welche die Änderungen, die der Benutzer getätigt hat, kapselt.
          Sie war ursprünglich nur für den internen Gebrauch in \refmethod{MapManagerController}{saveAllChanges} gedacht, wird jetzt aber auch der \reftype{MapManagerView} zugänglich gemacht, welche das Ergebnis im „Bestätigen“-Dialog verwendet und anzeigt.
          
          Die analoge Klasse \reftype{ProfileManagerController.ProfilesDiff} ist weiterhin \code{private}, da sie außerhalb des \reftype{ProfileManagerController}s nicht benötigt wird.
        }
        {\none}
        {
          \method{getNewOrUpdatedMaps}[Set<FutureMap>]
                 {\none}
                 {
                   Alle Karten, die importiert oder aktualisiert wurden, also neu importiert werden müssen.
                   
                   (\code{FutureMap} ist eine interne Klasse, die nur den vom Benutzer angegebenen Dateinamen hält.)
                 }
          \method{getDeletedMaps}[Set<StreetMap>]
                 {\none}
                 {
                   Alle Karten, die gelöscht werden müssen (auch die alten Versionen von aktualisierten Karten).
                 }
          \method{getDeletedPrecalculations}[Set<ProfileMapCombination>]
                 {\none}
                 {
                   Alle Vorberechnungen, die gelöscht werden müssen (weil ihre Karten aktualisiert oder gelöscht wurden, oder weil die Vorberechnung explizit gelöscht wurde).
                 }
          \method{getNewPrecalculations}[Set<ProfileMapCombination>]
                 {\none}
                 {
                   Alle Vorberechnungen, die durchgeführt werden müssen (neue und solche mit aktualisierter Karte).
                 }
        }
  \class{MainController}{~}
        {\none}
        {
	\method{MainController}
	{\param{pr}{ProgressReporter}{Wird zum Anzeigen des Fortschritts beim Start des Programms gebraucht.}}
	{~}
          \method{getInstance}[MainController]
                 {\none}
                 {(statisch) Gibt die Instanz des \reftype{MainControllers} zurück, der ein \gls{einzelstueck} ist.}
          \method{getHistory}[History]
                 {\none}
                 {Gibt den Verlauf zurück.}
        }
  \class{ProfileManagerController}{~}
        {\none}
        {
          \method{getDeletedPrecalculations}[Set<ProfileMapCombination>]
                 {\none}
                 {
                   Gibt alle zu löschenden \glspl{vorberechnung} zurück, damit sie dem Benutzer vor dem Löschen angezeigt werden.
                 }
          \method{getSelectedProfile}[Profile]
                 {\none}
                 {
                   Gibt das \gls{profil} zurück, das der Benutzer ausgewählt hat.
                   Wenn der Dialog noch nicht oder durch „Abbrechen“ geschlossen wurde, wird \code{null} zurückgegeben.
                 }
        }
  \class{MapManagerController}{~}
        {\none}
        {
          \method{MapManagerController}
	         {
                   \param{view}{MainView}{Das Hauptfenster der Anwendung.}
                 }
	         {~}
          \method{getChanges}[MapManagementDiff]
                 {\none}
                 {
                   Gibt alle Änderungen zurück, die der Benutzer bis jetzt vorgenommen hat, aber die noch nicht bestätigt wurden.
                 }
          \method{getSelectedMap}[StreetMap]
                 {\none}
                 {
                   Gibt die \gls{karte} zurück, die der Benutzer ausgewählt hat.
                   Wenn der Dialog noch nicht oder durch „Abbrechen“ geschlossen wurde, wird \code{null} zurückgegeben.
                 }
	\method{changeMap}
	{\param{mapName}{String}{Geändert: Die GUI kann keine Objekte vom Typ \code{Map} übergeben. Die GUI verwaltet nur die Namen der Karten.}}
          {~}
	\method{removeProfile}
	{\param{profileName}{String}{Geändert: Die GUI kann keine Objekte vom Typ \code{Profile} übergeben.  Die GUI verwaltet nur die Namen der Profile.}}
	{~}
        }
  \class{CLI}
        {
          Neue Klasse, die das \gls{cli} kapselt. Implementiert \reftype{ProgressListener}.
        }
        {\none}
        {
          \method{doImport}
                 {
                   \param{mapPath}{String}{Der Pfad zur Kartendatei, die importiert werden soll.}
                   \param{mapName}{String}{Der Name der Karte, die importiert werden soll.}
                   \param{profileName}{String}{Der Name des Profils, für das auf der importierten Karte eine Vorberechnung durchgeführt werden soll.}
                 }
                 {
                   Importiert eine Karte und führt anschließend eine Vorberechnung für diese Karte durch.
                 }
        }
}
\package{Precalculation}{
Die Klassen \reftype{ArkFlagCalculator} und \reftype{EdgeWeighter} wurden zu Interfaces, die von den neuen Klassen \reftype{ArcFlagCalculatorImpl}, \reftype{ArcFlagCalculatorParallel} und \reftype{EdgeWeighterImpl} implementiert werden.
Vielen Klassen wird nun ein \reftype{ProgressReporter} als Parameter übergeben.
}
{
  \class{PreCalculator}{Führt die Vorberechnung für die angegebene Kombination aus.}
         {\none}
         {
           \method{doPrecalculation}
                  {
                    \param{reporter}{ProgressReporter}{Neuer Parameter. Wird zum Anzeigen des Fortschritts bei der \gls{arc}-Berechnung gebraucht.}
                  }
                  {Führt die Vorberechnung für die angegebene Kombination durch.}
         }
  \class{ArcFlagsCalculator}{Geändert: Ein Interface für die Berechnung der \gls{arc}}
        {\none}
        {
          \method{calculateArcFlags}
                 {
                   \param{reporter}{ProgressReporter}{Neuer Parameter. Wird zum Anzeigen des Fortschritts bei der \gls{arc}-Berechnung gebraucht.}
                 }
                 {Berechnet die \gls{arc} für die angegebene Kombination und setzt sie entsprechend.}
        }
  \class{ArcFlagsCalculatorImpl}{Geändert: Ersetzt die Klasse \code{ArcFlagsCalculator} aus dem Entwurf. Implementiert das Interface \reftype{ArcFlagsCalculator}}
        {\none}
        {
          \method{calculateArcFlags}
                 {
                   \param{reporter}{ProgressReporter}{Neuer Parameter. Wird zum Anzeigen des Fortschritts bei der \gls{arc}-Berechnung gebraucht.}
                 }
                 {Berechnet die \gls{arc} für die angegebene Kombination und setzt sie entsprechend.}
        }
  \class{ArcFlagsCalculatorParallel}{Neue Klasse. Verwendet im Gegensatz zu \reftype{ArcFlagsCalculatorImpl} mehrere parallel laufende Threads, um die Vorberechnung zu beschleunigen. Implementiert das Interface \reftype{ArcFlagsCalculator}}
          {\none}
          {
            \method{calculateArcFlags}
                   {
                     \param{reporter}{ProgressReporter}{Neuer Parameter. Wird zum Anzeigen des Fortschritts bei der \gls{arc}-Berechnung gebraucht.}
                   }
                   {Berechnet die \gls{arc} für die angegebene Kombination und setzt sie entsprechend.}
          }
  \class{EdgeWeighter}{Geändert: Ein Interface für die Berechnung der Kantengewichte.}
        {\none}
        {
          \method{weightEdges}
                 {
                   \param{reporter}{ProgressReporter}{Neuer Parameter. Wird zum Anzeigen des Fortschritts bei der Gewichte-Berechnung gebraucht.}
                 }
                 {Versieht den kantenbasierten Graphen mit Kantengewichten.}
        }
  \class{EdgeWeighterImpl}{Geändert: Erstzt die Klasse \code{EdgeWeighter} aus dem Entwurf. Implementiert das Interface \reftype{EdgeWeighter}}
        {\none}
        {
          \method{weightEdges}
                 {
                   \param{reporter}{ProgressReporter}{Neuer Parameter. Wird zum Anzeigen des Fortschritts bei der Gewichte-Berechnung gebraucht.}
                 }
                 {Versieht den kantenbasierten Graphen mit Kantengewichten.}
        }
  \class{OSMMapImporter}{Neuer Name für die Klasse \reftype{MapImporter}, welche nun die Schnittstelle \code{MapImporter} implementiert.}
        {\none}
        {\none}
  \class{OSMParser}{~}
        {\none}
        {
          \method{parseOSM}
                 {\none}
                 {Geändert: Der Parameter \code{name} wurde entfernt. Der Name der Karte wird erst später vom \reftype{MapImporter} gesetzt.}
        }
  \class{OSMWay}{~}
        {\none}
        {
          \method{isReversedOneway}[boolean]
                 {\none}
                 {Bestimmt, ob es sich um eine Einbahnstraße entgegen der Wegrichtung handelt (OSM-Tag \code{oneway=-1}).}
          \method{isHighwayLink}[boolean]
                 {\none}
                 {Bestimmt, ob es sich um eine Anschluss- bzw. Verbindungsstraße (z.\,B. Auf- oder Abfahrt) handelt.}
        }
  \class{MapEdge}{~}
        {
          \attr{targetNode}{Node}{Geändert: Speichert nun direkt den Zielknoten und nicht mehr dessen ID in der OSM-Datei. Dadurch werden unnötige Hashtabellenabfragen in \reftype{OSMParser} vermieden.}
          \attr{Id}{Edge}{Der interne Bezeichner der Kante.}
        }
        {\none}
        
  \class{TurnRestriction}{~}
        {
          \attr{from}{int}{Die OSM-Way-ID des Wegs, von dem die Abbiegebeschränkung definiert ist.}
          \attr{to}{MapEdge}{Die Kante, auf die die Abbiegebeschränkung definiert ist.}
        }
        {
          \method{TurnRestriction}
                 {\none}
                 {Geänderter Konstruktor: Parameter \code{from} und \code{to} (die Werte der gleichnamigen Attribute) hinzugefügt.}
          \method{allowsTo}[boolean]
                 {
                   \param{to}{MapEdge}{Die Kante, auf die abgebogen werden soll.}
                 }
                 {Gibt an, ob diese Abbiegebeschränkung das Abbiegen auf die angegebene Kante erlaubt oder nicht.}
        }
}

\package{RouteCalculator}{}
{
  \class{Route}{Diese Klasse implementiert nun die Schnittstelle \code{Iterable}.}
        {\none}
        {
          \method{iterator}[Iterator<Coordinates>]
                 {\none}
                 {Gibt einen Iterator über die Koordinaten der Routenpunkte einschließlich Start- und Zielpunkt zurück. Diese Methode ersetzt \code{getNodeIterator}.}
        }
  \class{FibonacciHeapEntry}{Neue Klasse. Stellt einen Eintrag des \reftype{FibonacciHeap} dar.}
        {
          \attr{degree}{int}{Der Grad eines Eintrags.}
          \attr{marked}{boolean}{Legt fest, ob ein Eintrag markiert wurde.}
          \attr{parent}{FibonacciHeapEntry}{Der Eltern-Eintrag zur diesem Eintrag.}
          \attr{child}{FibonacciHeapEntry}{Der Kind-Eintrag zur diesem Eintrag.}
          \attr{next}{FibonacciHeapEntry}{Der nächste Eintrag.}
          \attr{prev}{FibonacciHeapEntry}{Der vorherige Eintrag.}
          \attr{value}{int}{Speichert den Wert des Eintrags.}
          \attr{priority}{int}{Speichert die Priorität des Eintrags.}
        }
        {
          \method{FibonacciHeapEntry}
                 {
                 	\param{value}{int}{Der Wert für den neuen Eintrag.}
                 	\param{priority}{int}{Die Priorität für den neuen Eintrag.}
                 }
                 {Konstruktor für eine FibonacciHeapEntry.}
          \method{increaseDegree}
                 {\none}
                 {Erhöht den Grad des Eintrags um eins.}
          \method{decreaseDegree}
                 {\none}
                 {Verringert den Grad des Eintrags um eins.}
        }
  \class{FibonacciHeap}{Diese Klasse stellt einen Fibonacci-Heap dar, der vom \code{ArcFlagsDijkstra} und der Vorberechnung genutzt wird.}
        {\none}
        {
          \method{isEmpty}[boolean]
                 {\none}
                 {Prüft, ob der Fibonacci-Heap leer ist.}
          \method{getSize}[int]
                 {\none}
                 {Gibt die Anzahl der Elemente, die sich gerade im Fibonacci-Heap befinden, zurück. Sehr nützlich z.\,B. für Testfälle.}
          \method{add}[FibonacciHeapEntry]
                 {
                 	\param{value}{int}{Der Wert für den neuen Eintrag.}
                 	\param{priority}{int}{Die Priorität für den neuen Eintrag.}
                 }
                 {Fügt einen neuen Eintrag mit dem gegebenen Wert und der Priorität in den Fibonacci-Heap ein und gibt das neu eingefügte Element zurück.}
          \method{deleteMin}[FibonacciHeapEntry]
                 {\none}
                 {Entfernt das Element mit der niedrigsten Priorität aus dem Fibonacci-Heap und gibt es zurück.}
          \method{decreaseKey}
                 {
                 	\param{entry}{FibonacciHeapEntry}{Der Eintrag, welcher aktualisiert werden soll.}
                 	\param{newPriority}{int}{Die neue Priorität für den Eintrag.}
                 }
                 {Aktualisiert die Priorität eines gegebenen Eintrags.}
        }
}

\package{Models}{}
{
  \class{ProfileMapCombination}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{directory}{File}{Der Ordner, in den geschrieben werden soll.}
                 }
                 {
                   Speichert die Vorberechnung in den angegebenen Ordner.
                 }
          \method{load}[ProfileMapCombination]
                 {
                   \param{directory}{File}{Der Ordner, aus dem geladen werden soll.}
                 }
                 {
                   (statisch) Lädt eine Vorberechnung aus dem angegebenen Ordner.
                 }
          \method{loadLazily}[ProfileMapCombination]
                 {
                   \param{directory}{File}{Der Ordner, aus dem geladen werden soll.}
                 }
                 {
                   (statisch) Gibt eine \reftype{ProfileMapCombination} zurück, die erst beim ersten Zugriff auf \refmethod{ProfileMapCombination}{getWeights} bzw. \refmethod{ProfileMapCombination}{getArcFlags} diese auch aus dem angegebenen Ordner lädt.
                   Diese Methode wird verwendet, um die Startzeit des Programms zu verbessern:
                   Die Information, welche Vorberechnungen existieren, soll zwar jederzeit verfügbar sein, allerdings werden nicht alle Vorberechnungen sofort benötigt.
                 }
          \method{ensureLoaded}
                 {
                   \param{reporter}{ProgressReporter}{Der \reftype{ProgressReporter}, dem der Ladefortschritt gemeldet werden soll.}
                 }
                 {
                   Nach Aufruf dieser Methode ist garantiert, dass auch eine Vorberechnung, welche mittels \refmethod{ProfileMapCombination}{loadLazily} geladen wurde, vollständig geladen ist.
                   Spätere Aufrufe von \refmethod{ProfileMapCombination}{getWeights} bzw. \refmethod{ProfileMapCombination}{getArcFlags} sind dann garantiert schnell.
                 }
        }
  \class{Weights}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert die \reftype{Weights} in die angegebene Datei.}
          \method{load}[Weights]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt \reftype{Weights} aus der angegebenen Datei.}
        }
  \class{ArcFlags}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert die \reftype{ArcFlags} in die angegebene Datei.}
          \method{load}[ArcFlags]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt \reftype{ArcFlags} aus der angegebenen Datei.}
        }
  \class{ProgressReporter}
        {
          Neue Klasse, um den Fortschritt bei verschiedenen Aktionen, etwa der Vorberechnung, dem Benutzer anzeigen zu können.
          
          Der \reftype{ProgressReporter} ist Aufgaben-basiert: Es gibt eine „Basis“-Aufgabe, die in verschiedene Teilaufgaben unterteilt wird, welche wieder in unterschiedliche Teilaufgaben unterteilt wird und so weiter.
          Für Aufgaben ohne Teilaufgaben kann dann der Fortschritt auch direkt gesetzt werden.
        }
        {\none}
        {
          \method{pushTask}
                 {
                   \param{name}{String}{Der Name der Aufgabe.}
                 }
                 {Beginnt eine neue (Teil-)Aufgabe mit dem angegeben Namen.}
          \method{setSubTasks}
                 {
                   \param{weights}{float[]}{Die Gewichte der Teilaufgaben, jeweils im Intervall $[0,1]$.}
                   \item[] \emph{oder}
                   \param{count}{int}{Die Anzahl der Teilaufgaben.}
                 }
                 {
                   Legt fest, wie viele Teilaufgaben die aktuelle Aufgabe hat und wie sie gewichtet werden sollen.
                   In der zweiten Variante wird nur die Anzahl der Teilaufgaben festgelegt und sie werden als gleich gewichtet angenommen (jeweils Gewicht $\frac{1}{\refparam{ProgressReporter}{setSubTasks}{count}}$).
                 }
          \method{popTask}
                 {
                   \param{name}{String}{\emph{optional}: Der Name der Aufgabe, die entfernt werden soll.}
                 }
                 {
                   Beendet die Aufgabe mit dem angegebenen Namen und ihre Teilaufgaben, wenn \refparam{ProgressReporter}{popTask}{name} gegeben ist, sonst die aktuelle Aufgabe.
                   
                   Die Variante mit \refparam{ProgressReporter}{popTask}{name} erlaubt es, sich von Fehlern in Teilaufgaben zu erholen:
                   Wenn eine Aufgabe Exceptions in ihren Teilaufgaben abfängt, kann sie durch Angabe von \refparam{ProgressReporter}{popTask}{name} auch die Teilaufgaben beenden, die wegen der Exception nicht von den Teilaufgaben selbst beendet werden konnten.
                 }
          \method{nextTask}
                 {
                   \param{name}{String}{Der Name der neuen Aufgabe.}
                 }
                 {
                   Abkürzung für \code{\refmethod{ProgressReporter}{popTask}(); \refmethod{ProgressReporter}{pushTask}(name);}.
                 }
          \method{openTask}[CloseableTask]
                 {
                   \param{name}{String}{Der Name der Aufgabe.}
                 }
                 {
                   Beginnt eine neue (Teil-)Aufgabe mit dem angegebenen Namen und gibt eine \reftype{CloseableTask} zurück, die in einem try-with-resources Statement verwendet werden kann, um die Aufgabe auf jeden Fall abzuschließen, selbst wenn eine Teilaufgabe eine Exception wirft.
                 }
          \method{addProgressListener}
                 {
                   \param{listener}{ProgressListener}{Der \reftype{ProgressListener}, der bei Fortschritten benachrichtigt werden soll.}
                 }
                 {
                   Registriert einen \reftype{ProgressListener}, der bei Fortschritten benachrichtigt wird.
                 }
          \method{setProgress}
                 {
                   \param{progress}{float}{Der aktuelle Fortschritt.}
                 }
                 {
                   Setzt den Fortschritt der aktuellen Aufgabe direkt.
                   Darf nicht für Aufgaben verwendet werden, die Teilaufgaben haben (siehe \refmethod{ProgressReporter}{setSubTasks}).
                 }
          \method{getProgress}[float]
                 {\none}
                 {
                   Gibt den aktuellen Gesamtfortschritt zurück.
                 }
          \method{getCurrentTask}[String]
                 {\none}
                 {
                   Gibt den Namen der aktuellen Aufgabe zurück.
                 }
        }
  \class{CloseableTask}
        {
          Hilfsklasse für \refmethod{ProgressReporter}{openTask}.
          Implementiert \code{AutoCloseable}, kann also in try-with-resources Statements verwendet werden.
        }
        {\none}
        {
          \method{close}
                 {\none}
                 {
                   Beendet die Aufgabe, die mit dem zugehörigen \refmethod{ProgressReporter}{openTask} begonnen wurde.
                 }
        }
  \class{ProgressListener}
        {
          Interface, um bei Änderungen den Fortschritts in \reftype{ProgressReporter} benachrichtigt zu werden.
        }
        {\none}
        {
          \method{startRoot}
                 {
                   \param{name}{String}{Der Name der Basisaufgabe.}
                 }
                 {
                   Wird aufgerufen, wenn die Basisaufgabe des \reftype{ProgressReporter}s begonnen wird (erster Aufruf von \refmethod{ProgressReporter}{pushTask}).
                 }
          \method{beginTask}
                 {
                   \param{name}{String}{Der Name der (Teil-)Aufgabe.}
                 }
                 {
                   Wird aufgerufen, wenn eine neue (Teil-)Aufgabe begonnen wird (Aufruf von \refmethod{ProgressReporter}{pushTask} oder \refmethod{ProgressReporter}{nextTask}).
                   Für die Basisaufgabe wird diese Methode \emph{nach} \refmethod{ProgressListener}{startRoot} aufgerufen.
                 }
          \method{progress}
                 {
                   \param{progress}{float}{Der aktuelle Gesamtfortschritt.}
                   \param{name}{String}{Der Name der aktuellen (Teil)-Aufgabe.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Fortschritt ändert.
                   Bei Beenden einer Aufgabe wird diese Methode \emph{nach} \refmethod{ProgressListener}{endTask} aufgerufen.
                 }
          \method{endTask}
                 {
                   \param{name}{String}{Der Name der beendeten (Teil)-Aufgabe.}
                 }
                 {
                   Wird aufgerufen, wenn eine (Teil-)Aufgabe beendet wird (Aufruf von \refmethod{ProgressReporter}{popTask} oder \refmethod{ProgressReporter}{nextTask}).
                   Für die Basisaufgabe wird diese Methode \emph{vor} \refmethod{ProgressListener}{finishRoot} aufgerufen.
                 }
          \method{finishRoot}
                 {
                   \param{name}{String}{Der Name der beendeten Basisaufgabe.}
                 }
                 {
                   Wird aufgerufen, wenn die Basisaufgabe des \reftype{ProgressReporter}s beendet wird.
                 }
        }
  \class{CurrentCombinationListener}
        {
          Neues Interface, um benachrichtigt zu werden, wenn sich die aktuelle \reftype{ProfileMapCombination} (gehalten vom \reftype{ProfileMapManager}) ändert.
          
          Die \reftype{MainView} registriert einen anonymen \reftype{CurrentCombinationListener}, um die \reftype{MapView} zu de- oder aktivieren und gegebenenfalls eine Nachricht anzuzeigen, dass eine Vorberechnung durchgeführt werden muss.
        }
        {\none}
        {
          \method{currentCombinationChanged}
                 {
                   \param{newCombination}{ProfileMapCombination}{Die neue aktuelle ProfileMapCombination.}
                 }
                 {
                   Wird aufgerufen, wenn sich die aktuelle \reftype{ProfileMapCombination} ändert, etwa durch Aufruf von \refmethod{ProfileMapManager}{setCurrentCombination}.
                 }
        }
  \class{RouteModel}
        {
          Das \code{RouteModel} implementiert nun \reftype{CurrentCombinationListener}, um die Route zu löschen, wenn die aktuelle \reftype{ProfileMapCombination} sich ändert.
        }
        {\none}
        {
          \method{currentCombinationChanged}
                 {
                   \param{newCombination}{ProfileMapCombination}{Wird ignoriert.}
                 }
                 {
                   Setzt Start- und Zielpunkt sowie die Route und ihre Beschreibung auf \code{null} und benachrichtigt dann registrierte \reftype{RouteModelListener}.
                   Siehe auch \refmethod{CurrentCombinationListener}{currentCombinationChanged}.
                 }
        }
}
\package{MapDisplay}{}
{\class{TileCache}{~}
	{\none}
	{
	\method{stop}
		{\none}
		{
		Bewirkt, das dieser aktuelle \reftype{TeileCache} aufhört Anfragen zu bearbeiten.
		}
	\method{waitForStop}
		{\none}
		{
		Bewirkt, das dieser aktuelle \reftype{TeileCache} aufhört Anfragen zu bearbeiten und wartet, bis alle threads gestorben sind.
		}
	}
}
\package{Profiles}{~}
{
  \class{Profile}{~}
        {\none}
        {
          \method{clone}[Profile]
                 {\none}
                 {
                   Neue Methode, um eine Kopie eines Profils zu erstellen, welche nicht als Standardprofil gekennzeichnet ist.
                 }
        }
}

\package{Map}{}
{
  \class{StreetMap}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert die Karte in den angegebenen Ordner.}
          \method{load}[StreetMap]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt eine Karte aus dem angegebenen Ordner.}
          \method{loadLazily}[StreetMap]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {
                   (statisch) Gibt eine \reftype{StreetMap} zurück, die erst beim ersten Zugriff auf \refmethod{StreetMap}{getGraph} bzw. \refmethod{StreetMap}{getEdgeBasedGraph} diese auch aus dem angegebenen Ordner lädt.
                   Diese Methode wird verwendet, um die Startzeit des Programms zu verbessern:
                   Die Information, welche Karten vorliegen, soll zwar jederzeit verfügbar sein, allerdings werden nicht alle Karten sofort benötigt.
                 }
          \method{ensureLoaded}
                 {
                   \param{reporter}{ProgressReporter}{Der \reftype{ProgressReporter}, dem der Ladefortschritt gemeldet werden soll.}
                 }
                 {
                   Nach Aufruf dieser Methode ist garantiert, dass auch eine Karte, welche mittels \refmethod{StreetMap}{loadLazily} geladen wurde, vollständig geladen ist.
                   Spätere Aufrufe von \refmethod{StreetMap}{getGraph} bzw. \refmethod{StreetMap}{getEdgeBasedGraph} sind dann garantiert schnell.
                 }
        }
  \class{Graph}{~}
        {\none}
        {
        \method{getCorrespondingEdge}[int]
        {\param{edge}{int}{Eine ID der Kante.}}
        {Gibt die Kante in entgegengesetzter Richtung, oder -1, wenn es nicht vorhanden ist (Erkennung der Einbahnstraßen). }
          \method{getNumberOfEdges}[int]
                 {\none}
                 {Gibt die Anzahl der Kanten zurück. Dies ermöglicht es, über alle Kanten zu iterieren.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert den Graphen in die angegebene Datei.}
          \method{load}[Graph]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt einen Graphen aus der angegebenen Datei.}
        }
  \class{EdgeBasedGraph}{~}
        {\none}
        {
          \method{getNumberOfTurns}[int]
                 {\none}
                 {Gibt die Anzahl der Abbiegemöglichkeiten zurück. Dies ermöglicht es, über alle Abbiegemöglichkeiten zu iterieren.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert den kantenbasierten Graphen in die angegebene Datei.}
          \method{load}[EdgeBasedGraph]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt einen kantenbasierten Graphen aus der angegebenen Datei.}
        }
  \class{NodeProperties}{~}
        {\none}
        {
          \method{NodeProperties}
                 {
                   \param{junctionRef}{String}{Die Nummer der Anschlussstelle.}
                   \param{junctionName}{String}{Der Name der Anschlussstelle.}
                   \param{isMotorwayJunction}{boolean}{Gibt an, ob der Knoten eine Schnellstraßen- oder Autobahnanschlussstelle ist.}
                   \param{isTrafficLights}{boolean}{Gibt an, ob es sich bei dem Knoten um eine Ampelkreuzung handelt.}
                 }
                 {Konstruktor: Erzeugt ein neues Objekt mit den gegebenen Eigenschaften.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert die \reftype{NodeProperties} in die angegebene Datei.}
          \method{load}[NodeProperties]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt \reftype{NodeProperties} aus der angegebenen Datei.}
        }
  \class{EdgeProperties}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {Speichert die \reftype{EdgeProperties} in die angegebene Datei.}
          \method{load}[EdgeProperties]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {(statisch) Lädt \reftype{EdgeProperties} aus der angegebenen Datei.}
        }
  \class{Restriction}{~}
        {\none}
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die geschrieben werden soll.}
                 }
                 {
                   Speichert die \reftype{Restriction}s in die angegebene Datei.
                   
                   Dazu wird zunächst der Typ der Restriction geschrieben und dann die Methode \code{saveInternal} aufgerufen, welche die einzelnen Unterklassen überschreiben.
                 }
          \method{load}[Restriction]
                 {
                   \param{file}{File}{Die Datei, aus der gelesen werden soll.}
                 }
                 {
                   (statisch) Lädt \reftype{Restriction}s aus der angegebenen Datei.
                   
                   Dazu wird zunächst der Typ der Restriction gelesen und dann die Methode \code{loadInternal} aufgerufen, welche die einzelnen Unterklassen definieren.
                 }
        }
}
\package{Views}{Alle Views außer der \reftype{MapView} haben im Konstruktor einen neuen Parameter \code{Window parent} der ein \code{Frame} aus dem dieser Dialog geöffnet wird darstellt.}
{
  \class{MainView}{~}
        {\none}
        {\method{currentCombinationChanged}
	{\param{newCombination}{ProfileMapCombination}{Die neue Kombination aus Profil und Karte.}}
	{Setzt in alle dafür vorgesehenen Felder den aktuellen Profil- und Kartennamen. Blockiert die \reftype{MapView}, falls es keine Vorberechnung für die aktuelle Kombination gibt und gibt durch \code{textMesage} die Meldung für den Benutzer aus.}
	\method{textMessage}
          {\param{str}{String}{Der auf den Bildschirm auszugebende Text.}}
          {Gibt Fehlermeldungen für den Benutzer auf den Bildschirm aus.}
        }
\class{MapManagerView}{~}
	{\none}
	{\method{MapManagerView}
	{
		\param{mmc}{MapManagerController}{Ein \reftype{MapManagerController} der für die \reftype{MapManagerView} verantwortlich ist solange sie offen ist.}
		\param{parent}{Window}{Ein \code{Frame} aus dem dieser Dialog geöffnet wird.}
		\param{currentMap}{StreetMap}{Die aktuell ausgewählte Karte.}
		\param{maps}{Set<StreetMap>}{Alle Karten, die importiert wuden. Der Benutzer kann in der Kartenverwaltung aus diesen Karten wählen.}
		\param{currentMapProfiles}{Set<Profile>}{Alle Profile, für die eine Vorberechnung für die aktuell ausgewälte Karte exestiert.}
	}
	{Konstruktor der eine neue \reftype{MapManagerView} erzeugt.}
	}
\class{ProfileManagerView}{~}
	{\none}
	{\method{ProfileManagerView}
	{
		\param{parent}{Window}{Ein \code{Frame} aus dem dieser Dialog geöffnet wird.}
		\param{pmc}{ProfileManagerController}{Ein \reftype{ProfileManagerController} der für die \reftype{ProfileManagerView} verantwortlich ist solange sie offen ist.}
		\param{currentProfile}{Profile}{Das aktuell ausgewählte Profil.}
		\param{availableProfiles}{Set<Profile>}{Alle erstellten Profile.}
	}
	{Konstruktor der eine neue \reftype{ProfileManagerView} erzeugt.}
	}
\class{MapView}{~}
	{\none}
	{\method{MapView}
	{\param{source}{TileSource}{Eine Renderer, der die Kacheln für die Darstellung der Karte liefert.}}
	{~}
	}
  \class{ProgressDialog}
        {
          Neue Klasse: Ein \reftype{ProgressListener}, der den aktuellen Fortschritt und die aktuellen Aufgaben in einem Dialog anzeigt.
          Bei \refmethod{ProgressListener}{finishRoot} wird der Dialog unsichtbar gemacht (\code{setVisible(false)}).
        }
        {\none}
        {
          \item Keine außer geerbten und privaten Methoden.
        }
}
\package{History}{}
{
  \class{HistoryEntry}{~}
	{\none}
	{
	   \method{fromString}[HistoryEntry]
	         {\param{s}{String}{Ein Text, der zu einem \reftype{HistoryEntry} erhalten kann.}}
	         {Gibt einen aus dem String generierten \reftype{HistoryEntry} zurück.}
	   \method{toString}[String]
	         {\none}
	         {Gibt einen aus dem \reftype{HistoryEntry} generierten Text in Form eines Strings zurück.}
	}
	
}
\package{Util}{}
{
  \class{Coordinates}{~}
        {\none}
        {
	\method{goIntoDirection}[Coordinates]
	       {
		\param{to}{Coordinates}{Gibt die Richtung an, in die gegangen wird}
		\param{position}{float}{Ein Wert zwischen 0 und 1, der angibt wie weit in diese Richtung gegangen wird.}
	       }
	       {Berechnet die Koordinaten des Punkts mit der angegebenen Position auf einer
Linie. Dieses Verfahren kann verwendet werden, um die Koordinaten eines \reftype{PointOnEdge} zu bestimmen.}

          	\method{toString}[String]
                 {\none}
                 {Gibt eine String-Repräsentation der Koordinaten zurück, die von \refmethod{Coordinates}{fromString} wieder geparst werden kann.}
          	\method{fromString}[Coordinates]
                 {
                   \param{coords}{String}{Der Koordinaten-String.}
                 }
                 {(statisch) Parst einen Koordinaten-String wie er von \refmethod{Coordinates}{toString} zurückgegeben wird.}
          \method{parseLatitude}[float]
                 {
                   \param{lat}{String}{Die Breitengrad-Angabe.}
                 }
                 {(statisch) Parst eine Breitengrad-Angabe aus einer Zeichenkette.}
          \method{parseLongitude}[float]
                 {
                   \param{lon}{String}{Die Längengrad-Angabe.}
                 }
                 {(statisch) Parst eine Längengrad-Angabe aus einer Zeichenkette.}
        }
  \class{FileUtil}
        {
          Neue Klasse, die verschiedene statische Methoden enthält, welche etwas mit Dateien oder Dateisystemen zu tun haben.
        }
        {\none}
        {
          \method{rmRf}
                 {
                   \param{directory}{File}{Das Verzeichnis, das gelöscht werden soll.}
                 }
                 {
                   (statisch) Löscht ein Verzeichnis rekursiv.
                   Wird verwendet von \refmethod{MapManager}{deleteMap} und \refmethod{ProfileMapManager}{deletePrecalculation}.
                 }
          \method{getRootDir}[File]
                 {\none}
                 {
                   (statisch) Gibt das Ursprungsverzeichnis der \routeKIT-Installation zurück.
                   Dieses Verzeichnis enthält alle Karten, Profile und Vorberechnungen.
                   \begin{description}
                   \item[Windows] \code{\%APPDATA\%\textbackslash{}routeKIT}
                   \item[Mac] \code{\$HOME/Library/Application Support/routeKIT}
                   \item[Unix/Linux] \code{\$HOME/.config/routeKIT}
                   \end{description}
                 }
          \method{getHistoryFile}[File]
                 {\none}
                 {
                   Gibt die Datei zurück, in der der Verlauf (siehe \reftype{History}) gespeichert wird:
                   \code{routeKIT.history} in \refmethod{FileUtil}{getRootDir}.
                 }
        }
  \class{TimeUtil}
        {
          Neue Klasse, die eine Methode enthält, welche etwas mit Zeit zu tun hat.
        }
        {\none}
        {
          \method{timeSpanString}
                 {
                   \param{text}{StringBuilder}{Der \reftype{StringBuilder}, an den die Zeitspanne angehängt werden soll.}
                   \param{interval}{int}{Die Zeitspanne in Millisekunden.}
                 }
                 {
                   Wandelt eine Zeitspanne in Text um und hängt sie an \refparam{TimeUtil}{timeSpanString}{text} an.
                   Wird verwendet von \reftype{ProfileManagerView} und \reftype{MapManagerView}.
                 }
        }
}

\section{Komponententests}
Die automatisierten Komponententests wurden zum größten Teil noch nicht während der Implementierung erstellt und daher erst im Qualitätssicherungsbericht beschrieben.

\section{Arbeitsplanung}
Auf den folgenden Seiten sind der ursprüngliche Implementierungsplan (\abbildung{zeitplan}) sowie der tatsächliche Zeitplan der Implementierung (\abbildung{zeitplan_final}) als Gantt-Diagramme dargestellt.

Im Großen und Ganzen erwies sich der abgeschätzte Arbeitsaufwand als zutreffend; allerdings ergaben sich einige Abweichungen im tatsächlichen Arbeitsablauf dadurch, dass nicht immer so viel Zeit wie geplant zur Verfügung stand. Dafür wurde jedoch in der ursprünglichen Planung ein einwöchiger Zeitpuffer vorgesehen, der auch zur Fehlerbehebung genutzt wurde.

\begin{figure}[h]
\centering
\vspace{-2.5cm}\includegraphics[angle=90,scale=0.4]{zeitplan}
\caption{Ursprünglicher Zeitplan der Implementierungsphase}
\label{fig:zeitplan}
\end{figure}
\begin{figure}[h]
\centering
\vspace{-2.25cm}\includegraphics[angle=90,scale=0.4]{zeitplan_final}
\caption{Tatsächlicher Arbeitsablauf der Implementierungsphase}
\label{fig:zeitplan_final}
\end{figure}

\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
