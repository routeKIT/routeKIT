% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands
\usepackage{xspace} % \xspace for use in commands: put a space only if no punctuation follows
\usepackage{enumitem} % for controlling indentation in list environments
\usepackage{amssymb} % for checkmark
\usepackage{pifont}

\newcommand{\cmark}{\ding{51}}

\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\makeatletter

\newcommand{\oitem}[2]{
  % define the counter
  \@ifundefined{c@oitem#1}{\newcounter{oitem#1}}{} % initialized at 0
  \addtocounter{oitem#1}{10}
  \item[\namedlabel{#1:#2}{/#1\arabic{oitem#1}/}]
}

\newcommand{\bug}[6]{%
  \oitem{BG}{#1}
  	#2
    \begin{description}
    \item[Symptom] #3
    \item[Ursache] #4
    \item[Maßnahme] #5
    \item[Status] #6
    \end{description}
}

\newcommand{\guitest}[3]{%
  \item
    \begin{description}
    \item[Aktion] #1
    \item[Ergebnis] #2
    \item[Status] #3
    \end{description}
}

\NewDocumentCommand{\test}{m m O{} m m m}{%
  \oitem{UT}{#1} 
    \begin{description}
    \item[Was wird getestet] \code{#2} #3
    \item[Beschreibung] #4
    \item[Bestanden, wenn] #5
    \item[Status] #6
    \end{description}
}

% usage: \testfall{szenario}{ablauf}{ergebnis} oder \testfall[\ref{F:getesteteFunktion}]{szenario}{ablauf}{ergebnis}
\newcommand{\testfall}[4][]{
  \begin{description}
    \ifthenelse{\equal{#1}{}}
               {} % optional argument #1 is empty: skip
               {\item[Testet] #1}
    \item[Vorbedingungen] #2
    \item[Ablauf] #3
    \item[Erwartetes Ergebnis] #4
  \end{description}
}

\makeatother

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{%
  \glsdoifexists{#2}{%
    \def\@glsnumberformat{glsgobblenumber}%
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}%
    \setkeys{glossadd}{#1}%
    \@gls@saveentrycounter%
    \@do@wrglossary{#2}%
  }%
}
\newcommand{\glsaddallunused}[1][]{%
  \edef\@glo@type{\@glo@types}%
  \setkeys{glossadd}{#1}%
  \forallglsentries[\@glo@type]{\@glo@entry}{%
    \ifglsused{\@glo@entry}{}{%
      \typeout{****Glossary entry '\@glo@entry' unused****}%
      \glsaddnp[#1]{\@glo@entry}}}%
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

\makeatletter

\begin{document}
\shorthandoff{"}

\sloppy % fix overfull hboxes

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\emph{routeKIT}\xspace}


% alle Glossareinträge
\newglossaryentry{profil}{
  name={Profil},
  description={enthält für die Routenplanung relevante Informationen, z.\,B. die Höhe und das Gewicht des Fahrzeugs},
  plural={Profile}
}
\newglossaryentry{karte}{
  name={Karte},
  description={enthält die Daten aus \gls{osm} sowie einen Namen},
  plural={Karten}
}
\newglossaryentry{osmkachel}{
  name={OSM-Kachel},
  description={die öffentlichen gerenderten \gls{osm}-Kacheln z.\,B. auf\\\mbox{\url{http://a.tile.openstreetmap.org/}}},
  plural={OSM-Kacheln}
}
\newglossaryentry{route}{
  name={Route},
  description={ein Weg von einem Start- zu einem Zielpunkt},
  plural={Routen}
}
\newglossaryentry{vorberechnung}{
  name={Vorberechnung},
  description={verbindet die \gls{karte} mit den auf einem \gls{profil} basierenden Informationen und ermöglicht, unter anderem mittels \gls{arc}, später eine Beschleunigung der Berechnung einer \gls{route}; muss für jede neue \gls{karte}/\gls{profil}-Kombination einmal ausgeführt werden},
  plural={Vorberechnungen},
  see={arc}
}
\newglossaryentry{rendern}{
  name={rendern},
  description={Berechnung einer Bildkachel aus den zu rendernden Daten}
}
\newglossaryentry{wegbeschreibung}{
  name={Wegbeschreibung},
  description={Beschreibung einer \gls{route} durch eine Liste von Abbiegeanweisungen}
}
\newglossaryentry{dijkstra}{
  name={Dijkstra’s Algorithmus},
  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
}
\newglossaryentry{arc}{
 name={Arc-Flags},
 description={eine Technik, um eine Routenberechnung zu beschleunigen}
}
\newglossaryentry{verlauf}{
  name={Verlauf},
  description={speichert Routenanfragen für spätere Wiederverwendung. Es existiert nur ein Verlauf für die gesamte Anwendung}
}
\newglossaryentry{mercator}{
  name={Mercator-Projektion},
  description={die Zylinderprojektion der Weltkugel}
}
\newglossaryentry{entwurfsmuster}{
  name={Entwurfsmuster},
  description={Eine Schablone, die eine Lösung für ein oder mehrere Entwurfsprobleme darstellt. Ihre Verwendung erleichtert Änderungen im Entwurf}
}
\newglossaryentry{beobachter}{
  name={Beobachter},
  description={Ein \gls{entwurfsmuster}, das bei Änderung des Zustands eines Objektes alle abhängenden Objekte benachrichtigt}
}
\newglossaryentry{einzelstueck}{
  name={Einzelstück},
  description={Ein \gls{entwurfsmuster}, das zusichert, dass eine Klasse genau ein Exemplar besitzt und stellt einen globalen Zugriffspunkt darauf bereit}
}
\newglossaryentry{dekorierer}{
  name={Dekorierer},
  description={Ein \gls{entwurfsmuster}, das dynamisch neue Funktionalität zum Objekt hinzufügt}
}
\newglossaryentry{strategie}{
  name={Strategie},
  description={Ein \gls{entwurfsmuster}, das eine Familie von Algorithmen definiert, sie kapselt und austauschbar macht}
}
\newglossaryentry{G_smt}{
  name={Slippy Map Tile},
  description={
    Koordinaten, durch die Kartenkacheln einer graphischen Darstellung (mit \gls{mercator}) adressiert werden können.
    Drei Bestandteile: x, y, zoom.
    Mit nicht-ganzzahligen Werten für x und y können nicht nur Kacheln, sondern auch Geokoordinaten adressiert werden}
}
\newglossaryentry{smt}{
  type=\acronymtype,
  name={SMT},
  description={Slippy Map Tile},
  first={Slippy Map Tile (SMT)},
  see=[Glossareintrag:]{G_smt}
}
\newglossaryentry{opaque}{
  name={deckend},
  description={
    Die innere Implementierung wird vor anderen Klassen verborgen; Zugriff ist nur über das definierte Interface der Klasse/Methode möglich. (engl. “opaque”)}
}

\newacronym[longplural=Personenkraftwagen]{pkw}{PKW}{Personenkraftwagen}
\newacronym[longplural=Lastkraftwagen]{lkw}{LKW}{Lastkraftwagen}
\newacronym{osm}{OSM}{OpenStreetMap}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{gpx}{GPX}{GPS Exchange Format}
\newacronym{mvc}{MVC}{Model View Controller}
\newacronym{cli}{CLI}{Command Line Interface}



\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Testdokument}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage


\section{Einleitung}
Dieses Dokument erläutert und protokolliert die Qualitätssicherung der Anwendung \routeKIT. Es dokumentiert die gefundenen Fehler, die durchgeführten Unit-Tests, die Testüberdeckung und die durchgeführten Änderungen seit der Implementierungsphase.

\routeKIT ist eine Anwendung zur Routenplanung; durch Verwendung von \glslink{profil}{Profilen} kann sie dem Benutzer die optimalen \glspl{route} für sein spezielles Fahrzeug angeben.
Um die Routenberechnung zu beschleunigen, wird pro \gls{profil} und \gls{karte} eine zeitaufwändige \gls{vorberechnung} durchgeführt.

\section{Fehlerprotokoll}

\subsection{Kritische Fehler}
\begin{itemize}
\bug{corruptIndex}{Korrupte Indexdatei}
    {Wenn die Indexdatei Karten oder Profile enthält, die nicht existieren, stürzt \routeKIT beim Programmstart ab.}
    {Es wird versucht, auf Karten/Profile, die \code{null} sind, zuzugreifen.}
    {Karte oder Profil überspringen, wenn es \code{null} ist.}
    {behoben}
\end{itemize}

\subsection{Funktionale Fehler}
\begin{itemize}
\bug{missingStreet}{Fehlende Straßen}
    {Im vergröberten Graph fehlen Straßen.}
    {Die entsprechenden Kanten werden weggeworfen.}
    {Ein falsches \code{break} entfernen, das nach der ersten Ein-Kanten-Straße das Erzeugen von Kanten abbricht.}
    {behoben}
\bug{pointProjection}{Punkt-Projektion}
    {Die Projektion von angeklickten Koordinaten auf Kanten ist manchmal leicht schief.}
    {Die Projektion findet im Geokoordinatensystem statt und nicht nach der \gls{mercator} (also im SMT-Koordinatensystem).}
    {Den Code muss für die Abstandsberechnung SMT-Koordinaten benutzen und keine Geokoordinaten.}
    {behoben}
\bug{cornerOneway}{Einbahnstraßen, Randfall}
    {Eine Route auf einer einzelnen Kante, die nur in einer Richtung befahrbar ist, kann die Kante auch entgegen der Fahrtrichtung benutzen.}
    {Es wird nur verhindert, dass man in Einbahnstraßen entgegen der Fahrtrichtung einbiegt, aber nicht, dass man darin entgegen der Fahrtrichtung losfährt.}
    {Den ersten Schritt der Routenberechnung gesondert ausführen, um dies als Spezialfall zu behandeln.}
    {behoben}
\bug{profileNoWarning}{Profilverwaltung: Warnung bei Enter}
    {Wenn im Profilverwaltungsdialog Vorberechnungen gelöscht werden und er mit \textit{Enter} geschlossen wird, erscheint keine Warnung. Beim Klick auf \textit{OK} erscheint sie aber.}
    {Der Code, der die Warnung erzeugt, liegt im Event-Handler des Buttons und nicht in der Methode der \code{ProfileManagerView}, die den Dialog schließt.}
    {Den Code, der die Warnung erzeugt, in die \code{ok}-Methode der \code{ProfileManagerView} verschieben.}
    {behoben}
\end{itemize}

\subsection{Benutzbarkeitsfehler}
\begin{itemize}
\bug{routeCalcRaceCondition}{Wettlauf bei der Routenberechnung}
    {Wenn während einer aktiven Routenberechnung eine weitere gestartet wird, kann es passieren,
    dass die erste Route angezeigt wird, obwohl Start und Ziel von der zweiten ausgewählt sind.}
    {Wenn die zweite Routenberechnung schneller ist, schreibt sie ihr Ergebnis zuerst und die erste Routenberechnung überschreibt dann anschließend die Route.}
    {Der aktuelle Berechnungsthread wird gespeichert. Die berechnete Route wird nur noch abgeschickt wenn der berechnende Thread der aktuelle ist.}
    {behoben}
\bug{zoomAndDrag}{Zoom und Ziehen}
    {Wenn die Karte während einer Ziehgeste gezoomt wird, verändert sich die Kartenansicht,
    sodass man auf einem komplett anderen Teil der Karte ist.}
    {Während der Ziehgeste werden die Ursprungskoordinaten der Geste gespeichert.
    Durch das Zoomen werden nun die Koordinaten halbiert (oder verdoppelt),
    was sich aber nicht direkt auf die gespeicherten Koordinaten auswirkt.
    Wird nun die Ziehgeste fortgesetzt, werden diese halb (oder doppelt) so großen Koordinaten
    zurückgeschrieben, was den Sprung auf der Karte verursacht.}
    {Verhindere alles Zoomen während einer Ziehgeste.}
    {behoben}
\bug{slowRender}{Vergröberung nötig}
    {Das Rendern der Kacheln ist auf kleineren Zoomstufen zu langsam.}
    {Es werden zu viele feine Kanten gezeichnet.}
    {Der Graph muss für die Anzeige vergröbert werden, sodass weniger Kanten gezeichnet werden müssen.}
    {behoben}
\bug{routeCalcAllEdges}{Routenberechnung: alle Kanten}
    {Die Routenberechnung ist zu langsam, auch für kurze Routen.}
    {Der Algorithmus fügt zu Beginn der Berechnung alle vorhandenen Kanten in einen Heap ein, obwohl die eigentliche Routenberechnung durch \gls{arc} oder nah beieinander liegende Start- und Zielpunkte möglicherweise nur auf einen Bruchteil der Kanten zugreifen muss.}
    {Den Heap „lazy“ initialisieren (nicht eingefügte Kanten sind „unendlich“ weit entfernt).}
    {behoben}
\bug{precalc}{Vorberechnung: alle Kanten}
    {Die Vorberechnung ist zu langsam.}
    {Es werden für jeden der Dijkstra-Durchläufe am Anfang alle Kanten des Graphen in den Heap eingefügt, auch wenn später möglicherweise nie darauf zugegriffen wird.}
    {Kanten nur noch bei Bedarf in den Heap einfügen.}
    {behoben}
\bug{routeCalcKeineRoute}{Falscher Infotext während Routenberechnung}
    {Während der Routenberechnung zeigt die Wegbeschreibungs-/Info-Box den Text „keine Route gefunden“ an.}
    {Begonnene Routenberechnungen werden dem \code{RouteModel} nicht mitgeteilt, so dass die \code{MainView} nicht erfahren kann, dass gerade eine Berechnung läuft.}
    {Hinzufügen der Methode \code{isCalculated} zum \code{RouteModel}; siehe auch Abschnitt \ref{change:routeCalcKeineRoute}.}
    {behoben}
\end{itemize}

\section{Testfälle aus dem Pflichtenheft}
\begin{tabular}{|l|l|}
	\hline
	Test & Status \\
	\hline
	\hline
	TF10 & bestanden \\
	\hline
\end{tabular}

\section{Protokoll der Unit-Tests}
\begin{itemize}
\test{gpxExport}{GPXExporter}
     {Es wird die GPX-Export-Funktion des Programms getestet.}
     {die erzeugte Datei ein gültiges XML-Dokument ist.}
     {bestanden}
\test{htmlExprt}{HTMLExporter}
     {Es wird die HTML-Export-Funktion des Programms getestet.}
     {die erzeugte Datei ein gültiges XML-Dokument ist.}
     {bestanden}
\test{history}{History}
     {Es wird die Speicher- und Lade-Funktion des Verlaufs getestet.}
     {der Verlauf nach dem Speichern und anschließenden Laden die gleichen Einträge enthält wie davor.}
     {bestanden}
\test{historyEntry}{HistoryEntry}
     {Es werden die Methoden \code{toString} und \code{fromString} der Verlaufseinträge getestet.}
     {ein Verlaufseintrag nach Anwenden von \code{fromString} auf den von \code{toString} erzeugten String denselben Start- und Zielpunkt sowie Zeitstempel enthält wie davor.}
     {bestanden}
\test{edgeProps}{EdgeProperties}
     {Es werden die Getter von \code{EdgeProperties} und insbesondere \code{getMaxSpeed} getestet.}
     {die Getter die korrekten Werte zurückgeben und \code{getMaxSpeed}, je nach Straßentyp und übergebenem Profil, die korrekte Höchstgeschwindigkeit des gegebenen Fahrzeugtyps auf diesem Straßentyp liefert.}
     {bestanden}
\test{restriction}{Restriction}
     {Es wird für verschiedene Beschränkungen (\mbox{\code{Height}-,} \mbox{\code{Width}-,} \mbox{\code{Weight}-,} \mbox{\code{VehicleType}-,} \mbox{\code{Multiple}-,} \code{NoRestriction}) die \code{allows}-Methode für die Profile „PKW (Standard)“ und „LKW (Standard)“ getestet.}
     {bei jeder getesteten Beschränkung \code{allows} für die jeweiligen Profile die korrekte Ausgabe liefert.}
     {bestanden}
\test{edgeBasedGraph}{EdgeBasedGraph}
     {Es wird die Speicher- und Lade-Funktion von \code{EdgeBasedGraph} getestet.}
     {der kantenbasierte Graph nach dem Speichern und anschließenden Laden die gleichen Kanten und Abbiegemöglichkeiten enthält wie davor.}
     {bestanden}
\test{graph}{Graph}
     {Es werden die Getter sowie die Speicher- und Lade-Funktion von \code{Graph} getestet.}
     {die Getter die korrekten Werte zurückgeben und der Graph nach dem Speichern und anschließenden Laden die gleichen Knoten und Kanten enthält wie davor.}
     {bestanden}
\test{graphIndex}{GraphIndex}
     {Es werden \code{findNearestPointOnEdge} und \code{getEdgesInRectangle} der beiden \code{GraphIndex}-Implementierungen (\code{Array}- und \code{Tree}-) getestet.}
     {die resultierenden Kantenmengen und die \code{PointOnEdge}s jeweils mit den erwarteten Werten übereinstimmen.}
     {bestanden}
\test{tileCacheCache}{TileCache}[Cache]
     {Es wird das Speichern von Kacheln im \code{TileCache} getestet.}
     {eine Kachel innerhalb von 100\,ms nach der ersten Anfrage im \code{TileCache} gespeichert wird.}
     {bestanden}
\test{tileCachePrefetch}{TileCache}[Prefetch]
     {Es wird das Prefetching (vorsorgliche Berechnung von benachbarten Kacheln, auch wenn diese noch nicht direkt angefragt wurden) des \code{TileCache} getestet.}
     {nach dem Anfragen einer Kachel innerhalb von 100\,ms benachbarte Kacheln ebenfalls im \code{TileCache} gespeichert werden.}
     {bestanden}
\test{tileCacheCleanup}{TileCache}[Cleanup]
     {Es wird das Entfernen von Kacheln aus dem \code{TileCache} getestet.}
     {nach dem Anfragen von $50^2$ anderen Kacheln die älteste gespeicherte Kachel aus dem \code{TileCache} entfernt wird.}
     {bestanden}
\test{arcflags}{ArcFlags}
     {Es wird die Speicher- und Lade-Funktion der Arc-Flags getestet.}
     {nach dem Speichern und anschließenden Laden die gleichen Arc-Flags gesetzt sind wie davor.}
     {bestanden}
\test{routeModel}{RouteModel}
     {Es wird das Beobachtermuster der \code{RouteModel}-Klasse getestet.}
     {die von einem \code{TestListener} gemessene Anzahl an ausgelösten Ereignissen an allen Stellen mit der erwarteten Anzahl übereinstimmt.}
     {bestanden}
\test{weights}{Weights}
     {Es wird die Speicher- und Lade-Funktion der Kantengewichte getestet.}
     {nach dem Speichern und anschließenden Laden die gleichen Kantengewichte gesetzt sind wie davor.}
     {bestanden}
\test{mapEdge}{MapEdge}
     {Es wird die \code{MapEdge}-Klasse getestet, die vom OSM-Parser verwendet wird.}
     {das Setzen der ID korrekt funktioniert und die Getter die richtigen Werte zurückgeben.}
     {bestanden}
\test{osmParser}{OSMParser}
     {Es wird die Verarbeitung verschiedener Karteneigenschaften (verschiedene Abbiegetypen, Einbahnstraßen, Ampeln, Kreisverkehre, \dots) sowie das Erkennen von fehlerhaften Eingabedaten (Eigenschaften ohne Name, Eigenschaften ohne Wert, fehlende Koordinaten, ungültige Koordinaten, \dots) durch den OSM-Parser getestet.}
     {alle gültigen Strukturen korrekt in den Graph übernommen werden und ungültige Daten vom Parser erkannt werden und der Import dann mit einer Ausnahme abgebrochen wird.}
     {bestanden}
\test{osmWay}{OSMWay}
     {Es wird die Verarbeitung verschiedener OSM-Tags (Straßentyp, Kreisverkehr, \dots) durch die \code{OSMWay}-Klasse getestet.}
     {alle OSM-Tags auf die richtigen Strukturen im Graph abgebildet werden.}
     {bestanden}
\test{profileMapComb}{ProfileMapCombination}
     {Es wird die Speicher- und Lade-Funktion von \code{ProfileMapCombination} getestet.}
     {die \code{ProfileMapCombination} nach dem Speichern und anschließenden Laden das gleiche Profil und die gleiche \code{StreetMap} sowie, falls vorhanden, die gleiche abgeschlossene Vorberechnung (Kantengewichte, Arc-Flags, benötigte Zeit) enthält wie davor.}
     {bestanden}
\test{turnRestriction}{TurnRestriction}
     {Es wird die Funktionalität von Abbiegebeschränkungen getestet.}
     {eine Abbiegebeschränkung ihre Start- und Zielkante korrekt zurückgibt und \code{allowsTurn} korrekt entscheidet, ob ein Abbiegevorgang auf eine bestimmte Kante erlaubt ist oder nicht.}
     {bestanden}
\test{profile}{Profile}
     {Es werden \code{equals} und \code{clone} sowie die Setter, Getter und die Speicher- und Lade-Funktion der Profile getestet.}
     {\code{equals} und \code{clone} erwartungsgemäß funktionieren, die Setter die verschiedenen Werte (Fahrzeugtyp, Höhe, Breite, \dots) korrekt setzen, die Werte von Standardprofilen jedoch nicht verändern, die Getter die korrekten Werte zurückgeben und das Profil nach dem Speichern und anschließenden Laden die gleichen Werte enthält wie davor.}
     {bestanden}
\test{fibHeap}{FibonacciHeap}
     {Es werden die verschiedenen Operationen (Einfügen/Entfernen von Elementen, Ändern der Priorität) des Fibonacci-Heaps getestet.}
     {die \code{deleteMin}-Methode nach dem Hinzufügen/Entfernen von Elementen und Ändern von Prioritäten immer korrekt das Element mit der niedrigsten Priorität zurückgibt.}
     {bestanden}
\test{coords}{Coordinates}
     {Es werden die Methoden \code{distanceTo}, \code{angleBetween} sowie \code{toString}/\code{toSMT} und \code{fromString}/\code{fromSMT} getestet.}
     {\code{distanceTo} und \code{angleBetween} die erwarteten Werte zurückgeben und eine Transformation und Rücktransformation mit den Konvertierungsmethoden die Testkoordinaten unverändert lässt.}
     {bestanden}
\test{pointOnEdge}{PointOnEdge}
     {Es werden der Konstruktor sowie die Getter von \code{PointOnEdge} getestet.}
     {der Konstruktor nur positive Kanten-IDs sowie Positionen zwischen 0 und 1 annimmt und die Getter die korrekten Werte zurückgeben.}
     {bestanden}
\test{fileUtil}{FileUtil}
     {Es werden \code{checkMapName} und \code{checkProfileName} getestet.}
     {\code{checkMapName}/\code{checkProfileName} zulässige \mbox{Karten-/}\hspace{0pt}Profilnamen akzeptiert und unzulässige ablehnt.}
     {bestanden}
\end{itemize}

\section{Protokoll des GUI-Tests}
\subsection{Automatisierter Test}
Bei allen hier beschriebenen Testfällen gilt als Vorbedingung, dass \routeKIT gestartet ist.
\begin{description}
\newcounter{oitemTF}
\setcounter{oitemTF}{400}
\oitem{TF}{aboutviewopen} Über-Fenster öffnen
\testfall
    {Alle Fenster außer dem Hauptfenster sind geschlossen.}
    {„routeKIT/Über\dots“ in der Menüleiste wird ausgewählt.}
    {Das Fenster mit den Informationen über das Programm erscheint.}
\oitem{TF}{aboutviewclose} Über-Fenster schließen
\testfall
    {Das Über-Fenster ist geöffnet.}
    {Die Tastenkombination \textit{Alt}+\textit{F4} drücken.}
    {Das Über-Fenster wird geschlossen.}
\oitem{TF}{swap} Koordinaten vertauschen
\testfall
    {Das Start- und das Zielfeld enthalten gültige Koordinaten.}
    {Der Start/Ziel-Tauschen-Button wird gedrückt.}
    {Die Eingaben von Start- und Zielfeld werden vertauscht und die Markierungen auf der Karte werden neu gesetzt. Die Route zwischen Start- und Zielpunkt wird berechnet.}
\oitem{TF}{waydescription} Wegbeschreibung
\testfall
    {Das Start- oder das Zielfeld enthält eine gültige Koordinate.}
    {Die fehlende gültige Koordinate wird eingegeben.}
    {Die Markierungen auf der Karte wird gesetzt. Die Route zwischen Start- und Zielpunkt wird berechnet. Die Wegbeschreibung wird in das Wegbeschreibungsfeld ausgegeben.}
\oitem{TF}{mapmanagerviewopen} Kartenverwaltung-Fenster öffnen
\testfall
    {Alle Fenster außer dem Hauptfenster sind geschlossen.}
    {Der Karte-Knopf wird gedrückt.}
    {Das Fenster der Kartenverwaltung erscheint.}
\oitem{TF}{mapimportcorrect} Karte importieren (genauer als /TF290/)
\testfall
    {Das Fenster Kartenverwaltung ist offen.}
    {Der Importieren-Knopf wird gedrückt. Im Dialog wird der korrekte Pfad und Name der Karte angegeben und zwei mal bestätigt.}
    {Die Kartenverwaltung wird geschlossen. Die importierte Karte ist ausgewählt, die Karte ist für das aktuelle Profil nicht vorberechnet.}
\oitem{TF}{profilemanagerviewopen} Profilverwaltung-Fenster öffnen
\testfall
    {Alle Fenster außer dem Hauptfenster sind geschlossen.}
    {Der Profil-Knopf wird gedrückt.}
    {Das Fenster der Profilverwaltung erscheint.}
\end{description}

Der Test wird mit der Karte „Regierungsbezirk Karlsruhe“ und dem dafür vorberechneten Standardprofil „PKW (Standard)“ gestartet. Eine Internetverbindung ist hergestellt.
\begin{longtable}{||c|c|c||}
Testnummer & bestanden & Vorbedingungen erfüllt wegen\\ \hline\hline
\endfirsthead
/TF30/ & \cmark &  Neustart der Anwendung  \\ \hline
\ref{TF:aboutviewopen}& \cmark & Neustart der Anwendung \\ \hline
\ref{TF:aboutviewclose}& \cmark & \ref{TF:aboutviewopen} \\ \hline
/TF150/ & \cmark & /TF30/ und der Bedingung für den Test \\ \hline
/TF80/ und /TF100/ & \cmark & /TF30/ und der Bedingung für den Test \\ \hline
/TF90/ und \ref{TF:waydescription} & \cmark & /TF30/ und der Bedingung für den Test \\ \hline
/TF70/ & \cmark & /TF90/ \\ \hline
/TF20/ & \cmark & /TF90/ und \ref{TF:waydescription} \\ \hline
\ref{TF:swap} & \cmark & /TF90/ und \ref{TF:waydescription} \\ \hline
/TF200/ & \cmark & /TF30/ und der Bedingung für den Test \\ \hline
/TF210/ & \cmark & /TF30/ und /TF200/ \\ \hline
/TF120/ und /TF220/& \cmark & /TF30/ \\ \hline
/TF130/ und /TF220/& \cmark & /TF30/ \\ \hline
\ref{TF:mapmanagerviewopen} & \cmark & \ref{TF:aboutviewclose} \\ \hline
\ref{TF:mapimportcorrect}& \cmark & \ref{TF:mapmanagerviewopen} \\ \hline
/TF10/ & \cmark & /TF30/ und \ref{TF:mapimportcorrect} \\ \hline
\ref{TF:profilemanagerviewopen} & \cmark & /TF30/ und \ref{TF:mapimportcorrect} \\ \hline
/TF240/ & \cmark & der Bedingung für den Test \\ \hline
/TF10/ & \cmark & /TF30/ und /TF240/ \\ \hline
\end{longtable}

\section{Testüberdeckung}

\section{Änderungen seit der Implementierung}
Im Folgenden sind die gegenüber der Implementierung geänderten und neu hinzugefügten Klassen, Methoden und Attribute aufgeführt.

\begin{itemize}
\item Änderungen am \code{GraphIndex}
  \begin{itemize}
  \item Die Klasse \code{GraphIndex} wurde in ein Interface geändert und die bisherige Implementierung in die Klasse \code{TreeGraphIndex} verschoben.
  \item Eine weitere Implementierung von \code{GraphIndex}, \code{ArrayGraphIndex}, wurde geschrieben.
  Sie verwendet nur zwei \code{int}-Arrays und ist dadurch etwas schneller und lässt sich gut speichern/laden.
  \item \code{Graph} verwendet \code{ArrayGraphIndex}.
  \item \code{Graph} lädt \code{ArrayGraphIndex} von der Festplatte, statt sie neu aufzubauen, wenn die Dateien vorhanden sind. Dies beschleunigt den Start der Anwendung erheblich.
  \end{itemize}
\item\label{change:routeCalcKeineRoute} \ref{BG:routeCalcKeineRoute}
  \begin{itemize}
  \item \code{RouteModel} erhält die neuen Methoden \code{startCalculating}, um den Beginn einer Routenberechnung zu melden, und \code{isCalculating}, um abzufragen, ob aktuell eine Routenberechnung stattfindet.
  (Eine Routenberechnung endet implizit bei Aufruf von \code{setCurrentRoute}.)
  \end{itemize}
  \item MainController-Änderungen
    \begin{itemize}
    \item Die Klasse \code{MainController} enthält nun eine Methode \code{setUseArcFlags} zum abschalten der ArcFlags bei der Routenberechnung. Hierzu wird entweder eine Instanz von ArcFlagsDijkstra oder Dijkstra zur Routenberechnung verwendet.
    \end{itemize}
  \item ArcFlagsDijkstra-Änderungen
    \begin{itemize}
    \item Die Klasse \code{ArcFlagsDijkstra} erbt nun von der neuen Klasse \code{Dijkstra}, welche den normalen Dijkstra-Algorithmus implementiert und ergänzt diese mit den \code{ArcFlags}.
    \end{itemize}
\end{itemize}

\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
