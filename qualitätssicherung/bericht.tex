% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands
\usepackage{xspace} % \xspace for use in commands: put a space only if no punctuation follows
\usepackage{enumitem} % for controlling indentation in list environments
\usepackage{amssymb} % for checkmark
\usepackage{pifont}

\newcommand{\cmark}{\ding{51}}

\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\newcommand{\none}[0]{
%  % see http://tex.stackexchange.com/questions/61155/linespacing-without-packages
%  \setlength\lineskiplimit{-1000pt} % allow overflowing of lines
%  \linespread{0}\selectfont % don’t advance line after empty item
  \item[] keine.
}

\makeatletter

\newcommand{\oitem}[2]{
  % define the counter
  \@ifundefined{c@oitem#1}{\newcounter{oitem#1}}{} % initialized at 0
  \addtocounter{oitem#1}{10}
  \item[\namedlabel{#1:#2}{/#1\arabic{oitem#1}/}]
}

\newcommand{\@packagelabel}[1]{P:#1}
\newcommand{\@typelabel}[1]{T:#1} % for classes and enums
\newcommand{\@attrlabel}[2]{A:#1.#2}
\newcommand{\@methodlabel}[2]{M:#1.#2}
\newcommand{\@paramlabel}[3]{P:#1.#2.#3}
\newcommand{\@constantlabel}[2]{C:#1.#2}

% evaluate #2 if the label #1 exists, else #3.
\newcommand{\ifhaslabel}[3]{%
  \@ifundefined{r@#1}%
               {#3}%
               {#2}%
}

\newcommand{\bug}[6]{%
  \oitem{BG}{#1}
  	#2
    \begin{description}
    \item[Symptom] #3
    \item[Ursache] #4
    \item[Maßnahme] #5
    \item[Status] #6
    \end{description}
}

\newcommand{\guitest}[3]{%
  \item
    \begin{description}
    \item[Aktion] #1
    \item[Ergebnis] #2
    \item[Status] #3
    \end{description}
}

\newcommand{\test}[5]{%
  \oitem{UT}{#1} 
    \begin{description}
    \item[Was wird getestet] #2
    \item[Beschreibung] #3
    \item[Bestanden, wenn] #4
    \item[Status] #5
    \end{description}
}

% usage: \testfall{szenario}{ablauf}{ergebnis} oder \testfall[\ref{F:getesteteFunktion}]{szenario}{ablauf}{ergebnis}
\newcommand{\testfall}[4][]{
  \begin{description}
    \ifthenelse{\equal{#1}{}}
               {} % optional argument #1 is empty: skip
               {\item[Testet] #1}
    \item[Vorbedingungen] #2
    \item[Ablauf] #3
    \item[Erwartetes Ergebnis] #4
  \end{description}
}

% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Klassen (ein oder mehrere \class)
\newcommand{\package}[3]{%
  \subsection{Paket #1}\label{\@packagelabel{#1}}
  #2
  \begin{description}
   #3%
  \end{description}
}
% Argumente:
% 1. Klassenname
% 2. Beschreibung
% 3. Attribute (ein oder mehrere \attr, oder \none)
% 4. Methoden (ein oder mehrere \method, oder \none)
\newcommand{\class}[4]{%
  \newcommand{\currentclass}[0]{#1}%
  \item[\namedlabel{\@typelabel{#1}}{\code{#1}}] #2
    \ifstrequal{#3#4}{\none\none}{%
      % \none attributes and \none methods, skip
    }{%
      \begin{description}[leftmargin=0em,itemindent=0em]
        \ifstrequal{#3}{\none}{%
          % \none attributes, skip
        }{%
        \item[Attribute] \hfill % \hfill forces the following description into the next line
          \begin{description}
            #3%
          \end{description}
        }%
        \ifstrequal{#4}{\none}{%
          % \none methods, skip
        }{%
        \item[Methoden] \hfill% \hfill forces the following description into the next line
          \begin{description}
            #4%
          \end{description}
        }%
      \end{description}
    }%
  \let\currentclass=\undefined%
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\attr}[3]{%
  \item[\namedlabel{\@attrlabel{\currentclass}{#1}}{\code{#1}}] #3 Typ:~\reftype{#2}
}
% Argumente:
% 1. Name
% 2. (optional) Typ – default: void (wird nicht angezeigt); wird automatisch gelinkt, falls vorhanden
% 3. Parameter (ein oder mehrere \param, oder \none)
% 4. Beschreibung
\NewDocumentCommand{\method}{m o m +m}{% the ‘+m’ means that parameter 4 can contain several paragraphs, see http://tex.stackexchange.com/questions/64328/blank-lines-break-xparse-or-ifthen-macro
  \newcommand{\currentmethod}[0]{#1}%
  \item[\namedlabel{\@methodlabel{\currentclass}{#1}}{\code{#1}}] #4%
    \ifstrequal{#3}{\none}{%
      % \none parameters, skip
    }{%
      \\Parameter:
      \begin{description}[leftmargin=0em,itemindent=0em]
        #3%
      \end{description}
    }%
    \IfValueTF{#2}% if the optional “type” argument is given...
              { Rückgabetyp:~\reftype{#2}}% then show the return type...
              {}% else don’t.
  \let\currentmethod=\undefined%
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\param}[3]{%
  \item[\namedlabel{\@paramlabel{\currentclass}{\currentmethod}{#1}}{\code{#1}}] #3 Typ:~\reftype{#2}%
}
% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Konstanten (ein oder mehrere \constant, oder \none)
\newcommand{\enum}[3]{%
  \newcommand{\currentenum}[0]{#1}%
  \item[\namedlabel{\@typelabel{#1}}{\code{#1}}] #2
    \ifstrequal{#3}{\none}{%
      % \none cases, skip
    }{%
      Instanzen:
      \begin{description}
        #3
      \end{description}
    }%
  \let\currentenum=\undefined%
}
% Argumente:
% 1. Name
% 2. Beschreibung
\newcommand{\constant}[2]{%
  \item[\namedlabel{\@constantlabel{\currentenum}{#1}}{\code{#1}}] #2
}

\NewDocumentCommand{\refpackage}{mO{#1}}{%
  \hyperref[\@packagelabel{#1}]{\code{#2}}\xspace%
}
% Argumente:
% 1. Typ (Klasse oder Enum)
% 2. (optional) Text – default: Typ
\NewDocumentCommand{\reftype}{mO{#1}}{%
  \def\@reftype@tmp@text{\code{#2}}%
  \ifhaslabel{\@typelabel{#1}}{% if the label exists...
    \hyperref[\@typelabel{#1}]{\@reftype@tmp@text}}{% then reference it...
    \@reftype@tmp@text}% else just print the text.
  \let\@reftype@tmp@text=\undefined%
}
% DEPRECATED
\NewDocumentCommand{\refclass}{mO{#1}}{%
  \GenericWarning{}{The command \refclass is deprecated -- use \reftype instead}%
  \reftype{#1}[#2]%
}
% Argumente:
% 1. Klasse
% 2. Attribut
% 3. (optional) Text – default: Attribut innerhalb der Klasse, sonst Klasse.Attribut
\NewDocumentCommand{\refattr}{mmO{__DEFAULT__}}{%
  \def\@refattr@tmp@text{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the attribute name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}\xspace}
  \ifhaslabel{\@attrlabel{#1}{#2}}{% if the label exists...
    \hyperref[\@attrlabel{#1}{#2}]{\@refattr@tmp@text}}{% the reference it...
    \@refattr@tmp@text}% else just print the text.
  \let\@refattr@tmp@text=\undefined%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. (optional) Text – default: Methode innerhalb der Klasse, sonst Klasse.Methode
\NewDocumentCommand{\refmethod}{mmO{__DEFAULT__}}{%
  \def\@refmethod@tmp@text{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the method name
        }{%
          #1.#2%
        }%
      }{%
        #3%
    }}\xspace}%
  \ifhaslabel{\@methodlabel{#1}{#2}}{% if the label exists...
    \hyperref[\@methodlabel{#1}{#2}]{\@refmethod@tmp@text}}{% then reference it...
    \@refmethod@tmp@text}% else just print the text.
  \let\@refmethod@tmp@text=\undefined%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. Parameter
% 4. (optional) Text – default: Parameter innerhalb der Methode, sonst Methode.Parameter innerhalb der Klasse, sonst Klasse.Methode.Parameter
\NewDocumentCommand{\refparam}{mmmO{__DEFAULT__}}{%
  \def\@refparam@tmp@text{\code{%
      \ifthenelse{\equal{#4}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          \ifthenelse{\equal{\currentmethod}{#2}}{%
            #3% we’re inside the same method, only use the parameter name
          }{%
            #2.#3% we’re inside the same class, only use the method and parameter name
        }}{%
          #1.#2.#3%
      }}{%
        #4%
  }}\xspace}%
  \ifhaslabel{\@paramlabel{#1}{#2}{#3}}{% if the label exists...
    \hyperref[\@paramlabel{#1}{#2}{#3}]{\@refparam@tmp@text}}{% then reference it...
      \@refparam@tmp@text}% else just print the text.
  \let\@refparam@tmp@text=\undefined%
}
% Argumente:
% 1. Enum
% 2. Konstante
% 3. (optional) Text – default: Konstante innerhalb der Enum, sonst Enum.Konstante
\NewDocumentCommand{\refconstant}{mmO{__DEFAULT__}}{%
  \def\@refconstant@tmp@text{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentenum}{#1}}{%
          #2% we’re inside the same enum, only use the constant name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}\xspace}%
  \ifhaslabel{\@constantlabel{#1}{#2}}{% if the label exists...
    \hyperref[\@constantlabel{#1}{#2}]{\@refconstant@tmp@text}}{% then reference it...
    \@refconstant@tmp@text}% else just print the text.
  \let\@refconstant@tmp@text=\undefined%
}


\makeatother

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{%
  \glsdoifexists{#2}{%
    \def\@glsnumberformat{glsgobblenumber}%
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}%
    \setkeys{glossadd}{#1}%
    \@gls@saveentrycounter%
    \@do@wrglossary{#2}%
  }%
}
\newcommand{\glsaddallunused}[1][]{%
  \edef\@glo@type{\@glo@types}%
  \setkeys{glossadd}{#1}%
  \forallglsentries[\@glo@type]{\@glo@entry}{%
    \ifglsused{\@glo@entry}{}{%
      \typeout{****Glossary entry '\@glo@entry' unused****}%
      \glsaddnp[#1]{\@glo@entry}}}%
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

\makeatletter

\begin{document}
\shorthandoff{"}

\sloppy % fix overfull hboxes

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\emph{routeKIT}\xspace}


% alle Glossareinträge
\newglossaryentry{profil}{
  name={Profil},
  description={enthält für die Routenplanung relevante Informationen, z.\,B. die Höhe und das Gewicht des Fahrzeugs},
  plural={Profile}
}
\newglossaryentry{karte}{
  name={Karte},
  description={enthält die Daten aus \gls{osm} sowie einen Namen},
  plural={Karten}
}
\newglossaryentry{osmkachel}{
  name={OSM-Kachel},
  description={die öffentlichen gerenderten \gls{osm}-Kacheln z.\,B. auf\\\mbox{\url{http://a.tile.openstreetmap.org/}}},
  plural={OSM-Kacheln}
}
\newglossaryentry{route}{
  name={Route},
  description={ein Weg von einem Start- zu einem Zielpunkt},
  plural={Routen}
}
\newglossaryentry{vorberechnung}{
  name={Vorberechnung},
  description={verbindet die \gls{karte} mit den auf einem \gls{profil} basierenden Informationen und ermöglicht, unter anderem mittels \gls{arc}, später eine Beschleunigung der Berechnung einer \gls{route}; muss für jede neue \gls{karte}/\gls{profil}-Kombination einmal ausgeführt werden},
  plural={Vorberechnungen},
  see={arc}
}
\newglossaryentry{rendern}{
  name={rendern},
  description={Berechnung einer Bildkachel aus den zu rendernden Daten}
}
\newglossaryentry{wegbeschreibung}{
  name={Wegbeschreibung},
  description={Beschreibung einer \gls{route} durch eine Liste von Abbiegeanweisungen}
}
\newglossaryentry{dijkstra}{
  name={Dijkstra’s Algorithmus},
  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
}
\newglossaryentry{arc}{
 name={Arc-Flags},
 description={eine Technik, um eine Routenberechnung zu beschleunigen}
}
\newglossaryentry{verlauf}{
  name={Verlauf},
  description={speichert Routenanfragen für spätere Wiederverwendung. Es existiert nur ein Verlauf für die gesamte Anwendung}
}
\newglossaryentry{mercator}{
  name={Mercator-Projektion},
  description={die Zylinderprojektion der Weltkugel}
}
\newglossaryentry{entwurfsmuster}{
  name={Entwurfsmuster},
  description={Eine Schablone, die eine Lösung für ein oder mehrere Entwurfsprobleme darstellt. Ihre Verwendung erleichtert Änderungen im Entwurf}
}
\newglossaryentry{beobachter}{
  name={Beobachter},
  description={Ein \gls{entwurfsmuster}, das bei Änderung des Zustands eines Objektes alle abhängenden Objekte benachrichtigt}
}
\newglossaryentry{einzelstueck}{
  name={Einzelstück},
  description={Ein \gls{entwurfsmuster}, das zusichert, dass eine Klasse genau ein Exemplar besitzt und stellt einen globalen Zugriffspunkt darauf bereit}
}
\newglossaryentry{dekorierer}{
  name={Dekorierer},
  description={Ein \gls{entwurfsmuster}, das dynamisch neue Funktionalität zum Objekt hinzufügt}
}
\newglossaryentry{strategie}{
  name={Strategie},
  description={Ein \gls{entwurfsmuster}, das eine Familie von Algorithmen definiert, sie kapselt und austauschbar macht}
}
\newglossaryentry{G_smt}{
  name={Slippy Map Tile},
  description={
    Koordinaten, durch die Kartenkacheln einer graphischen Darstellung (mit \gls{mercator}) adressiert werden können.
    Drei Bestandteile: x, y, zoom.
    Mit nicht-ganzzahligen Werten für x und y können nicht nur Kacheln, sondern auch Geokoordinaten adressiert werden}
}
\newglossaryentry{smt}{
  type=\acronymtype,
  name={SMT},
  description={Slippy Map Tile},
  first={Slippy Map Tile (SMT)},
  see=[Glossareintrag:]{G_smt}
}
\newglossaryentry{opaque}{
  name={deckend},
  description={
    Die innere Implementierung wird vor anderen Klassen verborgen; Zugriff ist nur über das definierte Interface der Klasse/Methode möglich. (engl. “opaque”)}
}

\newacronym[longplural=Personenkraftwagen]{pkw}{PKW}{Personenkraftwagen}
\newacronym[longplural=Lastkraftwagen]{lkw}{LKW}{Lastkraftwagen}
\newacronym{osm}{OSM}{OpenStreetMap}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{gpx}{GPX}{GPS Exchange Format}
\newacronym{mvc}{MVC}{Model View Controller}
\newacronym{cli}{CLI}{Command Line Interface}



\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Testdokument}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage


\section{Einleitung}
Dieses Dokument erläutert und protokolliert die Qualitätssicherung der Anwendung \routeKIT. Es dokumentiert die gefundenen Fehler, die durchgeführten Unit-Tests, die Testüberdeckung und die durchgeführten Änderungen seit der Implementierungsphase.

\routeKIT ist eine Anwendung zur Routenplanung; durch Verwendung von \glslink{profil}{Profilen} kann sie dem Benutzer die optimalen \glspl{route} für sein spezielles Fahrzeug angeben.
Um die Routenberechnung zu beschleunigen, wird pro \gls{profil} und \gls{karte} eine zeitaufwändige \gls{vorberechnung} durchgeführt.

\section{Fehlerprotokoll}

\subsection{Kritische Fehler}

\subsection{Funktionale Fehler}
\begin{itemize}
\bug{missingStreet}{Fehlende Straßen}{
Im vergröberten Graph fehlen Straßen.
}{
Die entsprechenden Kanten werden weggeworfen.
}{
Der Fehler liegt in einem break, das nach der ersten ein-Kanten-Straße das Kanten-erzeugen abgebrochen hat.
}{
behoben
}
\bug{pointProjection}{Punkt Projektion}{
Die Projektion von angeklickten Koordinaten auf Kanten war manchmal leicht schief.
}{
Die Projektion fand im Geokoordinatensystem statt und nicht nach der Mercator-Projektion (also im SMT-Koordinatensystem)
}{
Den Code muss für die Abstandsberechnung SMT Koordinaten benutzen und keine Geokoordinaten.
}{
behoben
}
\bug{cornerOneway}{Einbahnstraßen Randfall}{
Eine Route auf einer einzelnen Kante, die nur in eine Richtung benutzbar ist, kann die Kante auch in die falsche Richtung benutzen.
}{
Es wird nur verhindert, dass man in Einbahnstraßen falschrum einbiegt und nicht falschrum darin losfährt.
}{
Führe den ersten Schritt der Routenberechnung gesondert aus, um dies als Spezialfall zu behandeln.
}{
behoben
}
\bug{profileNoWarning}{ProfileManager Warnung bei Enter}{
Wenn im ProfileManager-Dialog Vorberechnungen gelöscht werden und er mit "Enter" geschlossen wird erscheint keine Warnung. Beim Klick auf den "OK"-Knopf erscheint Sie aber.
}{
Der Programmcode der die Warnung erzeugt war explizit im Programmcode für den Knopf und nicht im gemeinsamen Programmcode, der abspeichert.
}{
Verschiebe die Warnungs-Programmcode in den gemeinsamen code, sodass er für beide Möglichkeiten des Schließens ausgeführt wird.
}{
behoben
}
\end{itemize}

\subsection{Benutzbarkeitsfehler}
\begin{itemize}
\bug{slowRender}{Vergröberung nötig}{
Das Rendern der Kacheln ist auf Zoomstufen weiter weg zu langsam.
}{
Es werden immernoch viele feine "Kanten" gezeichnet.
}{
Der Graph muss für die Anzeige vergröbert werden, sodass weniger Kanten gezeichnet werden müssen.
}{
behoben
}
\bug{routeCalcAllEdges}{Routenberechnung alle Kanten}{
Die Routenberechnung ist zu langsam, auch für kurze Routen.
}{
Der Algorithmus hat trotzdem über alle Kanten des Graphen iteriert, obwohl das eigentlich dank der ArcFlags und einer kurzen Route nicht nötig wäre.
}{
Initialisiere mehrere Daterstrukturen "lazy". (nicht eingefügte Kanten sind "unendlich" weit weg.... usw.)
}{
behoben
}
\bug{precalc}{Vorberechnung alle Kanten}{
Die Vorberechnung ist zu langsam.
}{
Es wurden für jeden der Dijkstras am Anfang alle Kanten des Graphen eingefügt.
}{
Es wird nur noch nötig die erste Kante am Anfang einzufügen.
}{
behoben
}
\bug{routeCalcKeineRoute}{Falscher Infotext während Routenberechnung}{
Während der Routenberechnung zeigt die Wegbeschreibungs-/Info-Box den Text „keine Route gefunden“.
}{
Begonnene Routenberechnungen wurden dem RouteModel nicht mitgeteilt, so dass die MainView nicht erfahren konnte, dass gerade eine Berechnung lief.
}{
Hinzufügen von \code{isCalculated()} zum RouteModel; siehe auch TODO ref! unten.
}{
behoben
}
\end{itemize}
\section{Testfälle aus dem Pflichtenheft}

\begin{tabular}{|l|l|}
	\hline
	Test & Status \\
	\hline
	\hline
	TF10 & bestanden \\
	\hline
\end{tabular}

\section{Protokoll der Unit-Tests}
\begin{itemize}
\test{gpxExport}{GPXExporter}{
  Es wird die GPX-Export-Funktion des Programms getestet.
}{
  Die erzeugte Datei muss ein gültiges XML-Dokument sein.
}{bestanden}

\test{htmlExprt}{HTMLExporter}{
  Es wird die HTML-Export-Funktion des Programms getestet.
}{
  Die erzeugte Datei muss ein gültiges XML-Dokument sein.
}{bestanden}

\test{history}{History}{
  Es wird die Speicher- und Lade-Funktion des Verlaufs getestet.
}{
  Der Verlauf muss nach dem Speichern und anschließenden Laden die gleichen Einträge enthalten wie davor.
}{bestanden}

\test{historyEntry}{HistoryEntry}{
  Es werden die toString und fromString Methoden der Verlaufseinträge getestet.
}{
  Ein HistoryEntry muss nach Anwenden von fromString auf den von toString erzeugten String den selben Start- und Zielpunkt sowie Zeitstempel enthalten.
}{bestanden}

\test{edgeProps}{EdgeProperties}{
  Es werden die Getter von EdgeProperties und insbesondere getMaxSpeed getestet.
}{
  Die Getter müssen den korrekten Wert zurückgeben.
  getMaxSpeed muss, je nach Straßentyp und übergebenem Profil, 
  die korrekte Höchstgeschwindigkeit des gegebenen Fahrzeugtyps auf diesem Straßentyp zurückgeben.
}{bestanden}

\test{restriction}{Restriction}{
  Es wird für verschiedene Restrictions (Height-, Width-, Weight-, VehicleType-, Multiple-, NoRestriction)
  die allows Methode für die Profile defaultCar und defaultTruck getestet.
}{
  Bei jeder getesteten Restriction muss allows für defaultCar und defaultTruck die korrekte Ausgabe haben.
}{bestanden}

\test{edgeBasedGraph}{EdgeBasedGraph}{
  Es wird die Speicher- und Lade-Funktion von EdgeBasedGraph getestet.
}{
  Der EdgeBasedGraph muss nach dem Speichern und anschließenden Laden die gleichen Edges und Turns enthalten wie davor.
}{bestanden}

\test{graph}{Graph}{
  Es werden die Getter sowie die Speicher- und Lade-Funktion von Graph getestet.
}{
  Die Getter müssen den korrekten Wert zurückgeben. Der Graph muss nach dem Speichern und anschließenden Laden die gleichen Nodes und Edges enthalten wie davor.
}{bestanden}

\test{graphIndex}{GraphIndex}{
  Beide GraphIndex-Implementierungen (Array- und Tree-) werden mit demselben Graphen 
  (einem Gitter aus unverbundenen Straßenstücken) initialisiert.
  Dann werden verschieden Bereiche von Kanten angefordert und verglichen.
  Danach werden noch Koordinaten mit dem Index projeziert.
}{
  Die resultierenden Kantenmengen und der Punkt auf der Kante stimmen jeweils mit den erwarteten überein.
}{bestanden}

\test{tileCacheCache}{TileCache Cache}{
  Es wird getestet, dass der TileCache Kacheln zwischenspeichert.
}{
  Eine Kachel, die bei der ersten Anfrage noch eine Dummy-Kachel war, soll bei einer zweiten Anfrage nach 100ms keine Dummy-Kachel mehr sein.
}{bestanden}

\test{tileCachePrefetch}{TileCache Prefetch}{
  Es wird getestet, dass Prefetching (vorsorgliche Berechnung von benachbarten Kacheln, auch wenn diese noch nicht direkt angefragt wurden) funktioniert.
}{
  Nachdem Kacheln angefragt wurden und 100ms gewartet wurde, sollen auch benachbarte Kacheln keine Dummy-Kacheln mehr sein.
}{bestanden}

\test{tileCacheCleanup}{TileCache Cleanup}{
  Es wird getestet, dass der TileCache auch Kacheln wegwirft.
}{
  Eine Kachel wird angefragt, dann werden $50^2$ andere Kacheln angefragt. Wenn die erste Kachel erneut angefragt wird, soll sie eine Dummy-Kachel sein.
}{bestanden}

\test{arcflags}{ArcFlags}{
  Es wird die Speicher- und Lade-Funktion der ArcFlags getestet.
}{
  Nach dem Speichern und anschließenden Laden müssen die gleichen ArcFlags gesetzt sein wie davor.
}{bestanden}

\test{routeModel}{RouteModel}{
  Testet ob bei den Benutzung von RouteModel immer die spezifizierte Anzahl an Events an alle Listener ausgegeben wird. Dafür wird ein Testlistener registriert und verschiedene Änderungen an den Daten durchgeführt.
}{
  Die gemessene Anzahl der ausgelösten Events an alles Stellen mit der erwarteten übereinstimmt
}{bestanden}

\test{weights}{Weights}{
  Es wird die Speicher- und Lade-Funktion der Weights getestet.
}{
  Nach dem Speichern und anschließenden Laden müssen die gleichen Kantengewichte gesetzt sein wie davor.
}{bestanden}

\test{mapEdge}{MapEdge}{
  Es wird die MapEdge-Klasse getestet, die vom OSMParser verwendet wird.
}{
  Das Setzen der ID muss korrekt funktionieren. Die Getter müssen die richtigen Werte zurückgeben.
}{bestanden}

\test{osmParser}{OSMParser}{
  Testet verschiedene Karteneigenschaften
  (verschiedene Abbiegetypen, Einbahnstraßen, Ampeln, Kreisverkehre, \ldots)
  und auch Kartenfehler (Eigenschaften ohne Name, Eigenschaften ohne Wert,
  fehlende Koordinaten, Ungültige Koordinaten,\ldots)
}{
  die gültigen Strukturen genau so im Graph nachher vorhanden sind und bei allen ungültigen Karten ein Fehler ausgelöst wird.
}{bestanden}

\test{osmWay}{OSMWay}{
  Es wird getestet, ob die OSMWay Klasse verschiedene OSMTags richtig verarbeitet.
}{
  alle OSM Tags auf die richtigen Strukturen im Graph abgebildet werden. (Straßentyp, Kreisverkehr, \ldots)
}{bestanden}

\test{profileMapComb}{ProfileMapCombination}{
  Es wird die Speicher- und Lade-Funktion von ProfileMapCombination getestet.
}{
  Die ProfileMapCombination muss nach dem Speichern und anschließenden Laden das gleiche Profil
  und die gleiche Streetmap sowie, falls vorhanden, die gleiche abgeschlossene Vorberechnung
  (Weights, ArcFlags, benötigte Zeit) enthalten wie davor.
}{bestanden} //TODO Den entsprechenden Test umbenennen von TestPrecalculationSaveLoad in ProfileMapCombinationSaveLoad?

\test{turnRestriction}{TurnRestriction}{
  Es wird die Funktionalität von TurnRestrictions getestet.
}{
  Eine TurnRestriction muss ihren Start- und Ziel-OSMWay korrekt zurückgeben. allowsTurn muss korrekt entscheiden, ob ein Turn auf einen OSMWay erlaubt ist oder nicht.
}{bestanden}

\test{profile}{Profile}{
  Es werden equals und clone sowie die Setter, Getter und die Speicher- und Lade-Funktion der Profile getestet.
}{
  equals und clone müssen wie erwartet funktionieren. Die Setter müssen die verschiedenen Werte (VehicleType, Height, Width, etc.) korrekt setzen. Die Setter dürfen die Werte von Standardprofilen nicht verändern. Die Getter müssen die korrekten Werte zurückgeben. Das Profil muss nach dem Speichern und anschließenden Laden die gleichen Werte enthalten wie davor.
}{bestanden}

\test{fibHeap}{FibonacciHeap}{
  Es werden die verschiedenen Operationen für den Heap getestet.
  So wird das Einfügen und Entfernen von Elementen, sowie das Ändern der Priorität getestet.
}{
  Alle Operation müssen die erwarteten Werte zurückgeben. So muss die deleteMin-Methode nachdem Elemente hinzugefügt und Prioritäten geändert wurden immer das Element mit der minimalen Priorität zurückgeben.
}{bestanden}

\test{coords}{Coordinates}{
  Es werden die distanceTo, angleBetween sowie to/fromString/SMT Methoden von Coordinates getestet.
}{
  distanceTo muss die korrekte Entfernung zwischen zwei Punkten zurückgeben.
  angleBetween muss den korrekten, zwischen zwei durch zwei Punkte angegebenen
  Geraden eingeschlossenen Winkel zurückgeben.
  Anwenden von von fromString/fromSMT auf den/die von toString/toSMT erzeugten
  String/SMT-Koordinaten muss Coordinates mit gleichen Koordinaten wie die ursprünglichen
  Coordinates erzeugen.
}{bestanden}

\test{pointOnEdge}{PointOnEdge}{
  Es werden der Konstruktor sowie die Getter von PointOnEdge getestet.
}{
  Der Konstruktor darf nur positive EdgeIDs sowie Positionen zwischen 0 und 1 annehmen. Die Getter müssen die korrekten Werte zurückgeben.
}{bestanden}

\test{fileUtil}{FileUtil}{
  Es werden checkMapName und checkProfileName getestet.
}{
  checkMapName/checkProfileName muss zulässige Map-/Profilnamen akzeptieren und alles andere ablehnen.
}{bestanden}
\end{itemize}

\section{Protokoll des GUI-Tests}
\subsection{Automatisierter Test}
Bei allen hier beschriebenen Testfällen gilt als Vorbedingung, dass \routeKIT gestartet ist.
\begin{description}
\newcounter{oitemTF}
\setcounter{oitemTF}{400}
\oitem{TF}{aboutviewopen} Über-Fenster öffnen
\testfall
    {Alle Fenster außer dem Hauptfenster sind geschlossen.}
    {"routeKIT/Über..." in der Menuleiste wird ausgewählt.}
    {Das Fenster mit den Informationen über das Programm erscheint.}
\oitem{TF}{aboutviewclose} Über-Fenster schließen
\testfall
    {Das Über-Fenster ist geöffnet.}
    {Die Tastenkombination Alt-F4 drücken.}
    {Das Über-Fenster wird geschlossen.}
\oitem{TF}{swap} Koordinaten vertauschen
\testfall
    {Das Start- und das Zielfeld enthalten gültige Koordinaten.}
    {Der Start/Ziel-tauschen-Button wird gedrückt.}
    {Die Eingaben von Start- und Zielfeld werden vertauscht und die Markierungen auf der Karte werden neu gesetzt. Die Route zwischen Start- und Zielpunkt wird berechnet.}
\oitem{TF}{waydescription} Wegbeschreibung
\testfall
    {Das Start- oder das Zielfeld enthält eine gültige Koordinate.}
    {Die fehlende gültige Koordinate wird eingegeben.}
    {Die Markierungen auf der Karte wird gesetzt. Die Route zwischen Start- und Zielpunkt wird berechnet. Die Wegbeschreibung wird in das Wegbeschreibungsfeld ausgegeben.}
\oitem{TF}{mapmanagerviewopen} Kartenverwaltung-Fenster öffnen
\testfall
    {Alle Fenster außer dem Hauptfenster sind geschlossen.}
    {Der Karte-Knopf wird gedrückt.}
    {Das Fenster der Kartenverwaltung erscheint.}
\oitem{TF}{mapimportcorrect} Karte importieren (genauer als /TF290/)
\testfall
    {Das Fenster Kartenverwaaltung ist offen.}
    {Der Importieren-Knopf wird gedrückt. Im Dialog wird der korrekte Pfad und Name der Karte angegeben und zwei mal bestätigt.}
    {Die Kartenverwaltung wird geschlossen. Die importierte Karte ist ausgewählt, die Karte ist für das aktuelle Profil nicht vorberechnet.}
\oitem{TF}{profilemanagerviewopen} Profilverwaltung-Fenster öffnen
\testfall
    {Alle Fenster außer dem Hauptfenster sind geschlossen.}
    {Der Profil-Knopf wird gedrückt.}
    {Das Fenster der Profilverwaltung erscheint.}




\end{description}

Der Test wird mit der Karte "Regierungsbezirk Karlsruhe" und dem dafür vorberechneten Standardprofil "PKW (Standard)" gestartet. Eine Internetverbindung ist hergestellt.
\begin{longtable}{||c|c|c||}
Testnummer & bestanden & Vorbedingungen erfüllt wegen\\ \hline\hline
\endfirsthead
/TF30/ & \cmark &  Neustart der Anwendung  \\ \hline
\ref{TF:aboutviewopen}& \cmark & Neustart der Anwendung \\ \hline
\ref{TF:aboutviewclose}& \cmark & \ref{TF:aboutviewopen} \\ \hline
/TF150/ & \cmark & /TF30/ und der Bedingung für den Test \\ \hline
/TF80/ und /TF100/ & \cmark & /TF30/ und der Bedingung für den Test \\ \hline
/TF90/ und \ref{TF:waydescription} & \cmark & /TF30/ und der Bedingung für den Test \\ \hline
/TF70/ & \cmark & /TF90/ \\ \hline
/TF20/ & \cmark & /TF90/ und \ref{TF:waydescription} \\ \hline
\ref{TF:swap} & \cmark & /TF90/ und \ref{TF:waydescription} \\ \hline
/TF200/ & \cmark & /TF30/ und der Bedingung für den Test \\ \hline
/TF210/ & \cmark & /TF30/ und /TF200/ \\ \hline
/TF120/ und /TF220/& \cmark & /TF30/ \\ \hline
/TF130/ und /TF220/& \cmark & /TF30/ \\ \hline
\ref{TF:mapmanagerviewopen} & \cmark & \ref{TF:aboutviewclose} \\ \hline
\ref{TF:mapimportcorrect}& \cmark & \ref{TF:mapmanagerviewopen} \\ \hline
/TF10/ & \cmark & /TF30/ und \ref{TF:mapimportcorrect} \\ \hline
\ref{TF:profilemanagerviewopen} & \cmark & /TF30/ und \ref{TF:mapimportcorrect} \\ \hline
/TF240/ & \cmark & der Bedingung für den Test \\ \hline
/TF10/ & \cmark & /TF30/ und /TF240/ \\ \hline




\end{longtable}

\section{Testüberdeckung}

\section{Änderungen seit der Implementierung}
Im Folgenden sind die gegenüber der Implementierung geänderten und neu hinzugefügten Klassen, Methoden und Attribute aufgeführt.

\begin{itemize}
\item GraphIndex-Änderungen
  \begin{itemize}
  \item Die Klasse \code{GraphIndex} wurde zu einem Interface geändert und die bisherige Implementierung in die Klasse \code{TreeGraphIndex} verschoben.
  \item Eine weitere Implementierung von \code{GraphIndex}, \code{ArrayGraphIndex}, wurde geschrieben.
    Sie verwendet nur zwei int-Arrays und ist dadurch leicht schneller und lässt sich gut speichern/laden.
  \item \code{Graph} verwendet \code{ArrayGraphIndex}.
  \item \code{Graph} lädt \code{ArrayGraphIndex} von der Festplatte, statt sie neu aufzubauen, wenn die Dateien vorhanden sind. Dies beschleunigt den Start der Anwendung erheblich.
  \end{itemize}
\item \ref{BG:routeCalcKeineRoute}
  \begin{itemize}
  \item \code{RouteModel} erhält die neuen Methoden \code{startCalculating()}, um den Beginn einer Routenberechnung zu melden, und \code{isCalculating()}, um abzufragen, ob aktuell eine Routenberechnung stattfindet.
    (Eine Routenberechnung endet implizit bei Aufruf von \code{setCurrentRoute()}.)
  \end{itemize}
\end{itemize}

\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
