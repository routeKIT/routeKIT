% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands
\usepackage{xspace} % \xspace for use in commands: put a space only if no punctuation follows
\usepackage{enumitem} % for controlling indentation in list environments
\usepackage{amssymb} % for checkmark


\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\makeatletter

\providecommand{\rowno}[1][__empty__]{%
\ifthenelse{\isundefined{\c@rowno}}{%
\newcounter{rowno}}{}%
\addtocounter{rowno}{1}
\ifthenelse{\equal{#1}{__empty__}}{%
\therowno%
}{%
\namedlabel{#1}{\therowno}%
}%

}

\newcommand{\oitem}[2]{
  % define the counter
  \@ifundefined{c@oitem#1}{\newcounter{oitem#1}}{} % initialized at 0
  \addtocounter{oitem#1}{10}
  \item[\namedlabel{#1:#2}{/#1\arabic{oitem#1}/}]
}

\newcommand{\bug}[6]{%
  \oitem{BG}{#1}
  	#2
    \begin{description}
    \item[Symptom] #3
    \item[Ursache] #4
    \item[Maßnahme] #5
    \item[Status] #6
    \end{description}
}

\newcommand{\guitest}[3]{%
  \item
    \begin{description}
    \item[Aktion] #1
    \item[Ergebnis] #2
    \item[Status] #3
    \end{description}
}

\NewDocumentCommand{\test}{m m O{} m m m}{%
  \oitem{UT}{#1} 
    \begin{description}
    \item[Was wird getestet] \code{#2} #3
    \item[Beschreibung] #4
    \item[Bestanden, wenn] #5
    \item[Status] #6
    \end{description}
}

% usage: \testfall{szenario}{ablauf}{ergebnis} oder \testfall[\ref{F:getesteteFunktion}]{szenario}{ablauf}{ergebnis}
\newcommand{\testfall}[4][]{
  \begin{description}
    \ifthenelse{\equal{#1}{}}
               {} % optional argument #1 is empty: skip
               {\item[Testet] #1}
    \item[Vorbedingungen] #2
    \item[Ablauf] #3
    \item[Erwartetes Ergebnis] #4
  \end{description}
}

\makeatother

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{%
  \glsdoifexists{#2}{%
    \def\@glsnumberformat{glsgobblenumber}%
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}%
    \setkeys{glossadd}{#1}%
    \@gls@saveentrycounter%
    \@do@wrglossary{#2}%
  }%
}
\newcommand{\glsaddallunused}[1][]{%
  \edef\@glo@type{\@glo@types}%
  \setkeys{glossadd}{#1}%
  \forallglsentries[\@glo@type]{\@glo@entry}{%
    \ifglsused{\@glo@entry}{}{%
      \typeout{****Glossary entry '\@glo@entry' unused****}%
      \glsaddnp[#1]{\@glo@entry}}}%
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

\makeatletter

\begin{document}
\shorthandoff{"}

\sloppy % fix overfull hboxes

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\emph{routeKIT}\xspace}


% alle Glossareinträge
\newglossaryentry{profil}{
  name={Profil},
  description={enthält für die Routenplanung relevante Informationen, z.\,B. die Höhe und das Gewicht des Fahrzeugs},
  plural={Profile}
}
\newglossaryentry{karte}{
  name={Karte},
  description={enthält die Daten aus \gls{osm} sowie einen Namen},
  plural={Karten}
}
\newglossaryentry{osmkachel}{
  name={OSM-Kachel},
  description={die öffentlichen gerenderten \gls{osm}-Kacheln z.\,B. auf\\\mbox{\url{http://a.tile.openstreetmap.org/}}},
  plural={OSM-Kacheln}
}
\newglossaryentry{route}{
  name={Route},
  description={ein Weg von einem Start- zu einem Zielpunkt},
  plural={Routen}
}
\newglossaryentry{vorberechnung}{
  name={Vorberechnung},
  description={verbindet die \gls{karte} mit den auf einem \gls{profil} basierenden Informationen und ermöglicht, unter anderem mittels \gls{arc}, später eine Beschleunigung der Berechnung einer \gls{route}; muss für jede neue \gls{karte}/\gls{profil}-Kombination einmal ausgeführt werden},
  plural={Vorberechnungen},
  see={arc}
}
\newglossaryentry{rendern}{
  name={rendern},
  description={Berechnung einer Bildkachel aus den zu rendernden Daten}
}
\newglossaryentry{wegbeschreibung}{
  name={Wegbeschreibung},
  description={Beschreibung einer \gls{route} durch eine Liste von Abbiegeanweisungen}
}
\newglossaryentry{dijkstra}{
  name={Dijkstra’s Algorithmus},
  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
}
\newglossaryentry{arc}{
 name={Arc-Flags},
 description={eine Technik, um eine Routenberechnung zu beschleunigen}
}
\newglossaryentry{verlauf}{
  name={Verlauf},
  description={speichert Routenanfragen für spätere Wiederverwendung. Es existiert nur ein Verlauf für die gesamte Anwendung}
}
\newglossaryentry{mercator}{
  name={Mercator-Projektion},
  description={die Zylinderprojektion der Weltkugel}
}
\newglossaryentry{entwurfsmuster}{
  name={Entwurfsmuster},
  description={Eine Schablone, die eine Lösung für ein oder mehrere Entwurfsprobleme darstellt. Ihre Verwendung erleichtert Änderungen im Entwurf}
}
\newglossaryentry{beobachter}{
  name={Beobachter},
  description={Ein \gls{entwurfsmuster}, das bei Änderung des Zustands eines Objektes alle abhängenden Objekte benachrichtigt}
}
\newglossaryentry{einzelstueck}{
  name={Einzelstück},
  description={Ein \gls{entwurfsmuster}, das zusichert, dass eine Klasse genau ein Exemplar besitzt und stellt einen globalen Zugriffspunkt darauf bereit}
}
\newglossaryentry{dekorierer}{
  name={Dekorierer},
  description={Ein \gls{entwurfsmuster}, das dynamisch neue Funktionalität zum Objekt hinzufügt}
}
\newglossaryentry{strategie}{
  name={Strategie},
  description={Ein \gls{entwurfsmuster}, das eine Familie von Algorithmen definiert, sie kapselt und austauschbar macht}
}
\newglossaryentry{G_smt}{
  name={Slippy Map Tile},
  description={
    Koordinaten, durch die Kartenkacheln einer graphischen Darstellung (mit \gls{mercator}) adressiert werden können.
    Drei Bestandteile: x, y, zoom.
    Mit nicht-ganzzahligen Werten für x und y können nicht nur Kacheln, sondern auch Geokoordinaten adressiert werden}
}
\newglossaryentry{smt}{
  type=\acronymtype,
  name={SMT},
  description={Slippy Map Tile},
  first={Slippy Map Tile (SMT)},
  see=[Glossareintrag:]{G_smt}
}
\newglossaryentry{opaque}{
  name={deckend},
  description={
    Die innere Implementierung wird vor anderen Klassen verborgen; Zugriff ist nur über das definierte Interface der Klasse/Methode möglich. (engl. “opaque”)}
}

\newacronym[longplural=Personenkraftwagen]{pkw}{PKW}{Personenkraftwagen}
\newacronym[longplural=Lastkraftwagen]{lkw}{LKW}{Lastkraftwagen}
\newacronym{osm}{OSM}{OpenStreetMap}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{gpx}{GPX}{GPS Exchange Format}
\newacronym{mvc}{MVC}{Model View Controller}
\newacronym{cli}{CLI}{Command Line Interface}



\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Testdokument}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage


\section{Einleitung}
Dieses Dokument erläutert und protokolliert die Qualitätssicherung der Anwendung \routeKIT. Es dokumentiert die gefundenen Fehler, die durchgeführten Unit-Tests, die Testüberdeckung und die durchgeführten Änderungen seit der Implementierungsphase.

\routeKIT ist eine Anwendung zur Routenplanung; durch Verwendung von \glslink{profil}{Profilen} kann sie dem Benutzer die optimalen \glspl{route} für sein spezielles Fahrzeug angeben.
Um die Routenberechnung zu beschleunigen, wird pro \gls{profil} und \gls{karte} eine zeitaufwändige \gls{vorberechnung} durchgeführt.

\section{Fehlerprotokoll}

\subsection{Kritische Fehler}
\begin{itemize}
\bug{corruptIndex}{Korrupte Indexdatei}
    {Wenn die Indexdatei Karten oder Profile enthält, die nicht existieren, stürzt \routeKIT beim Programmstart ab.}
    {Es wird versucht, auf Karten/Profile, die \code{null} sind, zuzugreifen.}
    {Karte oder Profil überspringen, wenn es \code{null} ist.}
    {behoben}
\end{itemize}

\subsection{Funktionale Fehler}
\begin{itemize}
\bug{missingStreet}{Fehlende Straßen}
    {Im vergröberten Graph fehlen Straßen.}
    {Die entsprechenden Kanten werden weggeworfen.}
    {Ein falsches \code{break} entfernen, das nach der ersten Ein-Kanten-Straße das Erzeugen von Kanten abbricht.}
    {behoben}
\bug{pointProjection}{Punkt-Projektion}
    {Die Projektion von eingegebenen Koordinaten auf Kanten ist oft schief.}
    {Die Projektion findet im Geokoordinatensystem statt und nicht nach der \gls{mercator} (also im SMT-Koordinatensystem).}
    {Den Code muss für die Abstandsberechnung SMT-Koordinaten benutzen und keine Geokoordinaten.}
    {behoben}
\bug{cornerOneway}{Einbahnstraßen, Randfall}
    {Eine Route auf einer einzelnen Kante, die nur in einer Richtung befahrbar ist, kann die Kante auch entgegen der Fahrtrichtung benutzen.}
    {Es wird nicht verhindert, dass man in Einbahnstraßen entgegen der Fahrtrichtung losfährt.}
    {Den ersten Schritt der Routenberechnung gesondert ausführen, um dies als Spezialfall zu behandeln.}
    {behoben}
\bug{profileNoWarning}{Profilverwaltung: Warnung bei Enter}
    {Wenn im Profilverwaltungsdialog Vorberechnungen gelöscht werden und er mit \textit{Enter} geschlossen wird, erscheint keine Warnung. Beim Klick auf \textit{OK} erscheint sie aber.}
    {Der Code, der die Warnung erzeugt, liegt im Event-Handler des Buttons und nicht in der Methode der \code{ProfileManagerView}, die den Dialog schließt.}
    {Den Code, der die Warnung erzeugt, in die \code{ok}-Methode der \code{ProfileManagerView} verschieben.}
    {behoben}
\bug{testCLIHelp}{CLI-Hilfe Test}
    {Der Test für die Ausgabe des Hilfetext für das Konsoleninterface schlägt auf Windows-Systemen
    mit einer \code{ArrayIndexOutOfBoundsException} fehl, obwohl er auf Linux-Systemen funktioniert.}
    {Die Ausgabe des Hilfetexts wird in ein Bytearray geschrieben. Dieses wird mit der Größe des Referenzstrings alloziert. Da auf Linux nur ein Byte für den Zeilenumbruch genutzt wird und auf Windows zwei, läuft das Array über.}
    {Erzeuge einen plattformabhängigen Referenzstring mit den richtigen Zeilenumbrüchen, damit er mit der Ausgabe exakt übereinstimmt.}
    {behoben}
\bug{deleteProfileWhileAddingToMap}{Karten- und Profilverwaltung: Inkonsistenz}
    {In der Kartenverwaltung ist ein Profil für die aktuelle Karte vorberechnet oder soll vorberechnet werden.
    Jetzt wird dieses Profil im Dialog für das Hinzufügen neuer Profile gelöscht.
    Das Profil ist weiterhin in der Liste der Karte vorhanden.}
    {Beim Beenden des Dialogs werden gelöschte Profile nicht richtig erkannt und verarbeitet.}
    {Weiteren Code hinzufügen, der alle gelöschten Profile ermittelt und sie direkt aus den Listen löscht.}
    {behoben}
\bug{currentProfileNotExisting}{Gelöschtes aktuelles Profil}
    {Das einzige Nicht-Standard-Profil ist ausgewählt. In der Kartenverwaltung wird dieses Profil (im Hinzufügen-Dialog) gelöscht und der Dialog mit \textit{OK} geschlossen.
    Beim erneuten Öffnen des Hinzufügen-Dialogs ist ein Standardprofil ausgewählt und die Eingaben sind nicht deaktiviert.}
    {Der Dialog lädt das nicht mehr existierende aktuelle Profil und deaktiviert deshalb die Eingaben nicht.
    Das Profil fehlt aber in der Liste, wodurch ein anderes Profil ausgewählt ist, was nun ein Standardprofil ist.}
    {Beim Löschen eines Profils oder einer Karte immer sicherstellen, dass die aktuelle Kombination nur aus nicht gelöschten Teilen besteht.}
    {behoben}
\bug{noRouteWirdBerechnet}{Falscher Infotext wenn keine Route gefunden wird}
	{Liegen Start- und/oder Zielpunkt außerhalb der Karte,
	d.\,h. \code{find\-Nearest\-Point\-On\-Edge} liefert \code{null},
	so wird der Infotext „Route wird berechnet \dots“ angezeigt, obwohl keine Route existiert.}
	{Zu Beginn der Routenberechnung wird \code{startCalculating} aufgerufen, wodurch „Route wird berechnet \dots“ angezeigt wird.
	In der Abbruchbedingung bei Start/Ziel \code{== null} wird die Routenberechnung abgebrochen,
	ohne \code{currentRoute} und \code{currentDescription} auf \code{null} zu setzen.
	Der Infotext bleibt unverändert auf „Route wird berechnet \dots“}
	{In der Abbruchbedingung \code{currentRoute} und \code{currentDescription} auf \code{null} setzen, wodurch „Keine Route gefunden.“ angezeigt wird.}
	{behoben}
\end{itemize}

\subsection{Benutzbarkeitsfehler}
\begin{itemize}
\bug{routeCalcRaceCondition}{Wettlauf bei der Routenberechnung}
    {Wenn während einer aktiven Routenberechnung eine weitere gestartet wird, kann es passieren,
    dass die erste Route angezeigt wird, obwohl Start und Ziel der zweiten ausgewählt sind.}
    {Wenn die zweite Routenberechnung schneller ist, schreibt sie ihr Ergebnis zuerst und die erste Routenberechnung überschreibt dann anschließend die Route.}
    {Der aktuelle Berechnungsthread wird gespeichert. Die berechnete Route wird nur noch abgeschickt, wenn der berechnende Thread der aktuelle ist.}
    {behoben}
\bug{zoomAndDrag}{Zoom und Ziehen}
    {Wenn die Karte während einer Ziehgeste gezoomt wird, verändert sich die Kartenansicht,
    sodass man auf einem komplett anderen Teil der Karte ist.}
    {Während der Ziehgeste werden die Ursprungskoordinaten der Geste gespeichert.
    Durch das Zoomen werden nun die Koordinaten halbiert (oder verdoppelt),
    was sich aber nicht direkt auf die gespeicherten Koordinaten auswirkt.
    Wird nun die Ziehgeste fortgesetzt, werden diese halb (oder doppelt) so großen Koordinaten
    zurückgeschrieben, was den Sprung auf der Karte verursacht.}
    {Verhindere Zoomen während einer Ziehgeste.}
    {behoben}
\bug{slowRender}{Vergröberung nötig}
    {Das Rendern der Kacheln ist auf kleineren Zoomstufen zu langsam.}
    {Es werden zu viele feine Kanten gezeichnet.}
    {Der Graph muss für die Anzeige vergröbert werden, sodass weniger Kanten gezeichnet werden müssen.}
    {behoben}
\bug{routeCalcAllEdges}{Routenberechnung: alle Kanten}
    {Die Routenberechnung ist zu langsam, auch für kurze Routen.}
    {Der Algorithmus fügt zu Beginn der Berechnung alle vorhandenen Kanten in einen Heap ein, obwohl die eigentliche Routenberechnung durch \gls{arc} oder nah beieinander liegende Start- und Zielpunkte möglicherweise nur auf einen Bruchteil der Kanten zugreifen muss.}
    {Den Heap „lazy“ initialisieren (nicht eingefügte Kanten sind „unendlich“ weit entfernt).}
    {behoben}
\bug{precalc}{Vorberechnung: alle Kanten}
    {Die Vorberechnung ist zu langsam.}
    {Es werden für jeden der Dijkstra-Durchläufe am Anfang alle Kanten des Graphen in den Heap eingefügt, auch wenn später möglicherweise nie darauf zugegriffen wird.}
    {Kanten nur noch bei Bedarf in den Heap einfügen.}
    {behoben}
\bug{routeCalcKeineRoute}{Falscher Infotext während Routenberechnung}
    {Während der Routenberechnung zeigt die Wegbeschreibungs-/Info-Box den Text „keine Route gefunden“ an.}
    {Begonnene Routenberechnungen werden dem \code{RouteModel} nicht mitgeteilt, so dass die \code{MainView} nicht erfahren kann, dass gerade eine Berechnung läuft.}
    {Hinzufügen der Methode \code{isCalculated} zum \code{RouteModel}; siehe auch Abschnitt \ref{change:routeCalcKeineRoute}.}
    {behoben}
\bug{centerMapProfileChange}{Kartenauschnitt zentriert bei Profilwechsel}
	{Der sichtbare Kartenauschnitt wird auf das Zentrum der Karte verschoben, obwohl man nur ein anderes Profil ausgewählt hat.}
	{Der Kartenausschnitt wird zentriert, sobald sich die aktuelle \code{ProfileMapCombination} ändert.}
	{Den Kartenauschnitt nur zentrieren, wenn sich die aktuelle Karte Ändert.}
	{behoben}
\bug{textfieldsProfileMapChange}{Textfelder für Start und Ziel beim Profil-/Kartenwechsel}
	{Wird die Karte oder das Profil geändert blieben in den Textfeldern für Start und Ziel die alten Koordinaten stehen.}
	{Die Route wird zwar zurückgesetzt aber die Textfelder nicht geleert.}
	{Die Textfelder werden nun geleert, sobald die Karte oder das Profil geändert werden.}
	{behoben}
\end{itemize}

\section{Protokoll der Unit-Tests}
\begin{itemize}
\test{gpxExport}{GPXExporter}
     {Es wird die GPX-Export-Funktion des Programms getestet.}
     {die erzeugte Datei ein gültiges XML-Dokument ist.}
     {bestanden}
\test{htmlExprt}{HTMLExporter}
     {Es wird die HTML-Export-Funktion des Programms getestet.}
     {die erzeugte Datei ein gültiges XML-Dokument ist.}
     {bestanden}
\test{history}{History}
     {Es wird die Speicher- und Lade-Funktion des Verlaufs getestet.}
     {der Verlauf nach dem Speichern und anschließenden Laden die gleichen Einträge enthält wie davor.}
     {bestanden}
\test{historyEntry}{HistoryEntry}
     {Es werden die Methoden \code{toString} und \code{fromString} der Verlaufseinträge getestet.}
     {ein Verlaufseintrag nach Anwenden von \code{fromString} auf den von \code{toString} erzeugten String denselben Start- und Zielpunkt sowie Zeitstempel enthält wie davor.}
     {bestanden}
\test{edgeProps}{EdgeProperties}
     {Es werden die Getter von \code{EdgeProperties} und insbesondere \code{get\-Max\-Speed} getestet.}
     {die Getter die korrekten Werte zurückgeben und \code{getMaxSpeed}, je nach Straßentyp und übergebenem Profil, die korrekte Höchstgeschwindigkeit des gegebenen Fahrzeugtyps auf diesem Straßentyp liefert.}
     {bestanden}
\test{restriction}{Restriction}
     {Es wird für verschiedene Beschränkungen (\mbox{\code{Height}-,} \mbox{\code{Width}-,} \mbox{\code{Weight}-,} \mbox{\code{VehicleType}-,} \mbox{\code{Multiple}-,} \code{NoRestriction}) die \code{allows}-Methode für die Profile „PKW (Standard)“ und „LKW (Standard)“ getestet.}
     {bei jeder getesteten Beschränkung \code{allows} für die jeweiligen Profile die korrekte Ausgabe liefert.}
     {bestanden}
\test{edgeBasedGraph}{EdgeBasedGraph}
     {Es wird die Speicher- und Lade-Funktion von \code{EdgeBasedGraph} getestet.}
     {der kantenbasierte Graph nach dem Speichern und anschließenden Laden die gleichen Kanten und Abbiegemöglichkeiten enthält wie davor.}
     {bestanden}
\test{graph}{Graph}
     {Es werden die Getter sowie die Speicher- und Lade-Funktion von \code{Graph} getestet.}
     {die Getter die korrekten Werte zurückgeben und der Graph nach dem Speichern und anschließenden Laden die gleichen Knoten und Kanten enthält wie davor.}
     {bestanden}
\test{graphIndex}{GraphIndex}
     {Es werden \code{findNearestPointOnEdge} und \code{getEdgesInRectangle} der beiden \code{GraphIndex}-Implementierungen (\code{Array}- und \code{Tree}-) getestet.}
     {die resultierenden Kantenmengen und die \code{PointOnEdge}s jeweils mit den erwarteten Werten übereinstimmen.}
     {bestanden}
\test{tileCacheCache}{TileCache}[Cache]
     {Es wird das Speichern von Kacheln im \code{TileCache} getestet.}
     {eine Kachel innerhalb von 100\,ms nach der ersten Anfrage im \code{TileCache} gespeichert wird.}
     {bestanden}
\test{tileCachePrefetch}{TileCache}[Prefetch]
     {Es wird das Prefetching (vorsorgliche Berechnung von benachbarten Kacheln, auch wenn diese noch nicht direkt angefragt wurden) des \code{TileCache} getestet.}
     {nach dem Anfragen einer Kachel innerhalb von 100\,ms benachbarte Kacheln ebenfalls im \code{TileCache} gespeichert werden.}
     {bestanden}
\test{tileCacheCleanup}{TileCache}[Cleanup]
     {Es wird das Entfernen von Kacheln aus dem \code{TileCache} getestet.}
     {nach dem Anfragen von $50^2$ anderen Kacheln die älteste gespeicherte Kachel aus dem \code{TileCache} entfernt wird.}
     {bestanden}
\test{arcflags}{ArcFlags}
     {Es wird die Speicher- und Lade-Funktion der Arc-Flags getestet.}
     {nach dem Speichern und anschließenden Laden die gleichen Arc-Flags gesetzt sind wie davor.}
     {bestanden}
\test{routeModel}{RouteModel}
     {Es wird das Beobachtermuster der \code{RouteModel}-Klasse getestet.}
     {die von einem \code{TestListener} gemessene Anzahl an ausgelösten Ereignissen an allen Stellen mit der erwarteten Anzahl übereinstimmt.}
     {bestanden}
\test{weights}{Weights}
     {Es wird die Speicher- und Lade-Funktion der Kantengewichte getestet.}
     {nach dem Speichern und anschließenden Laden die gleichen Kantengewichte gesetzt sind wie davor.}
     {bestanden}
\test{mapEdge}{MapEdge}
     {Es wird die \code{MapEdge}-Klasse getestet, die vom OSM-Parser verwendet wird.}
     {das Setzen der ID korrekt funktioniert und die Getter die richtigen Werte zurückgeben.}
     {bestanden}
\test{osmParser}{OSMParser}
     {Es wird die Verarbeitung verschiedener Karteneigenschaften (verschiedene Abbiegetypen, Einbahnstraßen, Ampeln, Kreisverkehre, \dots) sowie das Erkennen von fehlerhaften Eingabedaten (Eigenschaften ohne Name, Eigenschaften ohne Wert, fehlende Koordinaten, ungültige Koordinaten, \dots) durch den OSM-Parser getestet.}
     {alle gültigen Strukturen korrekt in den Graph übernommen werden und ungültige Daten vom Parser erkannt werden und der Import dann mit einer Ausnahme abgebrochen wird.}
     {bestanden}
\test{osmWay}{OSMWay}
     {Es wird die Verarbeitung verschiedener OSM-Tags (Straßentyp, Kreisverkehr, \dots) durch die \code{OSMWay}-Klasse getestet.}
     {alle OSM-Tags auf die richtigen Strukturen im Graph abgebildet werden.}
     {bestanden}
\test{profileMapComb}{ProfileMapCombination}
     {Es wird die Speicher- und Lade-Funktion von \code{Pro\-file\-Map\-Com\-bi\-na\-tion} getestet.}
     {die \code{ProfileMapCombination} nach dem Speichern und anschließenden Laden das gleiche Profil und die gleiche \code{StreetMap} sowie, falls vorhanden, die gleiche abgeschlossene Vorberechnung (Kantengewichte, Arc-Flags, benötigte Zeit) enthält wie davor.}
     {bestanden}
\test{turnRestriction}{TurnRestriction}
     {Es wird die Funktionalität von Abbiegebeschränkungen getestet.}
     {eine Abbiegebeschränkung ihre Start- und Zielkante korrekt zurückgibt und \code{allowsTurn} korrekt entscheidet, ob ein Abbiegevorgang auf eine bestimmte Kante erlaubt ist oder nicht.}
     {bestanden}
\test{profile}{Profile}
     {Es werden \code{equals} und \code{clone} sowie die Setter, Getter und die Speicher- und Lade-Funktion der Profile getestet.}
     {\code{equals} und \code{clone} erwartungsgemäß funktionieren, die Setter die verschiedenen Werte (Fahrzeugtyp, Höhe, Breite, \dots) korrekt setzen, die Werte von Standardprofilen jedoch nicht verändern, die Getter die korrekten Werte zurückgeben und das Profil nach dem Speichern und anschließenden Laden die gleichen Werte enthält wie davor.}
     {bestanden}
\test{fibHeap}{FibonacciHeap}
     {Es werden die verschiedenen Operationen (Einfügen/Entfernen von Elementen, Ändern der Priorität) des Fibonacci-Heaps getestet.}
     {die \code{deleteMin}-Methode nach dem Hinzufügen/Entfernen von Elementen und Ändern von Prioritäten immer korrekt das Element mit der niedrigsten Priorität zurückgibt.}
     {bestanden}
\test{coords}{Coordinates}
     {Es werden die Methoden \code{distanceTo}, \code{angleBetween} sowie \code{toString}/\code{toSMT} und \code{fromString}/\code{fromSMT} getestet.}
     {\code{distanceTo} und \code{angleBetween} die erwarteten Werte zurückgeben und eine Transformation und Rücktransformation mit den Konvertierungsmethoden die Testkoordinaten unverändert lässt.}
     {bestanden}
\test{pointOnEdge}{PointOnEdge}
     {Es werden der Konstruktor sowie die Getter von \code{PointOnEdge} getestet.}
     {der Konstruktor nur positive Kanten-IDs sowie Positionen zwischen 0 und 1 annimmt und die Getter die korrekten Werte zurückgeben.}
     {bestanden}
\test{fileUtil}{FileUtil}
     {Es werden \code{checkMapName} und \code{checkProfileName} getestet.}
     {\code{checkMapName}/\code{checkProfileName} zulässige \mbox{Karten-/}\hspace{0pt}Profilnamen akzeptiert und unzulässige ablehnt.}
     {bestanden}
\end{itemize}

\section{Protokoll des GUI-Tests}
\subsection{Automatisierter Test}
Alle Testfälle mit kleineren Nummern wurden im Pflichtenheft beschrieben.
Bei allen hier beschriebenen Testfällen gilt als Vorbedingung, dass \routeKIT gestartet ist.
\begin{description}
\newcounter{oitemTF}
\setcounter{oitemTF}{400}
\oitem{TF}{aboutviewopen} Über-Fenster öffnen
\testfall
    {Alle Fenster außer dem Hauptfenster sind geschlossen.}
    {„routeKIT/Über\dots“ in der Menüleiste wird ausgewählt.}
    {Das Fenster mit den Informationen über das Programm erscheint.}
\oitem{TF}{aboutviewclose} Über-Fenster schließen
\testfall
    {Das Über-Fenster ist geöffnet.}
    {Die Tastenkombination \textit{Alt}\,+\,\textit{F4} drücken.}
    {Das Über-Fenster wird geschlossen.}
\oitem{TF}{swap} Koordinaten vertauschen
\testfall
    {Das Start- und das Zielfeld enthalten gültige Koordinaten.}
    {Der Start/Ziel-Tauschen-Button wird gedrückt.}
    {Die Eingaben von Start- und Zielfeld werden vertauscht und die Markierungen auf der Karte werden neu gesetzt. Die Route zwischen Start- und Zielpunkt wird berechnet.}
\oitem{TF}{falsecoordinates} Ungültige Koordinaten
\testfall
    {Das Profil ist für die aktuelle Karte vorberechnet.}
    {Ins Start- oder Zielfeld wird eine ungültige Koordinate eingegeben.}
    {Das Feld färbt sich rot. Es wird keine Routenberechnung durchgeführt.}
\oitem{TF}{waydescription} Wegbeschreibung
\testfall
    {Das Start- oder das Zielfeld enthält eine gültige Koordinate.}
    {Die fehlende gültige Koordinate wird eingegeben.}
    {Die Markierungen auf der Karte wird gesetzt. Die Route zwischen Start- und Zielpunkt wird berechnet. Die Wegbeschreibung wird in das Wegbeschreibungsfeld ausgegeben.}
\oitem{TF}{mapmanagerviewopen} Kartenverwaltung-Fenster öffnen
\testfall
    {Alle Fenster außer dem Hauptfenster sind geschlossen.}
    {Der Karte-Button wird gedrückt.}
    {Das Fenster der Kartenverwaltung erscheint.}
\oitem{TF}{profilemanagerviewopen} Profilverwaltung-Fenster öffnen
\testfall
    {Alle Fenster außer dem Hauptfenster sind geschlossen.}
    {Der Profil-Button wird gedrückt.}
    {Das Fenster der Profilverwaltung erscheint.}
\oitem{TF}{oneway} Einbahnstraße benutzen
\testfall
    {Karte ist sichtbar, Profil ist vorberechnet (für die aktuelle Karte), Karte enthält eine Einbahnstraße.}
    {Als Start- und Zielpunkt werden Punkte auf der Einbahnstraße gewählt. Dabei ist Ziel weiter in Einbahnstraßenrichtung als Start. }
    {Eine Route, die den Einbahnstraßenabschnitt enthält, wird gefunden.}
\oitem{TF}{addprofile} Profil hinzufügen
\testfall
    {Die Kartenverwaltung ist offen.}
    {Der Hinzufügen-Button wird gedrückt. Ein Profil wird ausgewählt und die Wahl wird drei mal bestätigt.}
    {Die Kartenverwaltung wird geschlossen. Das Profil wird für die Karte vorberechnet.}
\oitem{TF}{historyopen} Verlauf-Fenster öffnen
\testfall
    {Alle Fenster außer dem Hauptfenster sind geschlossen.}
    {Der Verlauf-Button wird gedrückt.}
    {Das Verlauf-Fenster wird geöffnet.}
\oitem{TF}{removeprofileinmap} Vorberechnung für Profil entfernen
\testfall
    {Profil ist für die Karte vorberechnet. Kartenverwaltung ist offen.}
    {Ein Profil wird ausgewählt. Der Entfernen-Button wird gedrückt.}
    {Die Vorberechnung von dem Profil wird gelöscht.}
\oitem{TF}{deactivatearcflgs} Keine \gls{arc} verwenden
\testfall
    {Das Profil ist für die Karte vorberechnet. Die \gls{arc} sind aktiviert.}
    {In der Menüleiste werden die \gls{arc} abgewählt.}
    {Es werden keine \gls{arc} bei der Routenberechnung verwendet.}
\oitem{TF}{activatearcflgs}  \gls{arc} verwenden
\testfall
    {Das Profil ist für die Karte vorberechnet. Die \gls{arc} sind deaktiviert.}
    {In der Menüleiste werden die \gls{arc} gewählt.}
    {Es werden \gls{arc} bei der Routenberechnung verwendet.}
\end{description}

\newpage

Startbedingung: Eine Internetverbindung ist hergestellt. Die aktuelle Konfiguration (auch alle Profile und Karten) ist gelöscht.
Bei allen Tests außer sich selbst erfüllt „Start“ eine Vorbedingung.
\begin{longtable}{||c|c|c|c|c||}
ID& Testname & Testnummer & bestanden & Vorbedingungen\\ 
 & & & & erfüllt in\\ \hline\hline
\endfirsthead
\rowno[start] & Start\footnote{Die Konfiguration wird neu vom Server heruntergeladen. Damit wird gesichert, dass der Test mit der Karte „Regierungsbezirk Karlsruhe“ und dem dafür vorberechneten Standardprofil „PKW (Standard)“ gestartet wird, eigene Kacheln verwendet werden und die \gls{arc} aktiviert sind.} &/TF30/ & \checkmark &  \footnote{Neustart der Anwendung} \\ \hline
\rowno[aboutopen] & Öffnung des Über-Fenster & \ref{TF:aboutviewopen}& \checkmark & \footnotemark[2] \\ \hline
\rowno[aboutclose] & Schließen des Über-Fenster & \ref{TF:aboutviewclose}& \checkmark & \ref{aboutopen} \\ \hline
\rowno[coordinates] & Eingabe der Koordinaten & /TF150/ & \checkmark &  \\ \hline
\rowno[firstpoint] & Auswahl des ersten Punkts &  /TF80/ & \checkmark & \\
 & &/TF100/ & & \\ \hline
\rowno[secondpoint] & Auswahl des zweiten Punkts & /TF90/ & \checkmark &  \\ 
& &\ref{TF:waydescription} & & \\ \hline
\rowno[gpx] & GPX-Export & /TF70/ & \checkmark & \ref{secondpoint} \\ \hline
\rowno[html] & HTML-Export &/TF20/ & \checkmark & \ref{secondpoint} \\ \hline
\rowno[swap] & Vertauschen von Eingaben &\ref{TF:swap} & \checkmark & \ref{secondpoint} \\ \hline
\rowno[osm] & OSM-Kacheln & /TF200/ & \checkmark & \\ \hline
\rowno[selftile] & Eigene Kacheln & /TF210/ & \checkmark & \ref{osm} \\ \hline
\rowno[zoomin] & Reinzoomen & /TF120/ & \checkmark & \\ 
& & /TF220/ & & \\ \hline
\rowno[zoomout] & Rauszoomen &/TF130/ & \checkmark & \\
& & /TF220/ & & \\ \hline
\rowno[drag] & Karte ziehen &/TF110/ & \checkmark & \\ \hline
\rowno[noarcs] &  Deaktivierung der\gls{arc}& \ref{TF:deactivatearcflgs} & \checkmark & \\ \hline
\rowno[swapnoarc] & Vertauschen von Eingaben & \ref{TF:swap} & \checkmark & \ref{swap}\\ \hline
\rowno[arcs] & Aktivierung der \gls{arc} & \ref{TF:activatearcflgs} & \checkmark & \ref{noarcs} \\ \hline
\rowno[falsecoords] & Ungültige Koordinaten & \ref{TF:falsecoordinates}/ & \checkmark & \\ \hline
\rowno[mapmanageropen1] & Öffnung der Kartenverwaltung & \ref{TF:mapmanagerviewopen} & \checkmark & \ref{aboutclose} \\ \hline
\rowno[correctmapimport] & Import einer Karte & /TF290/& \checkmark & \ref{mapmanageropen1} \\ 
& & /TF330/ & & \\ \hline
\rowno[precalc1] & Vorberechnung & /TF10/ & \checkmark & \ref{correctmapimport} \\ \hline
\rowno[profilemanageropen1] & Öffnung der Profilverwaltung & \ref{TF:profilemanagerviewopen} & \checkmark & \ref{correctmapimport}  (schließen) \\ \hline
\rowno[selectprofile] & Auswahl eines Profils & /TF240/ & \checkmark & \\ \hline
\rowno[precalc2] & Vorberechnung & /TF10/ & \checkmark & \ref{selectprofile} (schließen) \\ \hline
\rowno[oneway] & Einbahnstraße in Fahrtrichtung & \ref{TF:oneway}& \checkmark & \ref{precalc2}\\ \hline
&  &\ref{TF:swap}& &  \\ 
\rowno[swaponeway]& Einbahnstraße gegen die Fahrtrichtung & /TF350/ & \checkmark & \ref{oneway} \\
& &  /TF340/ & & \\ \hline
\rowno[profilemanageropen2] & Öffnung der Profilverwaltung &\ref{TF:profilemanagerviewopen} & \checkmark & \ref{correctmapimport}  (schließen) \\ \hline
\rowno[neuprofile] & Neues Profil& /TF230/ & \checkmark & \\ \hline
\rowno[mapmanageropen2] & Öffnung der Kartenverwaltung &\ref{TF:mapmanagerviewopen} & \checkmark & \ref{neuprofile} (schließen) \\ \hline
\rowno[addprofileformap] & Hinzufügen von Profil zur Karte & \ref{TF:addprofile} & \checkmark & \ref{mapmanageropen2} \\ \hline
\rowno[historyopen] & Öffnung des Verlaufs & \ref{TF:historyopen} & \checkmark & \ref{addprofileformap} (schließen)\\ \hline
\rowno[loadfromhistory] & Laden aus Verlauf & /TF50/ & \checkmark & \ref{swaponeway} \\ \hline
\rowno[mapmanageropen3] & Öffnung der Kartenverwaltung &\ref{TF:mapmanagerviewopen} & \checkmark & \ref{loadfromhistory}  (schließen) \\ \hline
\rowno[removeprofilefrommap] & Entfernung einer Vorberechnung für Profil & \ref{TF:removeprofileinmap} & \checkmark & \ref{mapmanageropen3} und \ref{precalc2}\\ \hline
\rowno[deleteprofile] & Entfernung eines Profils & /TF250/ & \checkmark & \ref{neuprofile} \\ \hline
\rowno[deletemap] & Entfernung einer Karte & /TF310/ & \checkmark & \ref{correctmapimport} \\ \hline
\end{longtable}

\subsection{Manuelle Tests}
Die Tests /TF40/, /TF60/, /TF140/, /TF160/, /TF170/, /TF 180/, /TF190/, /TF260/, /TF270/, /TF280/, /TF300/, /TF320/ aus dem Pflichtenheft wurden manuell auf dem Commit \code{3c2b61df374375029a4fe853dce074f05488f9b6} am 7.\,03.\,2014 ausgeführt und wurden bestanden.\\
Die folgenden Tests wurden auf dem Commit \code{680d84bff40fce53b8126ed23e148572ca364474} am 7.\,03.\,2014 für die Karte „Regierungsbezirk Karlsruhe“ ausgeführt.
\begin{longtable}{||c|c|c|c|c||}
Testnummer & bestanden & Startkoordinate & Begründung\\ 
 & & Zielkoordinate & \\ \hline \hline
\endfirsthead
/TF360/ & \checkmark & 49.007614 8.394907 & links abbiegen verboten\\ 
 & & 49.00796 8.394949 & \\ \hline
/TF370/ & \checkmark & 49.00889 8.395014 & Beschränkung nach Höhe (3,5\,m), \\
 & & 49.00988 8.3951645 & Profil LKW (Standard) \\ \hline
/TF380/ & \checkmark & 49.00889 8.395014 & Beschränkung nach Höhe (3,5\,m), \\ 
 & & 49.00988 8.3951645 &  Profil PKW (Standard)\\ \hline
/TF390/ & \checkmark & 48.964893 8.613882 & LKW-Verbot, \\ 
 & & 48.965534 8.613367 & Profil LKW (Standard) \\ \hline
/TF390/ & \checkmark & 49.43081 8.691645 & Bus-Verbot, \\ 
 & & 49.430744 8.692374 & erstelltes Profil Bus \\ \hline
/TF390/ & \checkmark & 49.392246 8.783075 & Motorrad-Verbot, \\ 
 & & 49.392353 8.784149 & erstelltes Profil Motorrad \\ \hline
/TF400/ & \checkmark & 48.964893 8.613882 & LKW-Verbot, \\ 
 & & 48.965534 8.613367 & Profil PKW (Standard) \\ \hline
\end{longtable}
Somit wurden alle Test aus dem Pflichtenheft (von /TF10/ bis /TF400/) durchgeführt und bestanden.

\section{Testüberdeckung}
Die Abdeckung des Quellcodes im "src"-Ordner (also ohne Testfälle) während dem Commit \code{6d239a2ab7402c7a469b48299c42e8d56f547884} ist:\\
\begin{longtable}{||c|c|c|c||}
Testteil & Instruction Coverage & Line coverage & Branch coverage\\ \hline\hline
RobotUI & 78.1\%&79.8\%&56.9\%\\ \hline
Unit Tests & 51.3\%&51.1\%&44.9\%\\ \hline \hline
Merged & 87.0\%&89.0\%&66.3\%\\ \hline
\end{longtable}

Eine Aufteilung der "Instruction Coverage" des vereinigten Durchlaufs in die einzelnen Teilpakete ist in Abbildung \ref{fig:overallCoverage} dargestellt.
\begin{figure}[h]
\includegraphics[scale=0.7]{overallCoverage}
\caption{Die Instruction Coverage des gesamten Testlaufs.}
\label{fig:overallCoverage}
\end{figure}

Die teilweise eher niedrige Abdeckung der anderen Klassen soll hier
durch einen Ausschnitt aus \code{ManagementActions} (Abbildung \ref{fig:errorCoverage}) erklärt werden.

\begin{figure}[h]
\includegraphics[scale=0.7]{errorCoverage}
\caption{Ein Codeausschnitt aus \code{ManagementActions} mit der Abdeckung des gesamten Testlaufs.}
\label{fig:errorCoverage}
\end{figure}

Man kann hier sehr deutlich sehen, dass die fehlende Abdeckung durch IO-Fehlerbehandlungscode verursacht wird. Da sehr viele Dateien in verschiedensten Situationen gespeichert und geladen werden müssen, haben wir keine Testfälle geschrieben, die explizit hier Dateien entfernen oder die Festplatte komplett füllen, sodass keine Datei mehr angelegt werden kann.

Diese Problematik wird an einer anderen Stelle, bei der Benutzung des Java-Konstrukts "try-with-Resouces" noch deutlicher, wie man in Abbildung \ref{fig:tryWithResources} erkennen kann.

\begin{figure}[H]
\includegraphics[scale=0.7]{tryWithResources}
\caption{Ein Codeausschnitt aus \code{ArcFlags} mit der Abdeckung des gesamten Testlaufs.}
\label{fig:tryWithResources}
\end{figure}

Man kann erkennen, dass die nicht überdeckten Anweisungen dieser 2 Methoden in den try-Blöcken liegen.
Es sind die Anweisungen, die dafür sorgen, dass die Ressourcen 
(\code{RandomAccessFile}, \code{FileChannel}, \code{FileInputStream}, \code{DataInputStream}) 
auch im Fehlerfall ordnungsgemäß geschlossen werden
(und auch, dass die anderen Ressourcen geschlossen werden,
wenn das Schließen einer anderen fehlschlägt).
So sind allein im sichtbaren Programmcode 96 Befehle, die nicht überdeckt sind.

\section{Änderungen seit der Implementierung}
Im Folgenden sind die gegenüber der Implementierung geänderten und neu hinzugefügten Klassen, Methoden und Attribute aufgeführt.

\begin{itemize}
\item \code{GraphIndex}
  \begin{itemize}
  \item Die Klasse \code{GraphIndex} wurde in ein Interface geändert und die bisherige Implementierung in die Klasse \code{TreeGraphIndex} verschoben.
  \item Eine weitere Implementierung von \code{GraphIndex}, \code{ArrayGraphIndex}, wurde geschrieben.
  Sie verwendet nur zwei \code{int}-Arrays und ist dadurch etwas schneller und lässt sich gut speichern/laden.
  \item \code{Graph} verwendet \code{ArrayGraphIndex}.
  \item \code{Graph} lädt \code{ArrayGraphIndex} von der Festplatte, statt sie neu aufzubauen, wenn die Dateien vorhanden sind. Dies beschleunigt den Start der Anwendung erheblich.
  \end{itemize}
\item\label{change:routeCalcKeineRoute} \ref{BG:routeCalcKeineRoute}
  \begin{itemize}
  \item \code{RouteModel} erhält die neuen Methoden \code{startCalculating}, um den Beginn einer Routenberechnung zu melden, und \code{isCalculating}, um abzufragen, ob aktuell eine Routenberechnung stattfindet.
  (Eine Routenberechnung endet implizit bei Aufruf von \code{setCurrentRoute}.)
  \end{itemize}
  \item \code{MainController}
    \begin{itemize}
    \item Die Klasse \code{MainController} enthält nun eine Methode \code{setUseArcFlags} zum Abschalten der \gls{arc} bei der Routenberechnung. Hierzu wird entweder eine Instanz von \code{ArcFlagsDijkstra} oder \code{Dijkstra} zur Routenberechnung verwendet.
    \end{itemize}
  \item \code{ArcFlagsDijkstra}
    \begin{itemize}
    \item Die Klasse \code{ArcFlagsDijkstra} erbt nun von der neuen Klasse \code{Dijkstra}, welche den normalen \gls{dijkstra} implementiert und ergänzt diese mit den \gls{arc}.
    \end{itemize}
\end{itemize}

\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
