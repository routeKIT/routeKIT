% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands

\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\newcommand{\keine}[0]{
%  % see http://tex.stackexchange.com/questions/61155/linespacing-without-packages
%  \setlength\lineskiplimit{-1000pt} % allow overflowing of lines
%  \linespread{0}\selectfont % don’t advance line after empty item
  \item[] keine.
}
% Argumente:
% 1. Name
% 2. Klassen (ein oder mehrere \class)
\newcommand{\package}[2]{
  \subsection{Paket #1}
  \begin{description}
    #2
  \end{description}
}
% Argumente:
% 1. Klassenname
% 2. Beschreibung
% 3. Attribute (ein oder mehrere \attr, oder \keine)
% 4. Methoden (ein oder mehrere \method, oder \keine)
\newcommand{\class}[4]{
  \item[\namedlabel{K:#1}{#1}] #2
    \begin{description}
    \newcommand{\currentclass}[0]{#1}
    \item[Attribute] \hfill % \hfill forces the following description into the next line
      \begin{description}
        #3
      \end{description}
    \item[Methoden] \hfill % \hfill forces the following description into the next line
      \begin{description}
        #4
      \end{description}
    \end{description}
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\attr}[3]{
  \item[\namedlabel{A:\currentclass.#1}{#1}] #3 Typ:~\texttt{#2}
}
% Argumente:
% 1. Name
% 2. (optional) Typ – default: void (wird nicht angezeigt)
% 3. Parameter (ein oder mehrere \param, oder \keine)
% 4. Beschreibung
\NewDocumentCommand{\method}{m o m +m}{ % the ‘+m’ means that parameter 4 can contain several paragraphs, see http://tex.stackexchange.com/questions/64328/blank-lines-break-xparse-or-ifthen-macro
  \item[\namedlabel{M:\currentclass.#1}{#1}] #4\\
    Parameter:
    \begin{description}
      \newcommand{\currentmethod}[0]{#1}
      #3
    \end{description}
    \IfValueTF{#2} % if the optional “type” argument is given...
              {Rückgabetyp: \texttt{#2}} % then show the return type...
              {} % else don’t.
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\param}[3]{
  \item[\namedlabel{P:\currentclass.\currentmethod.#1}{#1}] #3 Typ:~\texttt{#2}
}

% Argumente:
% 1. Klasse
% 2. (optional) Text – default: Klasse
\NewDocumentCommand{\refclass}{mO{#1}}{
  \hyperref[K:#1]{\texttt{#2}}
}
% Argumente:
% 1. Klasse
% 2. Attribut
% 3. (optional) Text – default: Klasse.Attribut
\NewDocumentCommand{\refattr}{mmO{#1.#2}}{
  \hyperref[A:#1.#2]{\texttt{#3}}
}
% Argumennte:
% 1. Klasse
% 2. Methode
% 3. (optional) Text – default: Klasse.Methode
\NewDocumentCommand{\refmethod}{mmO{#1.#2}}{
  \hyperref[M:#1.#2]{\texttt{#3}}
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. Parameter
% 4. (optional) Text – default: Klasse.Methode.Parameter
\NewDocumentCommand{\refparam}{mmmO{#1.#2.#3}}{
  \hyperref[P:#1.#2.#3]{\texttt{#4}}
}

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{
  \glsdoifexists{#2}{
    \def\@glsnumberformat{glsgobblenumber}
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}
    \setkeys{glossadd}{#1}
    \@gls@saveentrycounter
    \@do@wrglossary{#2}
  }
}
\newcommand{\glsaddallunused}[1][]{
  \edef\@glo@type{\@glo@types}
  \setkeys{glossadd}{#1}
  \forallglsentries[\@glo@type]{\@glo@entry}{
    \ifglsused{\@glo@entry}{}{
      \glsaddnp[#1]{\@glo@entry}}}
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

\makeatletter

\begin{document}
\shorthandoff{"}

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\textit{routeKIT} }


% alle Glossareinträge
\newacronym[longplural=Personenkraftwagen]{pkw}{PKW}{Personenkraftwagen}
\newacronym[longplural=Lastkraftwagen]{lkw}{LKW}{Lastkraftwagen}
\newacronym{osm}{OSM}{OpenStreetMap}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{gpx}{GPX}{GPS Exchange Format}

\newglossaryentry{profil}{
  name={Profil},
  description={enthält für die Routenplanung relevante Informationen, z.\,B. die Höhe und das Gewicht des Fahrzeugs},
  plural={Profile}
}
\newglossaryentry{osmkachel}{
  name={OSM-Kachel},
  description={die öffentlichen gerenderten \gls{osm}-Kacheln z.\,B. auf \mbox{\url{http://a.tile.openstreetmap.org/}}},
  plural={OSM-Kacheln}
}
\newglossaryentry{route}{
  name={Route},
  description={ein Weg von einem Start- zu einem Zielpunkt},
  plural={Routen}
}
\newglossaryentry{rendern}{
  name={rendern},
  description={Berechnung einer Bildkachel aus den zu rendernden Daten}
}
\newglossaryentry{wegbeschreibung}{
  name={Wegbeschreibung},
  description={Beschreibung einer \gls{route} durch eine Liste von Abbiegeanweisungen}
}
\newglossaryentry{dijkstra}{
  name={Dijkstra’s Algorithmus},
  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
}
\newglossaryentry{arc}{
 name={Arc-Flags},
 description={eine Technik, um eine Routenberechnung zu beschleunigen}
}
\newglossaryentry{verlauf}{
  name={Verlauf},
  description={speichert Routenanfragen für spätere Wiederverwendung. Es existiert nur ein Verlauf für die gesamte Anwendung.}
}
\newglossaryentry{mercator}{
  name={Mercator-Projektion},
  description={die Zylinderprojektion der Weltkugel}
}



\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Entwurf}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage

\section{Klassen}

\package{Profiles}{
  \class{Profile}
        {Ein \glslink{profil}{Fahrzeugprofil}.}
        {
          \attr{name}{String}{Der Name des Profils.}
          \attr{vehicleType}{VehicleType}{Der Fahrzeugtyp.}
          \attr{height}{int}{Die Höhe des Fahrzeugs, in Zentimetern.}
          \attr{width}{int}{Die Breite des Fahrzeugs, in Zentimetern.}
          \attr{weight}{int}{Das Gewicht des Fahrzeugs, in Kilogramm.}
          \attr{speedHighway}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Autobahn, in Kilometern pro Stunde.}
          \attr{speedRoad}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Landstraße, in Kilometern pro Stunde.}
        }
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die das Profil gespeichert wird.}
                 }
                 {Speichert das Profil in die angegebene Datei.}
          \method{load}[\refclass{Profile}]
                 {
                   \param{file}{File}{Die Datei, aus der das Profil geladen wird.}
                 } 
                 {Lädt ein Profil aus der angegebenen Datei und gibt es zurück.}
        }
}

\package{Map}{
  \class{StreetMap}
        {Eine Karte.}
        {
          \attr{name}{String}{Der Name der Karte.}
          \attr{graph}{\refclass{Graph}}{Der Graph der Karte, d.\,h. das Straßennetz.}
        }
        {\keine}
  \class{Graph}
        {
          Ein Kartengraph / Straßennetz. Beachte: Dieser Graph ist nicht das Ergebnis einer Vorberechnung für ein Profil und eine Karte, sondern nur für eine Karte.
          Siehe auch \refclass{GraphPreCalculation}.
        }
        {\keine}
        {
          \method{Graph}[Konstruktor]
                 {
                   \param{nodes}{int[]}{Der Knoten-Bestandteil des Adjazenzfeldes.}
                   \param{edges}{int[]}{Der Kanten-Bestandteil des Adjazenzfeldes.}
                   \param{nodeProps}{Map<int, \refclass{NodeProperties}>}
                         {
                           Die \code{NodeProperties} der Knoten des Graphen. Es wird eine \code{Map} anstelle eines Arrays verwendet, da die meisten Knoten keine besonderen Eigenschaften haben und daher das Array zum großen Teil leer wäre.
                         }
                   \param{edgeProps}{\refclass{EdgeProperties}{}[]} % use \refclass{EdgeProperties}{}[] instead of \refclass{EdgeProperties}[]: in the latter form, LaTeX thinks we’re passing an optional argument to \refclass
                         {
                           Die \code{EdgeProperties} der Kanten des Graphen. Hier wird ein Array verwendet, da jede Kante einen Namen und damit ein \code{EdgeProperties}-Objekt hat.
                         }
                   \param{lat}{float[]}{Die geographischen Breiten der Knoten des Graphen.}
                   \param{lon}{float[]}{Die geographischen Längen der Knoten des Graphen.}
                 }
                 {Erstellt ein neues Graph-Objekt aus dem gegebenen Adjazenzfeld.}
          \method{getEdges}[Set<int>]
                 {\param{node}{int}{Der Knoten, dessen Kanten gesucht werden.}}
                 {Gibt alle \emph{ausgehenden} Kanten des angegebenen Knotens zurück.}
          \method{getTargetNode}[int]
                 {\param{edge}{int}{Die Kante, dessen Zielknoten gesucht wird.}}
                 {Gibt den Zielknoten der angegebenen Kante zurück.}
          \method{getLat}[float]
                 {\param{node}{int}{Der Knoten, dessen geographische Breite gesucht wird.}}
                 {Gibt die geographische Breite des angegebenen Knotens zurück.}
          \method{getLon}[float]
                 {\param{node}{int}{Der Knoten, dessen geographische Länge gesucht wird.}}
                 {Gibt die geographische Länge des angegebenen Knotens zurück.}
          \method{getNodeProperties}[\refclass{NodeProperties}]
                 {\param{node}{int}{Der Knoten, dessen \refclass{NodeProperties} gesucht werden.}}
                 {Gibt die \code{NodeProperties} des angegebenen Knotens zurück.}
          \method{getEdgeProperties}[\refclass{EdgeProperties}]
                 {\param{edge}{int}{Die Kante, deren \refclass{EdgeProperties} gesucht werden.}}
                 {Gibt die \code{EdgeProperties} de angegebenen Kante zurück.}
        }
  \class{NodeProperties}
        {Kapselt die Eigenschaften eines Knotens einschließlich der zugehörigen Abbiegebeschränkungen.}
        {\keine}
        {
          \method{allowsTurn}[boolean]
                 {
                   \param{fromEdge}{int}{Die eingehende Kante, über die der Knoten betreten wird.}
                   \param{toEdge}{int}{Die ausgehende Kante, über die der Knoten verlassen wird.}
                   \param{profile}{\refclass{Profile}}{Das \gls{profil}, für das die Zulässigkeit des Abbiegevorgangs bestimmt werden soll.}
                 }
                 {
                   Bestimmt, ob ein Abbiegevorgang über den Knoten von der angegebenen eingehenden Kante zur angegebenen ausgehenden Kante zulässig ist.

                   Wenn der Knoten nicht Endknoten von \refparam{NodeProperties}{allowsTurn}{fromEdge}[fromEdge] oder nicht Startknoten von \refparam{NodeProperties}{allowsTurn}{toEdge}[toEdge] ist, wird \code{false} zurückgegeben.
                 }
          \method{isMiniRoundabout}[boolean]
                 {\keine}
                 {Bestimmt, ob der Knoten ein kleiner Kreisverkehr ist.}
          \method{isHighwayJunction}[boolean]
                 {\keine}
                 {Bestimmt, ob der Knoten eine Schnellstraßen- oder Autobahnanschlussstelle ist.}
          \method{getJunctionName}[String]
                 {\keine}
                 {Gibt den Namen der Anschlussstelle zurück oder \code{null}, falls es sich nicht um eine Anschlussstelle handelt.}
          \method{getJunctionRef}[String]
                 {\keine}
                 {Gibt die Nummer der Anschlussstelle zurück oder \code{null}, falls es sich nicht um eine Anschlussstelle handelt.}
        }
  \class{EdgeProperties}
        {Kapselt die Eigenschaften einer Kante.}
        {\keine}
        {
          \method{getName}[String]
                 {\keine}
                 {Gibt den Namen der Straße zurück oder \code{null}, falls nicht vorhanden.}
          \method{getRoadRef}[String]
                 {\keine}
                 {Gibt die Nummer der Straße zurück oder \code{null}, falls nicht vorhanden.}
          \method{allowsRoute}[boolean]
                 {\param{profile}{\refclass{Profile}}{Das Profil, für das die Zulässigkeit der Benutzung bestimmt werden soll.}}
                 {Bestimmt, ob die Benutzung der Kante in einer \gls{route} zulässig ist.}
          \method{getMaxSpeed}[int]
                 {\param{profile}{\refclass{Profile}}{Das Profil, für das die Höchstgeschwindigkeit auf dieser Kante bestimmt werden soll.}}
                 {Bestimmt die zulässige Höchstgeschwindigkeit auf dieser Kante für das angegebene Profil.}
          \method{isRoundabout}[boolean]
                 {\keine}
                 {Bestimmt, ob die Kante Teil eines Kreisverkehrs ist.}
        }
}

\package{TODO}{ % TODO: holds classes that still need a package
  \class{ProfileMapCombination}
        {Eine Kombination aus einem \refclass{Profile}[Profil] und einer \refclass{StreetMap}[Karte]. Siehe auch \refclass{GraphPreCalculation}.}
        {
          \attr{profile}{\refclass{Profile}}{Das \gls{profil}.}
          \attr{map}{\refclass{StreetMap}}{Die Karte.}
        }
        {\keine}

   \class{Util}
        {Enthält oft verwendete Methoden, die von anderen Teilen des Programms unabhängig sind.}
        {\keine}
        {
          \method{projectToEdge} [\refclass{PointOnEdge}]
                 {
                   \param{lon}{float}{Die geographische Länge von einem Punkt.}
                   \param{lat}{float}{Die geographische Breite von einem Punkt.}
                 }
                 {Sucht zu gegebenen Koordinaten den nähesten Punkt auf einer Kante.}

           \method{unmercatorX}[float]
                 {
                   \param{x}{float}{Koordinate der Mercator-Projektion}
                   \param{zoom}{int}{Die Zoomstufe der Karte}
                 }
                 {Berechnet die geographische Breite.}

          \method{unmercatorY}[float]
                 {
                   \param{y}{float}{Koordinate der Mercator-Projektion}
                   \param{zoom}{int}{Die Zoomstufe der Karte}
                 }
                 {Berechnet die geographische Länge.}

          \method{distance}[float]
                 {
                   \param{a}{Coordinates}{Koordinaten des ersten Punktes}
                   \param{b}{Coordinates}{Koordinaten des zweiten Punktes}
                 }
                 {Berechnet die Länge der Luftlinie zwischen zwei Punkten.}

          \method{mercatorLat}[float]
                 {
                   \param{lat}{float}{die geographische Breite}
                   \param{zoom}{int}{Die Zoomstufe der Karte}
                 }
                 {Berechnet eine Koordinate der Mercator-Projektion.}

          \method{mercatorLon}[float]
                 {
                   \param{lon}{float}{die geographische Länge}
                   \param{zoom}{int}{Die Zoomstufe der Karte}
                 }
                 {Berechnet eine Koordinate der Mercator-Projektion.}
         }
  \class{PointOnEdge}
        {Beschreibt einen Punkt auf der Kante.}
        {
             \attr{edgeid}{int}{Die eindeutige Id einer Kante.}
             \attr{pointPosition}{float}{Eine Zahl zwischen 0 und 1, die den Anteil der Strecke vom Punkt zum Ausgangsknoten von der Gesamtlänge der Kante angibt.}
         }
        {\keine}
}

\package{RouteCalculator}{
  \class{GraphPreCalculation}
        {Kapselt ein Profil, eine Karte, und die Ergebnisse einer Vorberechnung für diese Profil-Karte-Kombination.}
        {\keine}
        {
          \method{calculateRoute}
                 {
                   \param{start}{\refclass{PointOnEdge}}{Der Startpunkt für die Routenberechnung.}
                   \param{destination}{\refclass{PointOnEdge}}{Der Zielpunkt für die Routenberechnung.}
                   \param{routeModel}{\refclass{RouteModel}}{Zur Verwaltung der aktuellen Route.}
                 }
                 {Ruft die Routenberechnung auf und speichert die erhaltene Route im gegebenen \refclass{RouteModel}.}
           \method{getEdgesIn}[Set<\refclass{Edge}>]
                  {
                    \param{fromX}{int}{Bereich beginnt bei der gegebenen X-Koordinate.}
                    \param{fromY}{int}{Bereich beginnt bei der gegebenen Y-Koordinate.}
                    \param{toX}{int}{Bereich endet bei der gegebenen X-Koordinate.}
                    \param{toY}{int}{Bereich endet bei der gegebenen Y-Koordinate.}
                    \param{zoomlevel}{int}{Die Zoom-Stufe.}
                  }
                  {Gibt alle Kanten im angegebenen Bereich abhängig von der Zoom-Stufe zurück.}
          \method{getNeighbours}[List<\refclass{Node}>]
                 {
                   \param{target}{int}{Die Nummer eines Knotens.}
                 }
                 {Gibt alle Nachbar-Knoten für einen gewählten Knoten zurück.}
        }
  \class{RouteCalculator}
        {Stellt ein Interface für einen Algorithmus zur Routenberechnung bereit.}
        {\keine}
        {
          \method{calculateRoute}[\refclass{Route}]
                 {
                   \param{start}{\refclass{PointOnEdge}}{Der Startpunkt für die Routenberechnung.}
                   \param{destination}{\refclass{PointOnEdge}}{Der Zielpunkt für die Routenberechnung.}
                   \param{data}{\refclass{GraphPreCalculation}}{Der vorberechnete Graph auf dem die Routenberechnung durchgeführt wird.}
                 }
                 {Berechnet einen Weg vom Startpunkt zum Zielpunkt auf dem gegebenen Graphen.}
        }
  \class{Route}
        {Repräsentiert eine berechnete \gls{route}.}
        {\keine} % ?
        {
          \method{getNodes}[int[]]
                 {\keine}
                 {Liefert eine Liste der Knoten, aus denen denen die Route besteht.}
          \method{getRouteDescription}[\refclass{RouteDescription}]
                 {\keine}
                 {Gibt die zur Route gehörende \gls{wegbeschreibung} zurück.}
        }
  \class{RouteDescription}
        {Kapselt die zu einer \refclass{Route} gehörende \gls{wegbeschreibung}.}
        {\keine} % ?
        {
          \keine % TODO
        }
  \class{TurnInstruction}
        {Kapselt eine einzelne Abbiegeanweisung, aus welchen eine \gls{wegbeschreibung} aufgebaut ist.}
        {\keine} % ?
        {\keine} % TODO
  \class{ArcFlags}
        {Enthält die Arc-Flags für den vorberechneten Graphen.}
        {\keine} % ?
        {
          \method{getFlags}[int]
                 {
                   \param{node}{int}{Die Nummer eines Knotens.}
                 }
                 {Gibt die zum Knoten gehörenden Arc-Flags zurück.}
        }
   \class{Dijkstra}
       {Führt die Berechnung der schnellsten Route zwischen Start- und Zielpunkt für die aktuelle Kombination aus Karte und Profil durch.}
       {\keine}
       {\keine} 
}

\package{History}{
  \class{History}
        {Kapselt den \gls{verlauf}.}
        {\keine}
        {
          \method{addEntry}
                 {
                   \param{start}{Coordinates}{Der Startpunkt.}
                   \param{destination}{Coordinates}{Der Zielpunkt.}
                 }
                 {Fügt einen Eintrag zum Verlauf hinzu. Als \refattr{HistoryEntry}{date} des neuen Eintrags wird die aktuelle Zeit verwendet.}
          \method{getEntries}[List<\refclass{HistoryEntry}>]
                 {\keine}
                 {Gibt alle Einträge des Verlaufs zurück.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die der Verlauf gespeichert wird.}
                 }
                 {Speichert den Verlauf in die angegebene Datei.}
          \method{load}[History]
                 {
                   \param{file}{File}{Die Datei, aus der der Verlauf geladen wird.}
                 }
                 {Lädt einen Verlauf aus der angegebenen Datei und gibt ihn zurück.}
        }
  \class{HistoryEntry}
        {Ein Eintrag im \gls{verlauf}.}
        {
          \attr{start}{Coordinates}{Der Startpunkt der Anfrage.}
          \attr{destination}{Coordinates}{Der Zielpunkt der Anfrage.}
          \attr{date}{Date}{Der Zeitpunkt der Anfrage.}
        }
        {\keine}
}

\package{MapDisplay}{
  \class{TileDequeue}
        {
          Verwaltet die Berechnung von Kartenkacheln.
          Karten können angefragt werden, und nachdem die (asynchrone) Berechnung abgeschlossen ist, werden registrierte \refclass{TileFinishedListener} benachrichtigt.
          Über das \code{Future}-Interface können Berechnungen auch abgebrochen werden.
        }
        {\keine}
        {
          \method{requestTile}[Future<BufferedImage>]
                 {
                   \param{x}{int}{Die x-Koordinate der angeforderten Kachel.} % TODO skaliert mit dem Zoom? relativ zu was?
                   \param{y}{int}{Die y-Koordinate der angeforderten Kachel.}
                   \param{zoom}{int}{Die Zoomstufe der angeforderten Kachel, zwischen 0 (eine Kachel für die ganze Welt) und 19 (Maßstab 1:1000).}
                 }
                 {
                   Beantragt die asynchrone Berechnung der angegebenen Kachel.
                   Über das zurückgegeben \code{Future}-Object kann die Berechnung abgebrochen werden; zu beachten ist aber, dass die \code{get}-Methode des Objekts niemals \code{null} zurückgeben wird, sondern für noch nicht berechnete Kacheln stattdessen eine „Platzhalter-Kachel“.
                 }
          \method{addTileFinishedListener}
                 {\param{listener}{\refclass{TileFinishedListener}}{Der Listener, der hinzugefügt werden soll.}}
                 {
                   Registriert einen \refclass{TileFinishedListener}, der benachrichtigt wird, wenn eine Kachel fertig berechnet ist.
                   Die Kachel ist Teil der Nachricht, kann aber auch jederzeit über das von \refmethod{TileDequeue}{requestTile}[requestTile] zurückgegebene \code{Future}-Object abgefragt werden.
                 }
        }
  \class{TileFinishedListener} % TODO \class? \interface?
        {Wird benachrichtigt, wenn die Berechnung einer Kartenkachel abgeschlossen ist.}
        {\keine}
        {
          \method{tileFinished}
                 {
                   \param{x}{int}{siehe \refparam{TileDequeue}{requestTile}{x}}
                   \param{y}{int}{siehe \refparam{TileDequeue}{requestTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileDequeue}{requestTile}{zoom}}
                   \param{tile}{BufferedImage}{Die berechnete Kachel.}
                 }
                 {
                   Wird vom \refclass{TileDequeue} aufgerufen, wenn die Berechnung einer Kachel abgeschlossen ist.
                   Die übliche Aktion ist, ein \code{repaint} der Kartenansicht im \gls{gui} auszulösen.
                 }
        }
  \class{TileSource}
        {Abstrakte Klasse, die ein Interface für das (synchrone) \Gls{rendern} von Kartenkacheln definiert.}
        {\keine}
        {
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileDequeue}{requestTile}{x}}
                   \param{y}{int}{siehe \refparam{TileDequeue}{requestTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileDequeue}{requestTile}{zoom}}
                 }
                 {Berechnet die angegebene Kachel und gibt sie zurück.}
        }
  \class{TileCache}
        {Ein Zwischenspeicher für Kacheln, um zu verhindern, dass sie ständig von neuem berechnet werden.}
        {\keine}
        {
          \method{TileCache}[Konstruktor]
                 {\param{target}{\refclass{TileSource}}{Die \code{TileSource}, die die tatsächliche Berechnung durchführt und deren Ergebnisse zwischengespeichert werden.}}
                 {Erstellt einen neuen Cache für die angegebene \refclass{TileSource}.}
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileDequeue}{requestTile}{x}}
                   \param{y}{int}{siehe \refparam{TileDequeue}{requestTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileDequeue}{requestTile}{zoom}}
                 }
                 {
                   Ist die angeforderte Kachel bereits im Zwischenspeicher vorhanden, so wird sie direkt zurückgegeben;
                   andernfalls wird sie von \refparam{TileCache}{TileCache}{target}[target] angefordert, im Zwischenspeicher gespeichert und dann zurückgegeben.
                 }
          \method{deleteTiles}
                 {\param{zoom}{int}{Die Zoomstufe, für die Kacheln gelöscht werden sollen; siehe \refparam{TileDequeue}{requestTile}{zoom}.}}
                 {Veranlasst, dass alle zwischengespeicherten Kacheln der angegebenen Zoomstufe aus dem Zwischenspeicher gelöscht werden, etwa, um Speicher zu sparen.}
        }
  \class{TileRenderer}
        {Eine \refclass{TileSource}, die die Kacheln selbst berechnet.}
        {\keine}
        {
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileDequeue}{requestTile}{x}}
                   \param{y}{int}{siehe \refparam{TileDequeue}{requestTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileDequeue}{requestTile}{zoom}}
                 }
                 {Berechnet die angegebene Kachel und gibt sie zurück.}
        }
  \class{OSMRenderer}
        {Eine \refclass{TileSource}, die die \glspl{osmkachel} vom OpenStreetMap-Server herunterlädt.}
        {\keine}
        {
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileDequeue}{requestTile}{x}}
                   \param{y}{int}{siehe \refparam{TileDequeue}{requestTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileDequeue}{requestTile}{zoom}}
                 }
                 {Lädt die angegebene Kachel herunter und gibt sie zurück.}
        }
}

\package{View}{
  \class{MapView}
        {Zeigt einen Kartenausschnitt auf dem Bildschirm an.}
        {\keine}
        {
          \method{MapView}
                 {
                   \param{s}{\refclass{TileSource}}{eine gerenderte Kachel}
                 }
                 {Ein Konstruktor, der ein Objekt der Klasse \refclass{MapView} erzeugt.}
          \method{paint}
                 {
                   \param{graphics}{Graphics}{ein Objekt vom}
                 }
                 {Zeichnet einen Kartenausschnitt, indem fertige Kacheln richtig platziert werden.}
        }

   \class{MainView}
        {Zeigt das Hauptfenster auf dem Bildschirm an.}
        {\keine}
        {\keine}

   \class{MapManagerView}
        {Zeigt das Fenster der Kartenverwaltung auf dem Bildschirm an.}
        {\keine}
        {\keine}

   \class{ProfileManagerView}
        {Zeigt das Fenster der Profilverwaltung auf dem Bildschirm an.}
        {\keine}
        {\keine}

  \class{HistoryView}
        {Zeigt das Fenster mit dem Verlauf auf dem Bildschirm an.}
        {\keine}
        {\keine}

  \class{AboutView}
        {Zeigt das Fenster mit den Informationen über routeKIT auf dem Bildschirm an.}
        {\keine}
        {\keine}
}
\package{Precalculation}{
  \class{PreCalculationScheduler}
        {Veranlasst die Vorberechnung für Kombinationen aus \refclass{Profile}[Profil] und \refclass{StreetMap}[Karte].}
        {\attr{calculationQueue}{Queue}{Die Queue, in der geplante Vorberechnungen stehen. Sie wird nacheinander abgearbeitet.}}
        {
          \method{scheduleCalculation}
                 {
                   \param{comb}{ProfileMapCombination}{Die Kombination aus \refclass{Profile}[Profil] und \refclass{StreetMap}[Karte], für die die Vorberechnung durchgeführt werden soll.}
                 }
                 {Fügt die \refclass{ProfileMapCombination}[ProfileMapCombination] zur späteren Vorberechnung zur Queue hinzu.}
        }
                        
  \class{PreCalculator}
        {Führt die Vorberechnung für eine Kombination aus \refclass{Profile}[Profil] und \refclass{StreetMap}[Karte] durch.}
        {\keine}
        {
          \method{doPrecalculation}
                 {
                   \param{comb}{ProfileMapCombination}{Die Kombination aus \refclass{Profile}[Profil] und \refclass{StreetMap}[Karte], für die die Vorberechnung durchgeführt werden soll.}
                 }
                 {
                   Führt die Vorberechnung für die gegebene Kombination aus \refclass{Profile}[Profil] und \refclass{StreetMap}[Karte] durch.
                   Dabei werden ein \refclass{EdgeWeighter}[EdgeWeighter] und ein \refclass{ArcFlagsCalculator}[ArcFlagsCalculator] aufgerufen.
                 }
        }
  \class{MapImporter}
        {Liest eine OSM-Karte aus dem Dateisystem in ein \refclass{Graph}-Objekt}
        {\keine}
        {
          \method{import}[Graph]
                 {
                   \param{f}{File}{Die Datei aus der die OSM-Daten importiert werden sollen.}
                 }
                 {Importiert und säubert den Straßengraph.}
        }
  \class{OSMParser}
        {Importiert eine neue Karte.}
        {\keine}
        {
          \method{parseOSM}[Graph]
                 {
                   \param{f}{File}{}
                 }
                 {Wandelt eine OSM-Karte in eine verlinkte Datenstruktur \refclass{MapNode} um.}
        }
  \class{MapNode}
        {Stellt eine Kreuzung im Straßennetz dar. Diese verknüpfte Darstellung ist nur eine Zwischendarstellung um die OSM-Daten gut einlesen zu können}
        {\keine}
        {
          \method{getLon}[float]
                 {\keine}
                 {Gibt den Längengrad dieses Knotens aus.}
          \method{getLat}[float]
                 {\keine}
                 {Gibt den Breitengrad dieses Knotens aus.}
          \method{getEdges}[Set<MapEdge>]
                 {\keine}
                 {Gibt eine Liste mit allen Kanten zu einem Knoten zurück.}
        }
        
  \class{EdgeWeighter}
        {Versieht die Kanten eines Graphen mit Kantengewichten.}
        {\keine}
        {
          \method{weightEdges}[float[]]
                 {
                   \param{graph}{Graph}{Der zu gewichtende Graph.}
                   \param{profile}{Profile}{Das zu verwendende Profil.}
                 }
                 {Versieht die Kanten des gegebenen Graphen mit Kantengewichten basierend auf durch das Profil beeinflussten Beschränkungen.}
        }
        
  \class{ArcFlagsCalculator}
        {Berechnet Arc-Flags für einen partitionierten, gewichteten Graphen.}
        {\keine}
        {
          \method{calculateArcFlags}[ArcFlags]
                 {
                   \param{graph}{Graph}{Der Graph.}
                   \param{partitions}{int[]}{Die Partitionen des Graphen.}
                   \param{weights}{float[]}{Die Kantengewichte des Graphen.}
                 }
                 {Berechnet Arc-Flags für den gegebenen Graphen mit den gegebenen Partitionen und Kantengewichten.}
        }
        
  \class{GraphPartitioner}
        {Partitioniert einen gegebenen Graphen.}
        {\keine}
        {
          \method{partitionGraph}[int[]]
                 {
                   \param{graph}{Graph}{Der zu partitionierende Graph.}
                   \param{numberOfPartitions}{int}{Die gewünschte Anzahl an Partitionen.}
                 }
                 {Teilt den Graphen in die gewünschte Anzahl an Partitionen.}
        }
        
  \class{ExternalPartitionerAdapter}
        {Leitet die Partitionierungsanfrage an ein externes Partitionierungsprogramm weiter.}
        {\keine}
        {
          \method{partitionGraph}[int[]]
                 {
                   \param{graph}{Graph}{Der zu partitionierende Graph.}
                   \param{numberOfPartitions}{int}{Die gewünschte Anzahl an Partitionen.}
                 }
                 {Lässt den Graphen durch das externe Programm in die gewünschte Anzahl an Partitionen teilen.}
        }
}

\package{Controllers}{
  \class{ProfileManager}
        {Verwaltet die Profile. Hat intern eine Liste von vorhandenen Profilen.} % TODO Liste oder Menge? vgl getProfiles - Lucas
        {\keine}
        {
          \method{saveProfile}
                 {
                   \param{p}{\refclass{Profile}}{Das Profil, das gespeichert werden soll.}
                 }
                 {
                   Speichert das ausgewählte Profil in der internen Liste und auf der Festplatte.
                   
                   (Der Speicherort wird vom Manager deckend verwaltet.) % „deckend“ = “opaque”
                 }
          \method{deleteProfile}
                 {
                   \param{p}{\refclass{Profile}}{Das Profil, das gelöscht werden soll.}
                 }
                 {
                   Löscht das ausgewählte Profil aus der internen Liste und von der Festplatte.
                 }
          \method{getProfiles}[Set<\refclass{Profile}>]
                 {\keine}
                 {
                   Gibt alle Profile in der internen Liste zurück.
                 }
        }
  \class{MapManager}
        {Verwaltet die Kartendaten. Hat intern eine Liste von vorhandenen Kartendaten.} % TODO siehe ProfileManager
        {\keine}
        {
          \method{saveMap}
                 {
                   \param{m}{\refclass{StreetMap}}{Die Karte, die gespeichert werden soll.}
                 }
                 {
                   Speichert die ausgewählte Karte in der internen Liste und auf der Festplatte.

                   (Der Speicherort wird vom Manager deckend verwaltet.)
                 }
          \method{deleteMap}
                 {
                   \param{m}{\refclass{StreetMap}}{Die Karte, die gelöscht werden soll.}
                 }
                 {
                   Löscht die ausgewählte Karte aus der internen Liste und von der Festplatte (die OSM-Datei, den Graphen und alle Vorberechnungen).
                 }
          \method{getMaps}[Set<\refclass{StreetMap}>]
                 {\keine}
                 {
                   Gibt alle Karten in der internen Liste zurück.
                 }
        }

  \class{Controller}
        {Steuert die Programmabläufe zur Routenberechnung.}
        {\keine}
        {
          \method{Controller}
                 {\keine}
                 {Ein Konstruktor, der ein Objekt der Klasse \refclass{Controller} erzeugt.}
                 
          \method{onStartChanged}
                 {
                   \param{start}{Coordinates}{Die Koordinaten des neuen Startpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Startpunkt ändert (z.\,B. durch eine Eingabe des Benutzers).
                   Setzt den neuen Startpunkt in der \refclass{MapView}.
                   Falls bereits ein Zielpunkt ausgewählt ist, wird außerdem ein neuer Eintrag zum Verlauf hinzugefügt (siehe \refmethod{History}{addEntry}) und die Routenberechnung gestartet.
                 }
          \method{onDestinationChanged}
                 {
                   \param{destination}{Coordinates}{Die Koordinaten des neuen Zielpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Zielpunkt ändert (z.\,B. durch eine Eingabe des Benutzers).
                   Setzt den neuen Zielpunkt in der \refclass{MapView}.
                   Falls bereits ein Startpunkt ausgewählt ist, wird außerdem ein neuer Eintrag zum Verlauf hinzugefügt (siehe \refmethod{History}{addEntry}) und die Routenberechnung gestartet.
                 }
          \method{onStartAndDestChanged}
                 {
                   \param{start}{Coordinates}{Die Koordinaten des neuen Startpunkts.}
                   \param{destination}{Coordinates}{Die Koordinaten des neuen Zielpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Start- und Zielpunkt ändern (z.\,B. durch die Auswahl eines Eintrags aus dem \gls{verlauf}).
                   Die gleichen Aktionen wie für \refmethod{Controller}{onStartChanged}[onStartChanged] und \refmethod{Controller}{onDestinationChanged}[onDestinationChanged] werden ausgeführt, nur nicht doppelt.
                 }
                 
          \method{exportGPX}
                 {
                   \param{target}{File}{Die Datei, in die die Route gespeichert werden soll.}
                 }
                 {
                   Speichert die aktuelle Route im \gls{gpx}-Format in die angegebene Datei.
                   Ist keine aktuelle Route verfügbar (z.\,B. da noch keine Vorberechnung vorliegt), so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{exportHTML}
                 {
                   \param{target}{File}{Die Datei, in die die Wegbeschreibung gespeichert werden soll.}
                 }
                 {
                   Speichert die Wegbeschreibung der aktuellen Route im HTML-Format in die angegeben Datei.
                   Ist keine aktuelle Route verfügbar (z.\,B. da noch keine Vorberechnung vorliegt), so wird eine \code{IllegalStateException} geworfen.
                 }
                 
          \method{selectProfile}
                 {
                   \param{profile}{Profile}{Das aktuelle Profil.} 
                 }
                 {
                   Wählt das angegebe Profil aus.
                 }
          \method{selectMap}
                 {
                   \param{map}{\refclass{StreetMap}}{Die aktuelle Karte.} 
                 }
                 {
                   Wählt die angegebe Karte aus.
                 }

          \method{getHistoryModel}[ListModel]
                 {\keine}
                 {
                   Gibt ein \code{javax.swing.ListModel} zurück, das von einer \code{JList} verwendet werden kann, um den Verlauf anzuzeigen.
                 }
                 
          \method{schedulePrecalculate}
                 {
                   \param{profileAndMap}{ProfileMapCombination}{Eine nicht vorberechnete Kombination aus Profil und Karte.} 
                 }
                 {
                   Ruft \refmethod{PreCalculationScheduler}{scheduleCalculation}[scheduleCalculation] auf, falls keine Vorberechnung für diese Kombination aus Profil und Karte existiert.
                 }

          \method{setUseOnlineMaps}
                 {
                   \param{useOnlineMaps}{boolean}{\code{true}, um \glspl{osmkachel} zu verwenden, \code{false}, um selbst gerenderte Kacheln zu verwenden.}
                 }
                 {
                   Legt fest, ob \glspl{osmkachel} oder selbst gerenderte Kacheln verwendet werden sollen.
                   Für \glspl{osmkachel} wird der \refclass{OSMRenderer} verwendet, für die eigenen Kacheln der \refclass{TileRenderer}.
                 }
          \method{getTileSource}[\refclass{TileSource}]
                 {\keine}
                 {
                   Gibt eine \refclass{TileSource} zurück, die zum Rendern der Karten verwendet werden soll.
                 }
        }

  \class{ProfileManagementController}
        {
          Der Controller für die \refclass{ProfileManagerView}.
        }
        {\keine}
        {
          \method{ProfileManagementController}
                 {\keine}
                 {
                   Erstellt eine neue Instanz der Klasse. % TODO warum haben wir diesen Konstruktor ohne Argumente? - Lucas
                 }
          \method{swapProfile}
                 {
                   \param{p}{\refclass{Profile}}{Das neue Profil.}
                 }
                 {
                   Wird aufgerufen, wenn in der \refclass{ProfileManagerView} ein anderes Profil ausgewählt wird.
                   Speichert die Werte aller Eingabeelemente und setzt sie auf die Werte des neuen Profils (ggf. die bereits gespeicherten Werte, falls das Profil schon zuvor einmal ausgewählt war).
                   Aktiviert/Deaktiviert den Löschen-Button und die Eingabeelemente, je nachdem, ob das neue Profil ein Standardprofil ist oder nicht.
                 }
          \method{deleteProfile}
                 {\keine}
                 {
                   Markiert das aktuell ausgewählte Profil zur Löschung und entfernt es aus der Auswahlliste.
                   
                   Beachte: Das Profil wird erst in \refmethod{ProfileManagementController}{saveAllChanges}[saveAllChanges] tatsächlich gelöscht.
                   
                   Handelt es sich bei dem aktuell ausgewählten Profil um ein Standardprofil, so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{estimateDeletionAmount}[int]
                 {\keine}
                 {
                   Schätzt, wie viel Rechenzeit durch die aktuell erfassten Änderungen verloren gehen würde (durch notwendige Löschung nun veralteter Vorberechnungen).
                   Die geschätzte Dauer wird in Minuten zurückgegeben.
                 }
          \method{saveAllChanges}
                 {\keine}
                 {
                   Führt alle vom Benutzer vorgenommenen Änderungen aus.
                   Dazu gehören das Hinzufügen, Ändern und Löschen von Profilen.
                   Für geänderte Profile werden alle Vorberechnungen gelöscht. 
                 }
        }
  \class{MapManagementController}
        {
          Der Controller für die \refclass{MapManagerView}.
        }
        {\keine}
        {
          \method{MapManagementController}
                 {\keine}
                 {
                   Erstellt eine neue Instanz der Klasse. % TODO warum haben wir diesen Konstruktor ohne Argumente? - Lucas
                 }
          \method{switchMap}
                 {
                   \param{m}{\refclass{StreetMap}}{Die neue Karte.}
                 }
                 {
                   Wird aufgerufen, wenn in der \refclass{MapManagerView} eine andere Karte ausgewählt wird.
                   Speichert die Liste der Profile für diese Karte und setzt sie auf die Liste der neuen Karte (ggf. die bereits gespeicherte Liste, falls die Karte schon zuvor einmal ausgewählt war).
                   Aktiviert/Deaktiviert den Löschen-Button, je nachdem, ob die neue Karte eine Standardkarte ist oder nicht.
                 }
          \method{addProfile}
                 {
                   \param{p}{\refclass{Profile}}{Das neue Profil.}
                 }
                 {
                   Fügt das angegebene Profil zur ausgewählten Karte hinzu.
                 }
          \method{removeProfile}
                 {
                   \param{p}{\refclass{Profile}}{Das Profil, das entfernt werden soll.}
                 }
                 {
                   Entfernt das angegebene Profil von der ausgewählten Karte.
                 }
          \method{importMap}
                 {\keine}
                 {
                   Fügt eine neue Karte mit dem angegebenen Namen hinzu (oder ersetzt eine bestehende mit diesem Namen) und wählt sie aus.

                   Beachte: Die GUI-Aktionen „Importieren“ und „Aktualisieren“ werden beide durch diese Methode implementiert;
                   bei „Importieren“ stellt die GUI sicher, dass kein bereits existierender Name gewählt wird,
                   bei „Aktualisieren“ verwendet sie den Namen der existierenden Karte.
                 }
          \method{deleteCurrentMap} % TODO inkonsistenter name: beim profil ohne „curren“
                 {\keine}
                 {
                   Markiert die aktuell ausgewählte Karte zur Löschung und entfernt sie aus der Auswahlliste.
                   
                   Beachte: Die Karte wird erst in \refmethod{MapManagementController}{saveAllChanges}[saveAllChanges] tatsächlich gelöscht.
                   
                   Handelt es sich bei der aktuell ausgewählten Karte um eine Standardkarte, so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{saveAllChanges}
                 {\keine}
                 {
                   Führt alle vom Benutzer vorgenommenen Änderungen aus.
                   Dazu gehören das Importieren und Löschen von Karten sowie das Hinzufügen oder Löschen von Profilen je Karte.
                 }
        }
}

\package{Exporter} {
  \class{Exporter}
         {Stellt ein Interface zum Exportieren einer Route dar.}
         {\keine}
         {
           \method{exportRoute}
                  {
                    \param{route}{\refclass{Route}}{Eine zu exportierende Route zwischen angegebenen Start- und Zielpunkt.}
                    \param{file}{File}{Die Datei, die geschrieben werden soll.}
                  }
                  {Exportiert die Beschreibung der \refparam{Exporter}{exportRoute}{route}[route] in die angegebene Datei.}
         }

  \class{HTMLExporter}
        {Stellt die Funktionalität zum Export einer \gls{route} im HTML-Format bereit.}
        {\keine}
        {
          \method{exportRoute}
                 {
                   \param{route}{\refclass{Route}}{Die zu exportierende Route.}
                   \param{file}{File}{Die HTML-Datei, die geschrieben werden soll.}
                 }
                 {Exportiert die berechnete \refparam{HTMLExporter}{exportRoute}{route}[route] als HTML-Beschreibung in die angegebene Datei.}
        }

  \class{GPXExporter}
        {Stellt die Funktionalität zum Export einer \gls{route} im GPX-Format bereit.}
        {\keine}
        {
          \method{exportRoute}
                 {
	           \param{route}{\refclass{Route}}{Die zu exportierende Route.}
                   \param{file}{File}{Die GPX-Datei, die geschrieben werden soll.}
                 }
                 {Exportiert die Wegpunkte der \refparam{GPXExporter}{exportRoute}{route}[route] im GPX-Format in die angegebene Datei.}
        }
}


\glsaddallunused
\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
