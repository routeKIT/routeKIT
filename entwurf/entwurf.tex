% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands
\usepackage{xspace} % \xspace for use in commands: put a space only if no punctuation follows

\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\newcommand{\none}[0]{
%  % see http://tex.stackexchange.com/questions/61155/linespacing-without-packages
%  \setlength\lineskiplimit{-1000pt} % allow overflowing of lines
%  \linespread{0}\selectfont % don’t advance line after empty item
  \item[] keine.
}

\makeatletter

\newcommand{\@typelabel}[1]{T:#1} % for classes and enums
\newcommand{\@attrlabel}[2]{A:#1.#2}
\newcommand{\@methodlabel}[2]{M:#1.#2}
\newcommand{\@paramlabel}[3]{P:#1.#2.#3}
\newcommand{\@constantlabel}[2]{C:#1.#2}

% evaluate #2 if the label #1 exists, else #3.
\newcommand{\ifhaslabel}[3]{
  \@ifundefined{r@#1}
               {#3}
               {#2}
}

% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Klassen (ein oder mehrere \class)
\newcommand{\package}[3]{
  \subsection{Paket #1}
  #2
  \begin{description}
    #3
  \end{description}
}
% Argumente:
% 1. Klassenname
% 2. Beschreibung
% 3. Attribute (ein oder mehrere \attr, oder \none)
% 4. Methoden (ein oder mehrere \method, oder \none)
\newcommand{\class}[4]{
  \newcommand{\currentclass}[0]{#1}
  \item[\namedlabel{\@typelabel{#1}}{\code{#1}}] #2
    \ifstrequal{#3#4}{\none\none}{
      % \none attributes and \none methods, skip
    }{
      \begin{description}
        \ifstrequal{#3}{\none}{
          % \none attributes, skip
        }{
        \item[Attribute] \hfill % \hfill forces the following description into the next line
          \begin{description}
            #3
          \end{description}
        }
        \ifstrequal{#4}{\none}{
          % \none methods, skip
        }{
        \item[Methoden] \hfill % \hfill forces the following description into the next line
          \begin{description}
            #4
          \end{description}
        }
      \end{description}
    }
  \let\currentclass=\undefined
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\attr}[3]{
  \item[\namedlabel{\@attrlabel{\currentclass}{#1}}{\code{#1}}] #3 Typ:~\reftype{#2}
}
% Argumente:
% 1. Name
% 2. (optional) Typ – default: void (wird nicht angezeigt); wird automatisch gelinkt, falls vorhanden
% 3. Parameter (ein oder mehrere \param, oder \none)
% 4. Beschreibung
\NewDocumentCommand{\method}{m o m +m}{ % the ‘+m’ means that parameter 4 can contain several paragraphs, see http://tex.stackexchange.com/questions/64328/blank-lines-break-xparse-or-ifthen-macro
  \newcommand{\currentmethod}[0]{#1}
  \item[\namedlabel{\@methodlabel{\currentclass}{#1}}{\code{#1}}] #4\\
    \ifstrequal{#3}{\none}{
      % \none parameters, skip
    }{
      Parameter:
      \begin{description}
        #3
      \end{description}
    }
    \IfValueTF{#2} % if the optional “type” argument is given...
              {Rückgabetyp:~\reftype{#2}} % then show the return type...
              {} % else don’t.
  \let\currentmethod=\undefined
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\param}[3]{
  \item[\namedlabel{\@paramlabel{\currentclass}{\currentmethod}{#1}}{\code{#1}}] #3 Typ:~\reftype{#2}
}
% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Konstanten (ein oder mehrere \constant, oder \none)
\newcommand{\enum}[3]{
  \newcommand{\currentenum}[0]{#1}
  \item[\namedlabel{\@typelabel{#1}}{\code{#1}}] #2
    
    \ifstrequal{#3}{\none}{
      % \none cases, skip
    }{
      Instanzen:
      \begin{description}
        #3
      \end{description}
    }
  \let\currentenum=\undefined
}
% Argumente:
% 1. Name
% 2. Beschreibung
\newcommand{\constant}[2]{
  \item[\namedlabel{\@constantlabel{\currentenum}{#1}}{\code{#1}}] #2
}

% Argumente:
% 1. Typ (Klasse oder Enum)
% 2. (optional) Text – default: Typ
\NewDocumentCommand{\reftype}{mO{#1}}{%
  \ifhaslabel{\@typelabel{#1}}{% if the label exists...
    \hyperref[\@typelabel{#1}]{\code{#2}}}{% then reference it...
    \code{#2}}\xspace% else just print the text.
}
% DEPRECATED
\NewDocumentCommand{\refclass}{mO{#1}}{%
  \GenericWarning{}{The command \refclass is deprecated -- use \reftype instead}%
  \reftype{#1}[#2]%
}
% Argumente:
% 1. Klasse
% 2. Attribut
% 3. (optional) Text – default: Attribut innerhalb der Klasse, sonst Klasse.Attribut
\NewDocumentCommand{\refattr}{mmO{__DEFAULT__}}{%
  \hyperref[\@attrlabel{#1}{#2}]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the attribute name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. (optional) Text – default: Methode innerhalb der Klasse, sonst Klasse.Methode
\NewDocumentCommand{\refmethod}{mmO{__DEFAULT__}}{%
  \hyperref[\@methodlabel{#1}{#2}]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the method name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. Parameter
% 4. (optional) Text – default: Parameter innerhalb der Methode, sonst Methode.Parameter innerhalb der Klasse, sonst Klasse.Methode.Parameter
\NewDocumentCommand{\refparam}{mmmO{__DEFAULT__}}{%
  \hyperref[\@paramlabel{#1}{#2}{#3}]{\code{%
      \ifthenelse{\equal{#4}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          \ifthenelse{\equal{\currentmethod}{#2}}{%
            #3% we’re inside the same method, only use the parameter name
          }{%
            #2.#3% we’re inside the same class, only use the method and parameter name
        }}{%
          #1.#2.#3%
      }}{%
        #4%
  }}}\xspace%
}
% Argumente:
% 1. Enum
% 2. Konstante
% 3. (optional) Text – default: Konstante innerhalb der Enum, sonst Enum.Konstante
\NewDocumentCommand{\refconstant}{mmO{__DEFAULT__}}{%
  \hyperref[\@constantlabel{#1}{#2}]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentenum}{#1}}{%
          #2% we’re inside the same enum, only use the constant name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}


\makeatother

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{
  \glsdoifexists{#2}{
    \def\@glsnumberformat{glsgobblenumber}
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}
    \setkeys{glossadd}{#1}
    \@gls@saveentrycounter
    \@do@wrglossary{#2}
  }
}
\newcommand{\glsaddallunused}[1][]{
  \edef\@glo@type{\@glo@types}
  \setkeys{glossadd}{#1}
  \forallglsentries[\@glo@type]{\@glo@entry}{
    \ifglsused{\@glo@entry}{}{
      \typeout{****Glossary entry '\@glo@entry' unused****}
      \glsaddnp[#1]{\@glo@entry}}}
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

\makeatletter

\begin{document}
\shorthandoff{"}

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\emph{routeKIT}\xspace}


% alle Glossareinträge
\newglossaryentry{profil}{
  name={Profil},
  description={enthält für die Routenplanung relevante Informationen, z.\,B. die Höhe und das Gewicht des Fahrzeugs},
  plural={Profile}
}
\newglossaryentry{karte}{
  name={Karte},
  description={enthält die Daten aus \gls{osm} sowie einen Namen},
  plural={Karten}
}
\newglossaryentry{osmkachel}{
  name={OSM-Kachel},
  description={die öffentlichen gerenderten \gls{osm}-Kacheln z.\,B. auf\\\mbox{\url{http://a.tile.openstreetmap.org/}}},
  plural={OSM-Kacheln}
}
\newglossaryentry{route}{
  name={Route},
  description={ein Weg von einem Start- zu einem Zielpunkt},
  plural={Routen}
}
\newglossaryentry{vorberechnung}{
  name={Vorberechnung},
  description={verbindet die \gls{karte} mit den auf einem \gls{profil} basierenden Informationen und ermöglicht, unter anderem mittels \gls{arc}, später eine Beschleunigung der Berechnung einer \gls{route}; muss für jede neue \gls{karte}/\gls{profil}-Kombination einmal ausgeführt werden},
  plural={Vorberechnungen},
  see={arc}
}
\newglossaryentry{rendern}{
  name={rendern},
  description={Berechnung einer Bildkachel aus den zu rendernden Daten}
}
\newglossaryentry{wegbeschreibung}{
  name={Wegbeschreibung},
  description={Beschreibung einer \gls{route} durch eine Liste von Abbiegeanweisungen}
}
\newglossaryentry{dijkstra}{
  name={Dijkstra’s Algorithmus},
  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
}
\newglossaryentry{arc}{
 name={Arc-Flags},
 description={eine Technik, um eine Routenberechnung zu beschleunigen}
}
\newglossaryentry{verlauf}{
  name={Verlauf},
  description={speichert Routenanfragen für spätere Wiederverwendung. Es existiert nur ein Verlauf für die gesamte Anwendung}
}
\newglossaryentry{mercator}{
  name={Mercator-Projektion},
  description={die Zylinderprojektion der Weltkugel}
}
\newglossaryentry{G_smt}{
  name={Slippy Map Tile},
  description={
    Koordinaten, durch die Kartenkacheln einer graphischen Darstellung (mit \gls{mercator}) adressiert werden können.
    Drei Bestandteile: x, y, zoom.
    Mit nicht-ganzzahligen Werten für x und y können nicht nur Kacheln, sondern auch Geokoordinaten adressiert werden}
}
\newglossaryentry{smt}{
  type=\acronymtype,
  name={SMT},
  description={Slippy Map Tile},
  first={Slippy Map Tile (SMT)},
  see=[Glossareintrag:]{G_smt}
}

\newacronym[longplural=Personenkraftwagen]{pkw}{PKW}{Personenkraftwagen}
\newacronym[longplural=Lastkraftwagen]{lkw}{LKW}{Lastkraftwagen}
\newacronym{osm}{OSM}{OpenStreetMap}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{gpx}{GPX}{GPS Exchange Format}
\newacronym{mvc}{MVC}{Model View Controller}



\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Entwurf}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage


\section{Einleitung}

Dieses Dokument erläutert den Entwurf der Anwendung \routeKIT. % TODO „dieses Dokument dokumentiert“ (gemacht)
Es beschreibt ausführlich die verwendeten Pakete, Klassen und Methoden und ihre Beziehungen untereinander (wobei die Beziehungen im Klassendiagramm deutlicher ersichtlich sind).

\routeKIT ist eine Anwendung zur Routenplanung; durch Verwendung von \glslink{profil}{Profilen} kann sie dem Benutzer die optimalen Routen für sein spezielles Fahrzeug angeben.
Um die Routenberechnung zu beschleunigen, wird pro \gls{profil} und \gls{karte} eine zeitaufwändige \gls{vorberechnung} durchgeführt.


\section{Übersicht}

% TODO


\section{Anmerkungen}

\begin{itemize}
\item Für Attribute, die im Klassendiagramm durch Relationen oder explizit angegeben sind, sind implizite Getter und Setter gegeben.
\item Die folgenden Typen aus dem Klassendiagramm sind „typedefs“, keine echten Klassen:
  \begin{itemize}
  \item \code{Node}: \code{int}, die ID des Knotens
  \item \code{Edge}: \code{int}, die ID der Kante
  \item \code{Turn}: \code{int}, die ID der Kante im kantenbasierten Graphen (\reftype{EdgeBasedGraph})
  \item \code{Partition}: \code{int}, die ID einer Partition
  \end{itemize}
\end{itemize}


\section{Pakete und Klassen}

\package{Controllers}{
  Dieses Paket enthält die Controller aus der \gls{mvc}-Architektur.
}
{
  \class{Controller}
        {Steuert die Programmabläufe zur Routenberechnung.}
        {\none}
        {
          \method{Controller}
                 {\none}
                 {Ein Konstruktor, der ein Objekt der Klasse \reftype{Controller} erzeugt.}
                 
          \method{onStartChanged}
                 {
                   \param{start}{Coordinates}{Die Koordinaten des neuen Startpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Startpunkt ändert (z.\,B. durch eine Eingabe des Benutzers).
                   Setzt den neuen Startpunkt in der \reftype{MapView}.
                   Falls bereits ein Zielpunkt ausgewählt ist, wird außerdem ein neuer Eintrag zum Verlauf hinzugefügt (siehe \refmethod{History}{addEntry}) und die Routenberechnung gestartet.
                 }
          \method{onDestinationChanged}
                 {
                   \param{destination}{Coordinates}{Die Koordinaten des neuen Zielpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Zielpunkt ändert (z.\,B. durch eine Eingabe des Benutzers).
                   Setzt den neuen Zielpunkt in der \reftype{MapView}.
                   Falls bereits ein Startpunkt ausgewählt ist, wird außerdem ein neuer Eintrag zum Verlauf hinzugefügt (siehe \refmethod{History}{addEntry}) und die Routenberechnung gestartet.
                 }
          \method{onStartAndDestChanged}
                 {
                   \param{start}{Coordinates}{Die Koordinaten des neuen Startpunkts.}
                   \param{destination}{Coordinates}{Die Koordinaten des neuen Zielpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Start- und Zielpunkt ändern (z.\,B. durch die Auswahl eines Eintrags aus dem \gls{verlauf}).
                   Die gleichen Aktionen wie für \refmethod{Controller}{onStartChanged} und \refmethod{Controller}{onDestinationChanged} werden ausgeführt, nur nicht doppelt.
                 }
                 
          \method{exportGPX}
                 {
                   \param{target}{File}{Die Datei, in die die Route gespeichert werden soll.}
                 }
                 {
                   Speichert die aktuelle Route im \gls{gpx}-Format in die angegebene Datei.
                   Ist keine aktuelle Route verfügbar (z.\,B. da noch keine Vorberechnung vorliegt), so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{exportHTML}
                 {
                   \param{target}{File}{Die Datei, in die die Wegbeschreibung gespeichert werden soll.}
                 }
                 {
                   Speichert die Wegbeschreibung der aktuellen Route im HTML-Format in die angegeben Datei.
                   Ist keine aktuelle Route verfügbar (z.\,B. da noch keine Vorberechnung vorliegt), so wird eine \code{IllegalStateException} geworfen.
                 }
                 
          \method{selectProfile}
                 {
                   \param{profile}{Profile}{Das aktuelle Profil.} 
                 }
                 {
                   Wählt das angegebe Profil aus.
                 }
          \method{selectMap}
                 {
                   \param{map}{StreetMap}{Die aktuelle Karte.} 
                 }
                 {
                   Wählt die angegebe Karte aus.
                 }

          \method{getHistoryModel}[ListModel]
                 {\none}
                 {
                   Gibt ein \code{javax.swing.ListModel} zurück, das von einer \code{JList} verwendet werden kann, um den Verlauf anzuzeigen.
                 }
                 
          \method{precalculate}
                 {
                   \param{profileAndMap}{ProfileMapCombination}{Eine nicht vorberechnete Kombination aus Profil und Karte.} 
                 }
                 {
                   Ruft \refmethod{PreCalculator}{doPrecalculation} auf, falls keine Vorberechnung für diese Kombination aus Profil und Karte existiert.
                 }

          \method{setUseOnlineMaps}
                 {
                   \param{useOnlineMaps}{boolean}{\code{true}, um \glspl{osmkachel} zu verwenden, \code{false}, um selbst gerenderte Kacheln zu verwenden.}
                 }
                 {
                   Legt fest, ob \glspl{osmkachel} oder selbst gerenderte Kacheln verwendet werden sollen.
                   Für \glspl{osmkachel} wird der \reftype{OSMRenderer} verwendet, für die eigenen Kacheln der \reftype{TileRenderer}.
                 }
          \method{getTileSource}[TileSource]
                 {\none}
                 {
                   Gibt eine \reftype{TileSource} zurück, die zum Rendern der Karten verwendet werden soll.
                 }
        }

  \class{ProfileManagerController}
        {
          Der Controller für die \reftype{ProfileManagerView}.
        }
        {\none}
        {
          \method{switchProfile}
                 {
                   \param{from}{Profile}{Das zuvor ausgewählte Profil, mit gegebenenfalls geänderten Werten.}
                   \param{to}{String}{Der Name des neuen ausgewählten Profils.}
                 }
                 {
                   Wird aufgerufen, wenn in der \reftype{ProfileManagerView} ein anderes Profil ausgewählt wird.
                   Die Werte in \refparam{ProfileManagerController}{switchProfile}{from} werden gespeichert.
                   Anschließend wird das neue Profil gesucht oder neu erstellt und der View mitgeteilt (siehe \refmethod{ProfileManagerView}{setCurrentProfile}).
                 }
          \method{deleteCurrentProfile}
                 {\none}
                 {
                   Markiert das aktuell ausgewählte Profil zur Löschung und entfernt es aus der Auswahlliste.
                   
                   Beachte: Das Profil wird erst in \refmethod{ProfileManagerController}{saveAllChanges} tatsächlich gelöscht.
                   
                   Handelt es sich bei dem aktuell ausgewählten Profil um ein Standardprofil, so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{estimateDeletionAmount}[int]
                 {\none}
                 {
                   Schätzt, wie viel Rechenzeit durch die aktuell erfassten Änderungen verloren gehen würde (durch notwendige Löschung nun veralteter Vorberechnungen).
                   Die geschätzte Dauer wird in Minuten zurückgegeben.
                 }
          \method{saveAllChanges}
                 {\none}
                 {
                   Führt alle vom Benutzer vorgenommenen Änderungen aus.
                   Dazu gehören das Hinzufügen, Ändern und Löschen von Profilen.
                   Für geänderte Profile werden alle Vorberechnungen gelöscht. 
                 }
        }
  \class{MapManagerController}
        {
          Der Controller für die \reftype{MapManagerView}.
        }
        {\none}
        {
          \method{switchMap}
                 {
                   \param{m}{StreetMap}{Die neue Karte.}
                 }
                 {
                   Wird aufgerufen, wenn in der \reftype{MapManagerView} eine andere Karte ausgewählt wird.
                   Speichert die Liste der Profile für diese Karte und setzt sie auf die Liste der neuen Karte (ggf. die bereits gespeicherte Liste, falls die Karte schon zuvor einmal ausgewählt war).
                   Aktiviert/Deaktiviert den Löschen-Button, je nachdem, ob die neue Karte eine Standardkarte ist oder nicht.
                 }
          \method{addProfile}
                 {
                   \param{p}{Profile}{Das neue Profil.}
                 }
                 {
                   Fügt das angegebene Profil zur ausgewählten Karte hinzu.
                 }
          \method{removeProfile}
                 {
                   \param{p}{Profile}{Das Profil, das entfernt werden soll.}
                 }
                 {
                   Entfernt das angegebene Profil von der ausgewählten Karte.
                 }
          \method{importMap}
                 {
                   \param{name}{String}{Der Name der neuen Karte}
                   \param{f}{File}{Die Datei aus der sie geladen werden soll}
                 }
                 {
                   Fügt eine neue Karte mit dem angegebenen Namen hinzu (oder ersetzt eine bestehende mit diesem Namen) und wählt sie aus.

                   Beachte: Die GUI-Aktionen „Importieren“ und „Aktualisieren“ werden beide durch diese Methode implementiert;
                   bei „Importieren“ stellt die GUI sicher, dass kein bereits existierender Name gewählt wird,
                   bei „Aktualisieren“ verwendet sie den Namen der existierenden Karte.
                 }
          \method{deleteCurrentMap}
                 {\none}
                 {
                   Markiert die aktuell ausgewählte Karte zur Löschung und entfernt sie aus der Auswahlliste.
                   
                   Beachte: Die Karte wird erst in \refmethod{MapManagerController}{saveAllChanges} tatsächlich gelöscht.
                   
                   Handelt es sich bei der aktuell ausgewählten Karte um eine Standardkarte, so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{saveAllChanges}
                 {\none}
                 {
                   Führt alle vom Benutzer vorgenommenen Änderungen aus.
                   Dazu gehören das Importieren und Löschen von Karten sowie das Hinzufügen oder Löschen von Profilen je Karte.
                 }
        }
\class{ProfileManager}
        {Verwaltet die Profile. Hat intern eine Menge von vorhandenen Profilen.}
        {\none}
        {
          \method{saveProfile}
                 {
                   \param{p}{Profile}{Das Profil, das gespeichert werden soll.}
                 }
                 {
                   Speichert das ausgewählte Profil in der internen Liste und auf der Festplatte.
                   
                   (Der Speicherort wird vom Manager deckend verwaltet.) % „deckend“ = “opaque”
                 }
          \method{deleteProfile}
                 {
                   \param{p}{Profile}{Das Profil, das gelöscht werden soll.}
                 }
                 {
                   Löscht das ausgewählte Profil aus der internen Liste und von der Festplatte.
                 }
          \method{getProfiles}[Set<Profile>]
                 {\none}
                 {
                   Gibt alle Profile in der internen Liste zurück.
                 }
        }
  \class{MapManager}
        {Verwaltet die Kartendaten. Hat intern eine Menge von vorhandenen Kartendaten.}
        {\none}
        {
          \method{saveMap}
                 {
                   \param{m}{StreetMap}{Die Karte, die gespeichert werden soll.}
                 }
                 {
                   Speichert die ausgewählte Karte in der internen Liste und auf der Festplatte.

                   (Der Speicherort wird vom Manager deckend verwaltet.)
                 }
          \method{deleteMap}
                 {
                   \param{m}{StreetMap}{Die Karte, die gelöscht werden soll.}
                 }
                 {
                   Löscht die ausgewählte Karte aus der internen Liste und von der Festplatte (die OSM-Datei, den Graphen und alle Vorberechnungen).
                 }
          \method{getMaps}[Set<StreetMap>]
                 {\none}
                 {
                   Gibt alle Karten in der internen Liste zurück.
                 }
        }

}

\package{Precalculation}{
  Dieses Paket enthält alle Klassen, die an der \gls{vorberechnung} beteiligt sind.
  
  % TODO kurze erklärung, wie die vorberechnung läuft
}
{
  \class{MapImporter}
        {Stellt die Funktionalität zum Importieren einer neuen Karte bereit.}
        {\none}
        {
          \method{importMap}[StreetMap]
                 {
                   \param{f}{File}{Die OSM-Datei, aus der die Kartendaten importiert werden sollen.}
                 }
                 {Importiert eine neue Karte aus der angegebenen OSM-Datei. Die vom \reftype{OSMParser} aufgebaute Graphdatenstruktur wird dabei vom \reftype{GraphPartitioner} partitioniert und zurückgegeben.}
        }
  \class{OSMParser}
        {Stellt die Funktionalität zum Parsen einer OSM-Datei bereit. Dafür werden zur temporären Repräsentation des Graphen im Speicher die Klassen \reftype{MapNode}, \reftype{MapEdge} und \reftype{TurnRestriction} verwendet.}
        {\none}
        {
          \method{parseOSM}[StreetMap]
                 {
                   \param{f}{File}{Die OSM-Datei, die eingelesen werden soll.}
                 }
                 {Liest eine OSM-Datei ein und erzeugt daraus einen \reftype{Graph} sowie den zugehörigen (unpartitionierten) \reftype{EdgeBasedGraph} und gibt diese als \reftype{StreetMap} zurück.}
        }
  \class{MapNode}
        {Stellt einen Knoten im Straßengraphen dar. Dies ist nur eine vom \reftype{OSMParser} verwendete Zwischendarstellung.}
        {
          \attr{lat}{float}{Der Längengrad des Knotens.}
          \attr{lon}{float}{Der Breitengrad des Knotens.}
        }
        {
          \method{getOutgoingEdges}[Set<MapEdge>]
                 {\none}
                 {Gibt eine Liste mit allen ausgehenden Kanten des Knotens zurück.}
        }
  \class{MapEdge}
        {Stellt eine Kante im Straßengraphen dar. Dies ist nur eine vom \reftype{OSMParser} verwendete Zwischendarstellung.}
        {\none}
        {\none}
  \class{TurnRestriction}
        {Stellt eine Abbiegebeschränkung dar. Dies ist nur eine vom \reftype{OSMParser} verwendete Zwischendarstellung.}
        {\none}
        {\none}
  \class{GraphPartitioner}
        {Partitioniert einen gegebenen Graphen.}
        {\none}
        {
          \method{partitionGraph}
                 {
                   \param{graph}{EdgeBasedGraph}{Der zu partitionierende Graph.}
                   \param{numberOfPartitions}{int}{Die gewünschte Anzahl an Partitionen.}
                 }
                 {
                   Teilt den Graphen in die gewünschte Anzahl an Partitionen.
                   
                   Die ermittelten Partitionen werden über \refmethod{EdgeBasedGraph}{setPartitions} direkt gesetzt.
                 }
        }
        
  \class{ExternalPartitionerAdapter}
        {Leitet die Partitionierungsanfrage an ein externes Partitionierungsprogramm weiter.}
        {\none}
        {
          \method{partitionGraph}
                 {
                   \param{graph}{EdgeBasedGraph}{Der zu partitionierende Graph.}
                   \param{numberOfPartitions}{int}{Die gewünschte Anzahl an Partitionen.}
                 }
                 {Lässt den Graphen durch das externe Programm in die gewünschte Anzahl an Partitionen teilen.}
        }
              
  \class{PreCalculator}
        {Führt die Vorberechnung für eine Kombination aus \reftype{Profile}[Profil] und \reftype{StreetMap}[Karte] durch.}
        {\none}
        {
          \method{doPrecalculation}
                 {
                   \param{comb}{ProfileMapCombination}{Die Kombination aus \reftype{Profile}[Profil] und \reftype{StreetMap}[Karte], für die die Vorberechnung durchgeführt werden soll.}
                 }
                 {
                   Führt die Vorberechnung für die gegebene Kombination aus \reftype{Profile}[Profil] und \reftype{StreetMap}[Karte] durch.
                   Dabei werden ein \reftype{EdgeWeighter} und ein \reftype{ArcFlagsCalculator} aufgerufen.
                 }
        }
        
  \class{EdgeWeighter}
        {
          Versieht den kantenbasierten Graphen (\reftype{EdgeBasedGraph}) mit Kantengewichten.
          
          Die Kantengewichte des kantenbasierten Graphen sind profilabhängig und geben an, wie „teuer“ ein bestimmter Abbiegevorgang ist.
          Abbiegebeschränkungen werden durch maximale Kantengewichte umgesetzt.
        }
        {\none}
        {
          \method{weightEdges}
                 {
                   \param{combination}{ProfileMapCombination}{Die zu gewichtende Kombination aus Profil und Karte.}
                 }
                 {
                   Berechnet die Kantengewichte für die angegebene Kombination und setzt die \reftype{Weights} von \refparam{EdgeWeighter}{weightEdges}{combination} entsprechend.
                 }
        }
        
  \class{ArcFlagsCalculator}
        {Berechnet \gls{arc} für einen partitionierten, gewichteten Graphen.}
        {\none}
        {
          \method{calculateArcFlags}
                 {
                   \param{combination}{ProfileMapCombination}{Die Kombination aus Profil und Karte.}
                 }
                 {
                   Berechnet die \gls{arc} für die angegebene Kombination und setzt die \reftype{ArcFlags} von \refparam{ArcFlagsCalculator}{calculateArcFlags}{combination} entsprechend.
                 }
        }
}

\package{RouteCalculator}{
  Dieses Paket enthält alle Klassen, die zur Routenberechnung benötigt werden.
}
{
  \class{RouteCalculator}
        {Stellt ein Interface für einen Algorithmus zur Routenberechnung bereit.}
        {\none}
        {
          \method{calculateRoute}[Route]
                 {
                   \param{start}{PointOnEdge}{Der Startpunkt für die Routenberechnung.}
                   \param{destination}{PointOnEdge}{Der Zielpunkt für die Routenberechnung.}
                   \param{data}{ProfileMapCombination}{Der vorberechnete Graph auf dem die Routenberechnung durchgeführt wird.}
                 }
                 {Berechnet einen Weg vom Startpunkt zum Zielpunkt auf dem gegebenen Graphen.}
        }
  \class{ArcFlagsDijkstra}
        {
          Verwended \gls{dijkstra}, um die schnellste Route zwischen Start- und Zielpunkt für die aktuelle Kombination aus Karte und Profil zu berechnen.
          Durch \gls{arc} wird die Berechnung beschleunigt.
        }
        {\none}
        {\none}
  \class{Route}
        {Repräsentiert eine berechnete \gls{route}.}
        {
          \attr{start}{PointOnEdge}{Der Startpunkt der Route.}
          \attr{destination}{PointOnEdge}{Der Zielpunkt der Route.}
        }
        {
          \method{getTurns}[List<Turn>]
                 {\none}
                 {Liefert eine Liste der Abbiegevorgänge, aus denen die Route besteht.}
          \method{getNodeIterator}[Iterator<Node>]
                 {\none}
                 {Gibt einen Iterator über die Knoten (\code{Node}) der Route einschließlich Start- und Zielpunkt zurück. Der Iterator ermittelt diese dynamisch aus der Liste der Abbiegevorgänge.}
        }
  \class{RouteDescriptionGenerator}
        {Stellt die Funktionalität zur Erzeugung einer \gls{wegbeschreibung} bereit.}
        {\none}
        {
          \method{generateRouteDescription}[RouteDescription]
                 {
                   \param{route}{Route}{Die Route, deren Beschreibung erzeugt werden soll.}
                 }
                 {Erzeugt die zur \refparam{RouteDescriptionGenerator}{generateRouteDescription}{route} gehörende Wegbeschreibung.}
        }
  \class{RouteDescription}
        {Kapselt die zu einer \reftype{Route} gehörende \gls{wegbeschreibung}.}
        {\none}
        {
          \method{getInstructions}[List<TurnInstruction>]
                 {\none}
                 {Liefert eine Liste der Abbiegeanweisungen.}
        }
  \class{TurnInstruction}
        {Kapselt eine einzelne Abbiegeanweisung, aus welchen eine \reftype{RouteDescription} aufgebaut ist.}
        {\none}
        {
          \method{toString}[String]
                 {\none}
                 {Gibt den Text der Abbiegeanweisung zurück.}
        }
}

\package{MapDisplay}{
  Dieses Paket enthält alle Klassen, die an der Darstellung der Karte im \gls{gui} beteiligt sind.
  
  Die zentrale Klasse dieses Pakets ist der \reftype{TileCache}, der dafür sorgt, dass Kartenkacheln nicht jedes Mal neu berechnet werden müssen.
  Er berechnet selbst keine Kacheln, sondern erhält diese von einer untergeordneten \reftype{TileSource}, welche die Kacheln synchron berechnet.
  Der Cache stellt diese Kacheln dann asynchron bereit, indem er für nicht gespeicherte Kacheln zunächst eine „Dummy-Kachel“ zurückgibt und bei abgeschlossener Berechnung registrierte \reftype{TileFinishedListener} benachrichtigt.
  
  Um nicht zu viel Arbeitsspeicher zu beanspruchen, verwaltet der Cache die gespeicherten Kacheln so, dass sie bei Speicherknappheit von der JVM garbage-collected werden können.
  
  Kartenkacheln werden über \gls{G_smt}-Koordinaten, wie sie auch bei anderen \gls{osm}-Viewern verwendet werden, adressiert.
}
{
 \class{TileSource}
        {Abstrakte Klasse, die ein Interface für das (synchrone) \Gls{rendern} von Kartenkacheln definiert.}
        {\none}
        {
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{getTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{getTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{getTile}{zoom}}
                 }
                 {Berechnet die angegebene Kachel und gibt sie zurück.}
        }
  \class{TileCache}
        {
          Verwaltet die Berechnung von Kartenkacheln und ist ein Zwischenspeicher für diese.
          Kacheln können angefragt werden, und nachdem die (asynchrone) Berechnung abgeschlossen ist, werden registrierte \reftype{TileFinishedListener} benachrichtigt.
          
          Intern werden die gecacheten Kacheln so gehalten, dass der Garbage Collector sie bei Speicherknappheit verwerfen kann (etwa durch \code{SoftReference}s).
        }
        {\none}
        {
          \method{TileCache}
                 {\param{target}{TileSource}{Die \code{TileSource}, die die tatsächliche Berechnung durchführt und deren Ergebnisse zwischengespeichert werden.}}
                 {Erstellt einen neuen Cache für die angegebene \reftype{TileSource}.}
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{Die \gls{smt}-X-Komponente.}
                   \param{y}{int}{Die \gls{smt}-Y-Komponente.}
                   \param{zoom}{int}{Die \gls{smt}-Zoom-Komponente.}
                 }
                 {
                   Ist die angeforderte Kachel bereits im Zwischenspeicher vorhanden, so wird sie direkt zurückgegeben;
                   andernfalls wird eine Dummy-Kachel zurückgegeben und die richtige von \refparam{TileCache}{TileCache}{target} angefordert, im Zwischenspeicher gespeichert und dann zurückgegeben. Kacheln von tieferer Zoomstufe und der Umgebung einer Kachel werden von \refparam{TileCache}{TileCache}{target} angefordert und im Zwischenspeicher gespeichert.
                 }

 \method{addTileFinishedListener}
                 {\param{listener}{TileFinishedListener}{Der Listener, der hinzugefügt werden soll.}}
                 {
                   Registriert einen \reftype{TileFinishedListener}, der benachrichtigt wird, wenn eine Kachel fertig berechnet ist.
                   Die Kachel ist Teil der Nachricht.
                 }
}
  \class{TileFinishedListener}
        {Wird benachrichtigt, wenn die Berechnung einer Kartenkachel abgeschlossen ist.}
        {\none}
        {
          \method{tileFinished}
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{getTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{getTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{getTile}{zoom}}
                   \param{tile}{BufferedImage}{Die berechnete Kachel.}
                 }
                 {
                   Wird vom \reftype{TileCache} aufgerufen, wenn die Berechnung einer Kachel abgeschlossen ist.
                   Die übliche Aktion ist, ein \code{repaint} der Kartenansicht im \gls{gui} auszulösen.
                 }
        }
 
  \class{TileRenderer}
        {Eine \reftype{TileSource}, die die Kacheln selbst berechnet.}
        {\none}
        {
          \method{TileRenderer}
	   { 
		\param{graph}{Graph}{Ein Adjazenzfeld.}
	    }
	   {Ein Konstruktor, der einen neuen TileRenderer erzeugt.}
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{getTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{getTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{getTile}{zoom}}
                 }
                 {Berechnet die angegebene Kachel und gibt sie zurück.}
        }
  \class{OSMRenderer}
        {Eine \reftype{TileSource}, die die \glspl{osmkachel} vom OpenStreetMap-Server herunterlädt.}
        {\none}
        {
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{getTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{getTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{getTile}{zoom}}
                 }
                 {Lädt die angegebene Kachel herunter und gibt sie zurück.}
        }
}

\package{Models} {
Dieses Paket enthält die Models aus der \gls{mvc}-Architektur. 
}
{  \class{ProfileMapCombination}
        {Eine Kombination aus einem \reftype{Profile}[Profil] und einer \reftype{StreetMap}[Karte].}
        {
          \attr{profile}{Profile}{Das \gls{profil}.}
          \attr{map}{StreetMap}{Die Karte.}
        }
        {
	\method{isCalculated}[boolean]
         	    {\none}
	    {Gibt \code{true} zurück, wenn für eine Kombination aus Profil und Karte eine Vorberechnung der Gewichte und der \gls{arc} existiert.}
         }
  \class{ArcFlags}
        {Enthält die \gls{arc} für den vorberechneten Graphen.}
        {\none}
        {
          \method{getFlags}[int]
                 {
                   \param{turn}{Turn}{Die Nummer eines Abbiegevorgang.}
                 }
                 {Gibt die zum Abbiegevorgang gehörenden \gls{arc} zurück.}
        }
\class{Weights}
        {Enthält die Kantengewichte für den vorberechneten Graphen.}
        {\none}
        {
          \method{getWeight}[int]
                 {
                   \param{turn}{Turn}{Die Nummer eines Abbiegevorgang.}
                 }
                 {Gibt die zum Abbiegevorgang gehörendes Gewicht zurück.}
        }

  \class{RouteModel}
        {Stellt die aktuellen Start- und Zielpunkte, sowie die aktuell berechnete Route dar. Die getter liefern dabei immer den aktuelle Zustand (auch null möglich). Die setter ändern den Wert und informieren eventuelle \reftype{RouteListener}}
        {\none}
        {
          \method{addRouteListener}
                 {
                   \param{listener}{RouteModelListener}{der neue Listener der über Änderungen informiert werden will}
                 }
                 {fügt einen RouteListener dem Modell hinzu, damit er über Änderungen an Route, Start oder Ziel informiert wird}
        }
  \class{RouteModelListener}
        {Wird bei Änderungen am \reftype{RouteModel} informiert.}
        {\none}
        {
          \method{routeModelChanged}
                 {\none}
                 {Wird bei jeder Änderung aufgerufen}
        }
}

\package{View}{
  Dieses Paket enthält die Views nach der \gls{mvc}-Architektur. Alle Views im Klassendiagramm sind Interfaces, die von genau einer Klasse realisiert werden. 
}
{
   \class{MainView}
        {Zeigt das Hauptfenster auf dem Bildschirm an.}
        {\none}
        {
          \method{setCurrentMap}
                 {
                   \param{map}{StreetMap}{Die neue Karte.}
                 }
                 {
                   Aktualisiert die Anzeige der aktuellen Karte.
                 }
          \method{setCurrentProfile}
                 {
                   \param{profile}{Profile}{Das neue Profil.}
                 }
                 {
                   Aktualisiert die Anzeige des aktuellen Profils.
                 }
        }

  \class{MapView}
        {
          Zeigt einen Kartenausschnitt auf dem Bildschirm an.
          
          Als Kartenprojektion wird die \gls{mercator} verwendet.
        }
        {\none}
        {
          \method{MapView}
                 {
                   \param{source}{TileSource}{Ein Objekt, das die Kartenkacheln liefert, die dann angezeigt werden.}
                 }
                 {
                   Erzeugt eine neue \reftype{MapView}. Die angegebene \reftype{TileSource} wird zum \Gls{rendern} verwendet.
                   
                   Da die Kacheln bei jedem \refmethod{MapView}{paint} synchron angefragt werden, sollte \refparam{MapView}{MapView}{source} ein \reftype{TileCache} sein.
                 }
          \method{paint}
                 {
                   \param{graphics}{Graphics}{Die Java \code{Graphics}, auf welche die Karte gezeichnet wird.}
                 }
                 {
                   Zeichnet den aktuell sichtbaren Kartenausschnitt.
                   Alle sichtbaren Kacheln werden von \refparam{MapView}{MapView}{source} synchron angefordert.
                 }
        }

  \class{ProfileManagerView}
        {Zeigt das Fenster der Profilverwaltung auf dem Bildschirm an.}
        {\none}
        {
          \method{setCurrentProfile}
                 {
                   \param{profile}{Profile}{Das neue Profile.}
                 }
                 {
                   Setzt das aktuelle Profil auf das angegebene Profil, lädt seine Werte in die Eingabefelder und aktiviert/deaktiviert die Eingabeelemente, je nachdem, ob es sich um ein Standardprofil handelt oder nicht.
                 }
          \method{setAvailableProfiles}
                 {
                   \param{profiles}{List<Profile>}{Die verfügbaren Profile.}
                 }
                 {
                   Setzt die Profile, die aktuell ausgewählt werden können.
                 }
        }

   \class{MapManagerView}
        {Zeigt das Fenster der Kartenverwaltung auf dem Bildschirm an.}
        {\none}
        {
          \method{setCurrentMap}
                 {
                   \param{map}{StreetMap}{Die neue Karte.}
                   \param{profiles}{Set<Profile>}{Die Profile für die neue Karte.}
                 }
                 {
                   Setzt die aktuelle Karte auf die angegebene Karte, aktualisiert die Liste der Profile für die ausgewählte Karte und aktiviert/deaktiviert die „Import“- und „Löschen“-Buttons, je nachdem, ob es sich um eine Standardkarte handelt oder nicht.
                 }
          \method{setAvailableMaps}
                 {
                   \param{maps}{Set<StreetMap>}{Die verfügbaren Karten.}
                 }
                 {
                   Setzt die Karten, die aktuell ausgewählt werden können.
                 }
        }

  \class{HistoryView}
        {Zeigt das Fenster mit dem Verlauf auf dem Bildschirm an.}
        {\none}
        {
          \method{HistoryView}
                 {
                   \param{history}{History}{Der Verlauf, der angezeigt wird.}
                 }
                 {
                   Erstellt eine HistoryView für den angegebenen Verlauf.
                   (Der Verlauf kann später nicht mehr geändert werden.)
                 }
        }

  \class{AboutView}
        {Zeigt das Fenster mit den Informationen über \routeKIT auf dem Bildschirm an.}
        {\none}
        {\none}
}

\package{Profiles}{
  Dieses Paket enthält alle Klassen zu \glslink{profil}{Profilen}.
}
{
  \class{Profile}
        {Ein \glslink{profil}{Fahrzeugprofil}.}
        {
          \attr{name}{String}{Der Name des Profils.}
          \attr{vehicleType}{VehicleType}{Der Fahrzeugtyp.}
          \attr{height}{int}{Die Höhe des Fahrzeugs, in Zentimetern.}
          \attr{width}{int}{Die Breite des Fahrzeugs, in Zentimetern.}
          \attr{weight}{int}{Das Gewicht des Fahrzeugs, in Kilogramm.}
          \attr{speedHighway}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Autobahn, in Kilometern pro Stunde.}
          \attr{speedRoad}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Landstraße, in Kilometern pro Stunde.}
        }
        {
          \method{isDefault}[boolean]
                 {\none}
                 {
                   Gibt zurück, ob es sich um ein Standardprofil handelt oder nicht.
                 }
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die das Profil gespeichert wird.}
                 }
                 {Speichert das Profil in die angegebene Datei.}
          \method{load}[Profile]
                 {
                   \param{file}{File}{Die Datei, aus der das Profil geladen wird.}
                 } 
                 {Lädt ein Profil aus der angegebenen Datei und gibt es zurück.}
        }
  \enum{VehicleType}
       {
         Ein Fahrzeugtyp.
       }
       {
         \constant{Car}{Ein \gls{pkw}.}
         \constant{Truck}{Ein \gls{lkw}.}
         \constant{Bus}{Ein Omnibus.}
         \constant{Motorcycle}{Ein Motorrad.}
       }
}

\package{Map}{
  Dieses Paket enthält alle Klassen zu Karten und Kartengraphen.
  
  \routeKIT verwendet zwei Datenstrukturen für den Straßengraphen:
  \begin{description}
  \item[\reftype{Graph}] ist ein regulärer, knotenbasierter Graph, gespeichert als Adjazenzfeld. Er wird zum \Gls{rendern} der Karte verwendet.
  \item[\reftype{EdgeBasedGraph}] ist ein kantenbasierter Graph (ebenfalls gespeichert als Adjazenzfeld). Er wird zur Routenberechnung verwendet.
  \end{description}
}
{
  \class{StreetMap}
        {Eine Karte.}
        {
          \attr{name}{String}{Der Name der Karte.}
          \attr{graph}{Graph}{Der Graph der Karte, d.\,h. das Straßennetz.}
        }
        {
          \method{isDefault}[boolean]
                 {\none}
                 {
                   Gibt zurück, ob es sich um eine Standardkarte handelt.
                 }
        }

  \class{Graph}
        {
          Ein Kartengraph / Straßennetz. Beachte: Dieser Graph ist nicht das Ergebnis einer Vorberechnung für ein Profil und eine Karte, sondern nur für eine Karte.
        }
        {
          \attr{highwayType}{HighwayType}{Der Straßentyp.}
        }
        {
          \method{Graph}
                 {
                   \param{nodes}{Node[]}{Der Knoten-Bestandteil des Adjazenzfeldes.}
                   \param{edges}{Edge[]}{Der Kanten-Bestandteil des Adjazenzfeldes.}
                   \param{nodeProps}{Map<Node, NodeProperties>}
                         {
                           Die \code{NodeProperties} der Knoten des Graphen. Es wird eine \code{Map} anstelle eines Arrays verwendet, da die meisten Knoten keine besonderen Eigenschaften haben und daher das Array zum großen Teil leer wäre.
                         }
                   \param{edgeProps}{EdgeProperties[]}
                         {
                           Die \code{EdgeProperties} der Kanten des Graphen. Hier wird ein Array verwendet, da jede Kante einen Namen und damit ein \code{EdgeProperties}-Objekt hat.
                         }
                   \param{lat}{float[]}{Die geographischen Breiten der Knoten des Graphen.}
                   \param{lon}{float[]}{Die geographischen Längen der Knoten des Graphen.}
                 }
                 {Erstellt ein neues Graph-Objekt aus dem gegebenen Adjazenzfeld.}
          \method{getOutgoingEdges}[Set<Edge>]
                 {\param{node}{Node}{Der Knoten, dessen ausgehende Kanten gesucht werden.}}
                 {Gibt alle ausgehenden Kanten des angegebenen Knotens zurück.}
	      \method{getIncomingEdges}[Set<Edge>]
                 {\param{node}{Node}{Der Knoten, dessen eingehende Kanten gesucht werden.}}
                 {Gibt alle in den Knoten eingehende Kanten zurück.}
          \method{getTargetNode}[Node]
                 {\param{edge}{Edge}{Die Kante, dessen Endknoten gesucht wird.}}
                 {Gibt den Endknoten der angegebenen Kante zurück.}
          \method{getStartNode}[Node]
                 {\param{edge}{Edge}{Die Kante, dessen Startknoten gesucht wird.}}
                 {Gibt den Startknoten der angegebenen Kante zurück.}       
          \method{getLat}[float]
                 {\param{node}{Node}{Der Knoten, dessen geographische Breite gesucht wird.}}
                 {Gibt die geographische Breite des angegebenen Knotens zurück.}
          \method{getLon}[float]
                 {\param{node}{Node}{Der Knoten, dessen geographische Länge gesucht wird.}}
                 {Gibt die geographische Länge des angegebenen Knotens zurück.}
          \method{getNodeProperties}[NodeProperties]
                 {\param{node}{Node}{Der Knoten, dessen \reftype{NodeProperties} gesucht werden.}}
                 {Gibt die \code{NodeProperties} des angegebenen Knotens zurück.}
          \method{getEdgeProperties}[EdgeProperties]
                 {\param{edge}{Edge}{Die Kante, deren \reftype{EdgeProperties} gesucht werden.}}
                 {Gibt die \code{EdgeProperties} der angegebenen Kante zurück.}
	\method{getIndex}[GraphIndex]
	      {\param{zoom}{int}{Das Zoomlevel.}}
                 {Gibt eine geometrische Datenstruktur zu einem bestimmten Zoomlevel zurück.}
        }
  \class{GraphIndex}
        {Eine geometrische Datenstruktur.}
        {\none}
        {
	\method{GraphIndex}
		{
		    \param{graph}{Graph}{Ein Adjazenzfeld.}
 		}
		    {Erzeugt eine geometrische Datenstruktur für einen Graph aus einem Adjazenzfeld.}	
	\method{getEdgesIn}[Edge[]]
		{
		    \param{leftTop}{Coordinates}{Die Koordinaten der linken oberen Ecke des Ausschnitts.}
 		    \param{rightBottom}{Coordinates}{Die Koordinaten der rechten unteren Ecke des Ausschnitts.}
                      } 
		    {
                      Bestimmt alle Kanten in einem Kartenausschnitt, der durch \refparam{GraphIndex}{getEdgesIn}{leftTop} und \refparam{GraphIndex}{getEdgesIn}{rightBottom} festgelegt ist.
                    }
	\method{projectToEdge} [PointOnEdge]
                 {
                   \param{lon}{float}{Die geographische Länge von einem Punkt.}
                   \param{lat}{float}{Die geographische Breite von einem Punkt.}
                 }
                 {Sucht zu gegebenen Koordinaten den nächsten Punkt auf einer Kante.}
         }
  \class{NodeProperties}
        {Kapselt die Eigenschaften eines Knotens.}
        {\none}
        {
          \method{isMotorwayJunction}[boolean]
                 {\none}
                 {Bestimmt, ob der Knoten eine Schnellstraßen- oder Autobahnanschlussstelle ist.}
          \method{getJunctionName}[String]
                 {\none}
                 {Gibt den Namen der Anschlussstelle zurück oder \code{null}, falls es sich nicht um eine Anschlussstelle handelt.}
          \method{getJunctionRef}[String]
                 {\none}
                 {Gibt die Nummer der Anschlussstelle zurück oder \code{null}, falls es sich nicht um eine Anschlussstelle handelt.}
          \method{isTrafficLights}[boolean]
                 {\none}
                 {Bestimmt, ob sich an dem Knoten eine Ampel befindet.}
        }
  \class{EdgeProperties}
        {Kapselt die Eigenschaften einer Kante.}
        {\none}
        {
          \method{getName}[String]
                 {\none}
                 {Gibt den Namen der Straße zurück oder \code{null}, falls nicht vorhanden.}
          \method{getRoadRef}[String]
                 {\none}
                 {Gibt die Nummer der Straße zurück oder \code{null}, falls nicht vorhanden.}
          \method{getMaxSpeed}[int]
                 {\param{profile}{Profile}{Das Profil, für das die Höchstgeschwindigkeit auf dieser Kante bestimmt werden soll.}}
                 {Bestimmt die zulässige Höchstgeschwindigkeit (in Kilometern pro Stunde) auf dieser Kante für das angegebene Profil.}
        }
  \enum{HighwayType}
       {Ein Straßentyp}
       {
         \constant{Motorway}{Autobahn}
         \constant{Trunk}{Schnellstraße}
         \constant{Primary}{Bundesstraße}
         \constant{Secondary}{Landesstraße}
         \constant{Tertiary}{Kreisstraße}
         \constant{Unclassified}{Gemeindeverbindungsstraße}
         \constant{Residential}{Ortsstraße}
       }
  \class{EdgeBasedGraph}
        {
          Enthält das Straßennetz als kantenbasierten Graphen. Die Knoten dieses Graphen entsprechen den Kanten des zugehörigen \reftype{Graph}-Objekts und werden daher mit \code{Edge} bezeichnet. Die Kanten dieses Graphen repräsentieren Abbiegemöglichkeiten und werden mit \code{Turn} bezeichnet.
          
          Diese Datenstruktur ist profilunabhängig und wird, wie \reftype{Graph}, bei der Vorberechnung für eine Karte erstellt.
          Erst in Kombination mit den Profil-spezifischen \reftype{Weights} kann sie zur Routenberechnung verwendet werden.
        }
        {\none}
        {
          \method{getOutgoingTurns}[Set<Turn>]
                 {
                   \param{edge}{Edge}{Die Kante, deren ausgehende Abbiegemöglichkeiten gesucht werden.}
                 }
                 {Gibt alle Abbiegemöglichkeiten \emph{von} der angegebenen Kante zurück.}
          \method{getIncomingTurns}[Set<Turn>]
                 {
                   \param{edge}{Edge}{Die Kante, deren eingehende Abbiegemöglichkeiten gesucht werden.}
                 }
                 {Gibt alle Abbiegemöglichkeiten \emph{auf} die angegebene Kante zurück.}
          \method{getTargetEdge}[Edge]
                 {
                   \param{turn}{Turn}{Die Abbiegemöglichkeit, deren Endkante gesucht wird.}
                 }
                 {Gibt die Kante zurück, auf die die angegebene Abbiegemöglichkeit führt.}
          \method{getStartEdge}[Edge]
                 {
                   \param{turn}{Turn}{Die Abbiegemöglichkeit, deren Anfangskante gesucht wird.}
                 }
                 {Gibt die Kante zurück, von der die angegebene Abbiegemöglichkeit besteht.}
          \method{getPartition}[Partition]
                 {
                   \param{edge}{Edge}{Die Kante, deren Partition bestimmt werden soll.}
                 }
                 {
                   Gibt die Partition zurück, in der sich die angegebene Kante (der Knoten des kantenbasierten Graphen) befindet.
                   
                   Ist noch keine Partitionierung gegeben, so wird immer eine Standard-Partition zurückgegeben.
                 }
          \method{setPartitions}
                 {
                   \param{partitions}{Partition[]}{Die neuen Partitionen.}
                 }
                 {
                   Setzt die Partitionen des Graphen. Die \code{Edge}s des Graphen sind die Indizes in \refparam{EdgeBasedGraph}{setPartitions}{partitions}.
                 }
          \method{getTurnType}[TurnType]
                 {
                   \param{turn}{Turn}{Der Abbiegevorgang, dessen Art gesucht wird.}
                 }
                 {Gibt die Art des angegebenen Abbiegevorgangs zurück.}
          \method{allowsTurn}[boolean]
                 {
                   \param{turn}{Turn}{Der zu betrachtende Abbiegevorgang.}
                   \param{profile}{Profile}{Das verwendete Profil.}
                 }
                 {Bestimmt, ob der angegebene Abbiegevorgang unter dem angegeben Profil zulässig ist.}
        }
  \enum{TurnType}
       {Der Typ einer Abbiegemöglichkeit.}
       {
         \constant{RightTurn}{Rechts abbiegen.}
         \constant{LeftTurn}{Links abbiegen.}
         \constant{HalfRightTurn}{Rechts halten.}
         \constant{HalfLeftTurn}{Links halten.}
         \constant{StraightOn}{Geradeaus.}
         \constant{NoTurn}{Keine echte Abbiegemöglichkeit.}
         \constant{RoundaboutEntry}{Einfahrt in einen Kreisverkehr.}
         \constant{RoundaboutExit}{Ausfahrt aus einem Kreisverkehr.}
         \constant{RoundaboutNoExit}{An einer Ausfahrt im Kreisverkehr bleiben.}
         \constant{MotorwayJunction}{Eine Anschlussstelle einer Autobahn oder Schnellstraße.}
       }
}

\package{Exporter}{
  Dieses Paket enthält alle Klassen, die zum Exportieren der Route oder ihrer Beschreibung benötigt werden.
}
{
  \class{HTMLExporter}
        {Stellt die Funktionalität zum Export der \gls{wegbeschreibung} einer \gls{route} im HTML-Format bereit.}
        {\none}
        {
          \method{exportRouteDescription}
                 {
                   \param{routeDesc}{RouteDescription}{Die zu exportierende Wegbeschreibung.}
                   \param{file}{File}{Die HTML-Datei, die geschrieben werden soll.}
                 }
                 {Exportiert die \refparam{HTMLExporter}{exportRouteDescription}{routeDesc} im HTML-Format in die angegebene Datei.}
        }

  \class{GPXExporter}
        {Stellt die Funktionalität zum Export einer \gls{route} im GPX-Format bereit.}
        {\none}
        {
          \method{exportRoute}
                 {
                   \param{route}{Route}{Die zu exportierende Route.}
                   \param{file}{File}{Die GPX-Datei, die geschrieben werden soll.}
                 }
                 {Exportiert die Wegpunkte der \refparam{GPXExporter}{exportRoute}{route} im GPX-Format in die angegebene Datei.}
        }
}

\package{History}{
  Dieses Paket enthält alle Klassen, die für den \gls{verlauf} benötigt werden.
}
{
  \class{History}
        {Kapselt den \gls{verlauf}.}
        {\none}
        {
          \method{addEntry}
                 {
                   \param{start}{Coordinates}{Der Startpunkt.}
                   \param{destination}{Coordinates}{Der Zielpunkt.}
                 }
                 {Fügt einen Eintrag zum Verlauf hinzu. Als \refattr{HistoryEntry}{date} des neuen Eintrags wird die aktuelle Zeit verwendet.}
          \method{getEntries}[List<HistoryEntry>]
                 {\none}
                 {Gibt alle Einträge des Verlaufs zurück.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die der Verlauf gespeichert wird.}
                 }
                 {Speichert den Verlauf in die angegebene Datei.}
          \method{load}[History]
                 {
                   \param{file}{File}{Die Datei, aus der der Verlauf geladen wird.}
                 }
                 {Lädt einen Verlauf aus der angegebenen Datei und gibt ihn zurück.}
        }
  \class{HistoryEntry}
        {Ein Eintrag im \gls{verlauf}.}
        {
          \attr{start}{Coordinates}{Der Startpunkt der Anfrage.}
          \attr{destination}{Coordinates}{Der Zielpunkt der Anfrage.}
          \attr{date}{Date}{Der Zeitpunkt der Anfrage.}
        }
        {\none}
}

\package{Util}{
  Dieses Paket enthält verschiedene nützliche Klassen, die sonst nirgendwo hingehören.
}
{
  \class{RouteKit}
        {Startet die Anwendung.}
        {\none}
        {
	\method{main}
         	    {
		\param{args}{String[]}{String-Argumente}
               }
	    {Erzeugt einen \reftype{Controller}.}
         }
  \class{Coordinates}
        {Kapselt ein Paar von geographischen Koordinaten.}
        {
          \attr{lat}{float}{Der Breitengrad der Koordinaten.}
          \attr{lon}{float}{Der Längengrad der Koordinaten.}
        }
        {
          \method{distanceTo}[float]
                 {
                   \param{other}{Coordinates}{Die anderen Koordinaten.}
                 }
                 {
                   Berechnet die Entfernung (Luftlinie, in Metern) zwischen den zwei Koordinaten.
                 }
          \method{getSmtX}[float]
                 {
                   \param{zoom}{int}{Das Zoomlevel.}
                 }
                 {
                   Berechnet die \gls{smt}-X-Komponente zu diesen Koordinaten.
                 }
          \method{getSmtY}[float]
                 {
                   \param{zoom}{int}{Das Zoomlevel.}
                 }
                 {
                   Berechnet die \gls{smt}-Y-Komponente zu diesen Koordinaten.
                 }
          \method{fromSmt}[Coordinates]
                 {
                   \param{x}{float}{Die \gls{smt}-X-Komponente.}
                   \param{y}{float}{Die \gls{smt}-Y-Komponente.}
                   \param{zoom}{int}{Die \gls{smt}-Zoom-Komponente.}
                 }
                 {
                   Statische Methode.
                   Rechnet \gls{smt}-Koordinaten in Koordinaten um.
                 }
        }
  \class{PointOnEdge}
        {Beschreibt einen Punkt auf der Kante.}
        {
          \attr{edgeid}{int}{Die eindeutige Id einer Kante.}
          \attr{pointPosition}{float}{Eine Zahl zwischen 0 und 1, die den Anteil der Strecke vom Punkt zum Ausgangsknoten von der Gesamtlänge der Kante angibt.}
        }
        {\none}
}


\section{Sequenzdiagramme}

\subsection{Programmstart}
\begin{figure}[H]
\centering
\includegraphics[angle=90, width=0.9\textwidth]{StartSequenz}
\caption{Start des Programms}
\label{fig:sequenz_start}
\end{figure}
Beteiligte Klassen: \reftype{RouteKit}, \reftype{Controller}, \reftype{MapManager}, \reftype{ProfileManager}, \reftype{ProfileMapCombination}, \reftype{RouteModel}, \reftype{MainView}, \reftype{TileCache}, \reftype{MapView}

\subsection{Rendern}
\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{RenderSequenz}
\caption{Rendern der Karte}
\label{fig:sequenz_rendern}
\end{figure}
Beteiligte Klassen: \reftype{MapView}, \reftype{TileCache}, \reftype{TileSource}

\subsection{Routenberechnung}
\begin{figure}[H]
\centering
\includegraphics[angle=90, height=\textheight]{RouteCalculationSequenz}
\caption{Berechnen der Route}
\label{fig:sequenz_routeCalculation}
\end{figure}
Beteiligte Klassen: \reftype{MainView}, \reftype{MapView}, \reftype{Controller}, \reftype{RouteModel}, \reftype{RouteCalculator}, \reftype{RouteDescription}, \reftype{Route}, \reftype{RouteDescription}

\subsection{Profilverwaltung}
\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{ProfilSequenz}
\caption{Hinzufügen und Entfernen von Profilen}
\label{fig:sequenz_profilVerwaltung}
\end{figure}
Beteiligte Klassen: \reftype{ProfileManagerView}, \reftype{ProfileManagerController}, \reftype{ProfileManager}, \reftype{MainView}


\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
