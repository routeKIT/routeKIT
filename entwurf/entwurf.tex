% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands
\usepackage{xspace} % \xspace for use in commands: put a space only if no punctuation follows
\usepackage{enumitem} % for controlling indentation in list environments

\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\newcommand{\none}[0]{
%  % see http://tex.stackexchange.com/questions/61155/linespacing-without-packages
%  \setlength\lineskiplimit{-1000pt} % allow overflowing of lines
%  \linespread{0}\selectfont % don’t advance line after empty item
  \item[] keine.
}

\makeatletter

\newcommand{\@packagelabel}[1]{P:#1}
\newcommand{\@typelabel}[1]{T:#1} % for classes and enums
\newcommand{\@attrlabel}[2]{A:#1.#2}
\newcommand{\@methodlabel}[2]{M:#1.#2}
\newcommand{\@paramlabel}[3]{P:#1.#2.#3}
\newcommand{\@constantlabel}[2]{C:#1.#2}

% evaluate #2 if the label #1 exists, else #3.
\newcommand{\ifhaslabel}[3]{%
  \@ifundefined{r@#1}%
               {#3}%
               {#2}%
}

% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Klassen (ein oder mehrere \class)
\newcommand{\package}[3]{%
  \subsection{Paket #1}\label{\@packagelabel{#1}}
  #2
  \begin{description}
    #3%
  \end{description}
}
% Argumente:
% 1. Klassenname
% 2. Beschreibung
% 3. Attribute (ein oder mehrere \attr, oder \none)
% 4. Methoden (ein oder mehrere \method, oder \none)
\newcommand{\class}[4]{%
  \newcommand{\currentclass}[0]{#1}%
  \item[\namedlabel{\@typelabel{#1}}{\code{#1}}] #2
    \ifstrequal{#3#4}{\none\none}{%
      % \none attributes and \none methods, skip
    }{%
      \begin{description}[leftmargin=0em,itemindent=0em]
        \ifstrequal{#3}{\none}{%
          % \none attributes, skip
        }{%
        \item[Attribute] \hfill % \hfill forces the following description into the next line
          \begin{description}
            #3%
          \end{description}
        }%
        \ifstrequal{#4}{\none}{%
          % \none methods, skip
        }{%
        \item[Methoden] \hfill% \hfill forces the following description into the next line
          \begin{description}
            #4%
          \end{description}
        }%
      \end{description}
    }%
  \let\currentclass=\undefined%
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\attr}[3]{%
  \item[\namedlabel{\@attrlabel{\currentclass}{#1}}{\code{#1}}] #3 Typ:~\reftype{#2}
}
% Argumente:
% 1. Name
% 2. (optional) Typ – default: void (wird nicht angezeigt); wird automatisch gelinkt, falls vorhanden
% 3. Parameter (ein oder mehrere \param, oder \none)
% 4. Beschreibung
\NewDocumentCommand{\method}{m o m +m}{% the ‘+m’ means that parameter 4 can contain several paragraphs, see http://tex.stackexchange.com/questions/64328/blank-lines-break-xparse-or-ifthen-macro
  \newcommand{\currentmethod}[0]{#1}%
  \item[\namedlabel{\@methodlabel{\currentclass}{#1}}{\code{#1}}] #4%
    \ifstrequal{#3}{\none}{%
      % \none parameters, skip
    }{%
      \\Parameter:
      \begin{description}[leftmargin=0em,itemindent=0em]
        #3%
      \end{description}
    }%
    \IfValueTF{#2}% if the optional “type” argument is given...
              { Rückgabetyp:~\reftype{#2}}% then show the return type...
              {}% else don’t.
  \let\currentmethod=\undefined%
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\param}[3]{%
  \item[\namedlabel{\@paramlabel{\currentclass}{\currentmethod}{#1}}{\code{#1}}] #3 Typ:~\reftype{#2}%
}
% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Konstanten (ein oder mehrere \constant, oder \none)
\newcommand{\enum}[3]{%
  \newcommand{\currentenum}[0]{#1}%
  \item[\namedlabel{\@typelabel{#1}}{\code{#1}}] #2
    \ifstrequal{#3}{\none}{%
      % \none cases, skip
    }{%
      Instanzen:
      \begin{description}
        #3
      \end{description}
    }%
  \let\currentenum=\undefined%
}
% Argumente:
% 1. Name
% 2. Beschreibung
\newcommand{\constant}[2]{%
  \item[\namedlabel{\@constantlabel{\currentenum}{#1}}{\code{#1}}] #2
}

\NewDocumentCommand{\refpackage}{mO{#1}}{%
  \hyperref[\@packagelabel{#1}]{\code{#2}}\xspace%
}
% Argumente:
% 1. Typ (Klasse oder Enum)
% 2. (optional) Text – default: Typ
\NewDocumentCommand{\reftype}{mO{#1}}{%
  \ifhaslabel{\@typelabel{#1}}{% if the label exists...
    \hyperref[\@typelabel{#1}]{\code{#2}}}{% then reference it...
    \code{#2}}\xspace% else just print the text.
}
% DEPRECATED
\NewDocumentCommand{\refclass}{mO{#1}}{%
  \GenericWarning{}{The command \refclass is deprecated -- use \reftype instead}%
  \reftype{#1}[#2]%
}
% Argumente:
% 1. Klasse
% 2. Attribut
% 3. (optional) Text – default: Attribut innerhalb der Klasse, sonst Klasse.Attribut
\NewDocumentCommand{\refattr}{mmO{__DEFAULT__}}{%
  \hyperref[\@attrlabel{#1}{#2}]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the attribute name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. (optional) Text – default: Methode innerhalb der Klasse, sonst Klasse.Methode
\NewDocumentCommand{\refmethod}{mmO{__DEFAULT__}}{%
  \hyperref[\@methodlabel{#1}{#2}]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the method name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. Parameter
% 4. (optional) Text – default: Parameter innerhalb der Methode, sonst Methode.Parameter innerhalb der Klasse, sonst Klasse.Methode.Parameter
\NewDocumentCommand{\refparam}{mmmO{__DEFAULT__}}{%
  \hyperref[\@paramlabel{#1}{#2}{#3}]{\code{%
      \ifthenelse{\equal{#4}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          \ifthenelse{\equal{\currentmethod}{#2}}{%
            #3% we’re inside the same method, only use the parameter name
          }{%
            #2.#3% we’re inside the same class, only use the method and parameter name
        }}{%
          #1.#2.#3%
      }}{%
        #4%
  }}}\xspace%
}
% Argumente:
% 1. Enum
% 2. Konstante
% 3. (optional) Text – default: Konstante innerhalb der Enum, sonst Enum.Konstante
\NewDocumentCommand{\refconstant}{mmO{__DEFAULT__}}{%
  \hyperref[\@constantlabel{#1}{#2}]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentenum}{#1}}{%
          #2% we’re inside the same enum, only use the constant name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}


\makeatother

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{%
  \glsdoifexists{#2}{%
    \def\@glsnumberformat{glsgobblenumber}%
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}%
    \setkeys{glossadd}{#1}%
    \@gls@saveentrycounter%
    \@do@wrglossary{#2}%
  }%
}
\newcommand{\glsaddallunused}[1][]{%
  \edef\@glo@type{\@glo@types}%
  \setkeys{glossadd}{#1}%
  \forallglsentries[\@glo@type]{\@glo@entry}{%
    \ifglsused{\@glo@entry}{}{%
      \typeout{****Glossary entry '\@glo@entry' unused****}%
      \glsaddnp[#1]{\@glo@entry}}}%
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

\makeatletter

\begin{document}
\shorthandoff{"}

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\emph{routeKIT}\xspace}


% alle Glossareinträge
\newglossaryentry{profil}{
  name={Profil},
  description={enthält für die Routenplanung relevante Informationen, z.\,B. die Höhe und das Gewicht des Fahrzeugs},
  plural={Profile}
}
\newglossaryentry{karte}{
  name={Karte},
  description={enthält die Daten aus \gls{osm} sowie einen Namen},
  plural={Karten}
}
\newglossaryentry{osmkachel}{
  name={OSM-Kachel},
  description={die öffentlichen gerenderten \gls{osm}-Kacheln z.\,B. auf\\\mbox{\url{http://a.tile.openstreetmap.org/}}},
  plural={OSM-Kacheln}
}
\newglossaryentry{route}{
  name={Route},
  description={ein Weg von einem Start- zu einem Zielpunkt},
  plural={Routen}
}
\newglossaryentry{vorberechnung}{
  name={Vorberechnung},
  description={verbindet die \gls{karte} mit den auf einem \gls{profil} basierenden Informationen und ermöglicht, unter anderem mittels \gls{arc}, später eine Beschleunigung der Berechnung einer \gls{route}; muss für jede neue \gls{karte}/\gls{profil}-Kombination einmal ausgeführt werden},
  plural={Vorberechnungen},
  see={arc}
}
\newglossaryentry{rendern}{
  name={rendern},
  description={Berechnung einer Bildkachel aus den zu rendernden Daten}
}
\newglossaryentry{wegbeschreibung}{
  name={Wegbeschreibung},
  description={Beschreibung einer \gls{route} durch eine Liste von Abbiegeanweisungen}
}
\newglossaryentry{dijkstra}{
  name={Dijkstra’s Algorithmus},
  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
}
\newglossaryentry{arc}{
 name={Arc-Flags},
 description={eine Technik, um eine Routenberechnung zu beschleunigen}
}
\newglossaryentry{verlauf}{
  name={Verlauf},
  description={speichert Routenanfragen für spätere Wiederverwendung. Es existiert nur ein Verlauf für die gesamte Anwendung}
}
\newglossaryentry{mercator}{
  name={Mercator-Projektion},
  description={die Zylinderprojektion der Weltkugel}
}
\newglossaryentry{entwurfsmuster}{
  name={Entwurfsmuster},
  description={Eine Schablone, die eine Lösung für ein oder mehrere Entwurfsprobleme darstellt. Ihre Verwendung erleichtert Änderungen im Entwurf.}
}
\newglossaryentry{beobachter}{
  name={Beobachter},
  description={Ein \gls{entwurfsmuster}, das bei Änderung des Zustands eines Objektes alle abhängenden Objekte banachrichtigt.}
}
\newglossaryentry{einzelstück}{
  name={Einzelstück},
  description={Ein \gls{entwurfsmuster}, das zusichert, dass eine Klasse genau ein Exemplar besitzt und stellt einen globalen Zugriffspunkt darauf bereit.}
}
\newglossaryentry{dekorierer}{
  name={Dekorierer},
  description={Ein \gls{entwurfsmuster}, das dynamisch neue Funktionalität zum Objekt hinzufügt.}
}
\newglossaryentry{strategie}{
  name={Strategie},
  description={Ein \gls{entwurfsmuster}, das eine Familie von Algorithmen definiert, sie kapselt und austauschbar macht.}
}
\newglossaryentry{G_smt}{
  name={Slippy Map Tile},
  description={
    Koordinaten, durch die Kartenkacheln einer graphischen Darstellung (mit \gls{mercator}) adressiert werden können.
    Drei Bestandteile: x, y, zoom.
    Mit nicht-ganzzahligen Werten für x und y können nicht nur Kacheln, sondern auch Geokoordinaten adressiert werden}
}
\newglossaryentry{smt}{
  type=\acronymtype,
  name={SMT},
  description={Slippy Map Tile},
  first={Slippy Map Tile (SMT)},
  see=[Glossareintrag:]{G_smt}
}
\newglossaryentry{opaque}{
  name={deckend},
  description={
    Die innere Implementierung wird vor anderen Klassen verborgen; Zugriff ist nur über das definierte Interface der Klasse/Methode möglich. (engl. “opaque”)}
}

\newacronym[longplural=Personenkraftwagen]{pkw}{PKW}{Personenkraftwagen}
\newacronym[longplural=Lastkraftwagen]{lkw}{LKW}{Lastkraftwagen}
\newacronym{osm}{OSM}{OpenStreetMap}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{gpx}{GPX}{GPS Exchange Format}
\newacronym{mvc}{MVC}{Model View Controller}



\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Entwurfsdokument}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage


\section{Einleitung}

Dieses Dokument erläutert den Entwurf der Anwendung \routeKIT. % TODO „dieses Dokument dokumentiert“ (gemacht)
Es beschreibt ausführlich die verwendeten Pakete, Klassen und Methoden und ihre Beziehungen untereinander (wobei die Beziehungen im Klassendiagramm deutlicher ersichtlich sind).

\routeKIT ist eine Anwendung zur Routenplanung; durch Verwendung von \glslink{profil}{Profilen} kann sie dem Benutzer die optimalen \glspl{route} für sein spezielles Fahrzeug angeben.
Um die Routenberechnung zu beschleunigen, wird pro \gls{profil} und \gls{karte} eine zeitaufwändige \gls{vorberechnung} durchgeführt.


\section{Übersicht}

Beim Entwurf der Anwendung \routeKIT wurden \gls{entwurfsmuster} eingesetzt.
Das Muster \gls{mvc} umfasst die Pakete \refpackage{Controllers}, \refpackage{Models} und \refpackage{Views}, wobei die Klassen in \refpackage{Controllers} die Kommunikation zwischen den Klassen in \refpackage{Views} und den funktionalem Teil des Programms übernehmen.
Das Anfordern der Kacheln aus dem Paket \refpackage{MapDisplay} erfolgt von der Klasse \reftype{MapView} direkt (ohne Einsatz von Controllern).
Die Klassen in \refpackage{Views} sind für die Interaktion des Benutzers mit den Programm und die Darstellung der Daten aus dem Paket \refpackage{Models} zuständig.
Die Bekanntgabe von Änderungen an relevanten Daten im Modell geschieht nach dem \gls{entwurfsmuster} \gls{beobachter}.
Durch den Einsatz vom \gls{entwurfsmuster} \gls{mvc} ist das Paket \refpackage{Views} leicht austauschbar.
Die Klassen \reftype{Controller}, \reftype{ProfileManager}, \reftype{MapManager} im Paket \refpackage{Controllers} basieren auf dem \gls{entwurfsmuster} \gls{einzelstück}. % TODO nein? ManagerController werden immer wieder erstellt – Lucas (gemacht, stimmt hab mich vertan)

Im Paket \refpackage{MapDisplay} wird das \gls{entwurfsmuster} \gls{dekorierer} verwendet.
Der Cache baut dabei eine Kapselung für einen effizienteren Zugriff um eine Kachelquelle herum.
Dadurch wird die Funktionaltät, dass ältere Zugriffe gespeichert werden, von der Funktion, die Kacheln zu beschaffen, abgetrennt.
Es wird außerdem das \gls{entwurfsmuster} \gls{beobachter} verwendet, wobei \reftype{TileFinishedListener} der Beobachter ist. Die genauere Funktionsweise wird in \refpackage{MapDisplay} erläutert.

% TODO Vorteile davon. (gemacht)

Im Paket \refpackage{RouteCalculator} wird das  \gls{entwurfsmuster} „\gls{strategie}“ eingesetzt.
Der Algorithmus zur Berechnung der \gls{route} ist in eine eigene Klasse \reftype{ArcFlagsDijkstra} gekapselt und somit leicht zu ersetzen.  
Im Paket \refpackage{Precalculation} wird ebenfalls dieses Muster verwendet. Somit wird ermöglicht das Programm zum Partitionieren eines Graphen auszutauschen.

\section{Anmerkungen}

\begin{itemize}
\item Für Attribute, die im Klassendiagramm durch Relationen oder explizit angegeben sind, sind implizite Getter und Setter gegeben.
\item Die folgenden Typen aus dem Klassendiagramm sind „typedefs“, keine echten Klassen:
  \begin{itemize}
  \item \code{Node}: \code{int}, die ID des Knotens
  \item \code{Edge}: \code{int}, die ID der Kante
  \item \code{Turn}: \code{int}, die ID der Kante im kantenbasierten Graphen (\reftype{EdgeBasedGraph})
  \item \code{Partition}: \code{int}, die ID einer Partition
  \end{itemize}
\end{itemize}


\section{Legende}

\package{BeispielPaket}{
  Dies ist ein Paket.
  Es enthält eine kurze Beschreibung und dann mehrere Klassen.
}
{
  \class{BeispielKlasse}
        {
          Dies ist eine Klasse.
          Sie kann Attribute und Methoden enthalten.
        }
        {
          \attr{beispielAttribut}{Typ}{Dies ist ein Attribut.}
        }
        {
          \method{beispielMethode}[Rückgabetyp]
                 {
                   \param{beispielParameter}{Typ}{Dies ist ein Parameter der Methode.}
                 }
                 {
                   Dies ist eine Methode.
                   Sie kann mehrere Parameter enthalten und einen Wert eines bestimmten Typs zurückgeben.
                 }
        }
}
Bezeichner und weiterer Code sind in \code{dicktengleicher Schrift} gesetzt.


\section{Pakete und Klassen}

\package{Controllers}{
 Dieses Paket enthält die Controller aus der \gls{mvc}-Architektur.
 Die Controller übernehmen die Steuerung des Programms und regeln die Kommunikation unter den einzelnen Komponenten.
 Der \reftype{Controller} nimmt Benutzeraktionen von der \reftype{MainView} und \reftype{MapView} entgegen und reagiert darauf.
 
 Der \reftype{Controller} erstellt den \reftype{ProfileManagerController} bzw. den \reftype{MapManagerController}, wenn der Benutzer das Fenster der \gls{profil}- bzw. Kartenverwaltung öffnet.
 Diese sind für \reftype{ProfileManagerView} bzw. die \reftype{MapManagerView} verantwortlich.

 Der \reftype{ProfileManager} und der \reftype{MapManager} sind für das Speichern und Laden der \gls{profil}- oder Kartendaten zuständig.

}
{
  \class{Controller}
        {
          Der Haupt-Controller von \routeKIT.
          Er wird beim Programmstart erstellt und erstellt dabei die \reftype{MainView}.
          Er verwaltet den gesamtem Programmablauf und bleibt so lange bestehen, bis \routeKIT beendet wird.
        }
        {\none}
        {
          \method{Controller}
                 {\none}
                 {
                   Erstellt den Controller, lädt \glspl{profil} und \glspl{karte} und erstellt dann die \reftype{MainView}.
                   Für den genauen Ablauf siehe \abbildung{sequenz_start}.
                 }
                 
          \method{onStartChanged}
                 {
                   \param{start}{Coordinates}{Die Koordinaten des neuen Startpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Startpunkt ändert (z.\,B. durch eine Eingabe des Benutzers).
                   Setzt den neuen Startpunkt in der \reftype{MapView}.
                   Falls bereits ein Zielpunkt ausgewählt ist, wird außerdem ein neuer Eintrag zum \gls{verlauf} hinzugefügt (siehe \refmethod{History}{addEntry}) und die Routenberechnung gestartet.
                 }
          \method{onDestinationChanged}
                 {
                   \param{destination}{Coordinates}{Die Koordinaten des neuen Zielpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Zielpunkt ändert (z.\,B. durch eine Eingabe des Benutzers).
                   Setzt den neuen Zielpunkt in der \reftype{MapView}.
                   Falls bereits ein Startpunkt ausgewählt ist, wird außerdem ein neuer Eintrag zum \gls{verlauf} hinzugefügt (siehe \refmethod{History}{addEntry}) und die Routenberechnung gestartet.
                 }
          \method{onStartAndDestChanged}
                 {
                   \param{start}{Coordinates}{Die Koordinaten des neuen Startpunkts.}
                   \param{destination}{Coordinates}{Die Koordinaten des neuen Zielpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Start- und Zielpunkt ändern (z.\,B. durch die Auswahl eines Eintrags aus dem \gls{verlauf}).
                   Die gleichen Aktionen wie für \refmethod{Controller}{onStartChanged} und \refmethod{Controller}{onDestinationChanged} werden ausgeführt, nur nicht doppelt.
                 }
                 
          \method{exportGPX}
                 {
                   \param{target}{File}{Die Datei, in die die \gls{route} gespeichert werden soll.}
                 }
                 {
                   Speichert die aktuelle \gls{route} im \gls{gpx}-Format in die angegebene Datei.
                   Ist keine aktuelle \gls{route} verfügbar (z.\,B. da noch keine \gls{vorberechnung} vorliegt), so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{exportHTML}
                 {
                   \param{target}{File}{Die Datei, in die die \gls{wegbeschreibung} gespeichert werden soll.}
                 }
                 {
                   Speichert die \gls{wegbeschreibung} der aktuellen \gls{route} im HTML-Format in die angegeben Datei.
                   Ist keine aktuelle \gls{route} verfügbar (z.\,B. da noch keine \gls{vorberechnung} vorliegt), so wird eine \code{IllegalStateException} geworfen.
                 }
                 
          \method{selectProfile}
                 {
                   \param{profile}{Profile}{Das aktuelle \gls{profil}.} 
                 }
                 {
                   Wählt das angegebene \gls{profil} aus.
                 }
          \method{selectMap}
                 {
                   \param{map}{StreetMap}{Die aktuelle \gls{karte}.} 
                 }
                 {
                   Wählt die angegebene \gls{karte} aus.
                 }

          \method{startPrecalculation}
                 {
                   \param{combination}{ProfileMapCombination}{Eine nicht vorberechnete Kombination aus \gls{profil} und \gls{karte}.} 
                 }
                 {
                   Ruft \refmethod{PreCalculator}{doPrecalculation} auf, falls keine \gls{vorberechnung} für diese Kombination aus \gls{profil} und \gls{karte} existiert.
                 }
                 
		  \method{onPrecalculationFinished}
                 {\none}
                 {
                   Wird aufgerufen, wenn eine \gls{vorberechnung} abgeschlossen ist. Reaktiviert Benutzerinteraktion mit der mainView.
                 }

          \method{setUseOnlineMaps}
                 {
                   \param{useOnlineMaps}{boolean}{\code{true}, um \glspl{osmkachel} zu verwenden, \code{false}, um selbst gerenderte Kacheln zu verwenden.}
                 }
                 {
                   Legt fest, ob \glspl{osmkachel} oder selbst gerenderte Kacheln verwendet werden sollen.
                   Für \glspl{osmkachel} wird der \reftype{OSMRenderer} verwendet, für die eigenen Kacheln der \reftype{TileRenderer}.
                 }
          \method{getTileSource}[TileSource]
                 {\none}
                 {
                   Gibt eine \reftype{TileSource} zurück, die zum \glslink{rendern}{Rendern} der \glspl{karte} verwendet werden soll.
                 }
          \method{manageProfiles}
                 {\none}
                 {
                   Startet einen neuen \reftype{ProfileManagerController} und öffnet so den Dialog zur Profilverwaltung.
                 }
          \method{manageMaps}
                 {\none}
                 {
                   Startet einen neuen \reftype{MapManagerController} und öffnet so den Dialog zur Kartenverwaltung.
                 }
          \method{main}
                 {
		           \param{args}{String[]}{Kommandozeilen-Argumente.}
                 }
	             {Statische Hauptmethode des Programms. Erzeugt einen \reftype{Controller}.}
        }

  \class{ProfileManagerController}
        {
          Der Controller für die \reftype{ProfileManagerView}.

	  Ein Beispiel für die Kommunikation zwischen den beiden Klassen ist in \abbildung{sequenz_profilVerwaltung} zu sehen.
        }
        {\none}
        {
          \method{saveTemporaryProfile}
                 {
                   \param{profile}{Profile}{Das temporäre \gls{profil} mit den aktuell eingegebenen Werten.}
                 }
                 {
                   Speichert die Werte des temporären \glslink{profil}{Profils}.
                   Wird üblicherweise direkt vor \refmethod{ProfileManagerController}{changeTemporaryProfile} aufgerufen.
                 }
          \method{changeTemporaryProfile}
                 {
                   \param{name}{String}{Der Name des neuen \glslink{profil}{Profils}.}
                 }
                 {
                   Wechselt zu dem temporären \gls{profil} mit dem angegebenen Namen.
                   Falls noch kein \gls{profil} mit diesem Namen existiert, wird es als Kopie des aktuellen \glslink{profil}{Profils} erstellt.
                   
                   Die Änderung wird der View über \refmethod{ProfileManagerView}{setCurrentProfile} mitgeteilt.
                 }
          \method{deleteCurrentTemporaryProfile}
                 {\none}
                 {
                   Markiert das aktuell ausgewählte \gls{profil} zur Löschung und entfernt es aus der Auswahlliste.
                   
                   Beachte: Das \gls{profil} wird erst in \refmethod{ProfileManagerController}{saveAllChanges} tatsächlich gelöscht.
                   
                   Handelt es sich bei dem aktuell ausgewählten \gls{profil} um ein Standardprofil, so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{getDeletionTime}[int]
                 {\none}
                 {
                   Gibt zurück, wie lange die \glspl{vorberechnung} benötigten, die durch die aktuell erfassten Änderungen gelöscht werden.
                   Die geschätzte Dauer wird in Millisekunden zurückgegeben.
                 }
          \method{saveAllChanges}
                 {\none}
                 {
                   Führt alle vom Benutzer vorgenommenen Änderungen aus.
                   Dazu gehören das Hinzufügen, Ändern und Löschen von \glslink{profil}{Profilen}.
                   Für geänderte \glspl{profil} werden alle \glspl{vorberechnung} gelöscht. 
                 }
        }
  \class{MapManagerController}
        {
          Der Controller für die \reftype{MapManagerView}.
        }
        {\none}
        {
          \method{changeMap}
                 {
                   \param{map}{StreetMap}{Die neue \gls{karte}.}
                 }
                 {
                   Wird aufgerufen, wenn in der \reftype{MapManagerView} eine andere \gls{karte} ausgewählt wird.
                   Speichert die Liste der \glspl{profil} für diese \gls{karte} und setzt sie auf die Liste der neuen \gls{karte} (ggf. die bereits gespeicherte Liste, falls die \gls{karte} schon zuvor einmal ausgewählt war).
                   Aktiviert/Deaktiviert den Löschen-Button, je nachdem, ob die neue \gls{karte} eine Standardkarte ist oder nicht.
                 }
          \method{addProfile}
                 {
                   \param{profile}{Profile}{Das neue \gls{profil}.}
                 }
                 {
                   Fügt das angegebene \gls{profil} zur ausgewählten \gls{karte} hinzu.
                 }
          \method{removeProfile}
                 {
                   \param{profile}{Profile}{Das \gls{profil}, das entfernt werden soll.}
                 }
                 {
                   Entfernt das angegebene \gls{profil} von der ausgewählten \gls{karte}.
                 }
          \method{importMap}
                 {
                   \param{name}{String}{Der Name der neuen \gls{karte}.}
                   \param{file}{File}{Die Datei aus der sie geladen werden soll.}
                 }
                 {
                   Fügt eine neue \gls{karte} mit dem angegebenen Namen hinzu (oder ersetzt eine bestehende mit diesem Namen) und wählt sie aus.

                   Beachte: Die \gls{gui}-Aktionen „Importieren“ und „Aktualisieren“ werden beide durch diese Methode implementiert;
                   bei „Importieren“ stellt die \gls{gui} sicher, dass kein bereits existierender Name gewählt wird,
                   bei „Aktualisieren“ verwendet sie den Namen der existierenden \gls{karte}.
                 }
          \method{deleteCurrentMap}
                 {\none}
                 {
                   Markiert die aktuell ausgewählte \gls{karte} zur Löschung und entfernt sie aus der Auswahlliste.
                   
                   Beachte: Die \gls{karte} wird erst in \refmethod{MapManagerController}{saveAllChanges} tatsächlich gelöscht.
                   
                   Handelt es sich bei der aktuell ausgewählten \gls{karte} um eine Standardkarte, so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{saveAllChanges}
                 {\none}
                 {
                   Führt alle vom Benutzer vorgenommenen Änderungen aus.
                   Dazu gehören das Importieren und Löschen von \glspl{karte} sowie das Hinzufügen oder Löschen von \glslink{profil}{Profilen} je \gls{karte}.
                 }
        }
\class{ProfileManager}
        {Verwaltet die \glspl{profil}. Hat intern eine Menge von vorhandenen \glslink{profil}{Profilen}.}
        {\none}
        {
          \method{saveProfile}
                 {
                   \param{profile}{Profile}{Das \gls{profil}, das gespeichert werden soll.}
                 }
                 {
                   Speichert das ausgewählte \gls{profil} in der internen Liste und auf der Festplatte.
                   
                   (Der Speicherort wird vom Manager \gls{opaque} verwaltet.)
                 }
          \method{deleteProfile}
                 {
                   \param{profile}{Profile}{Das \gls{profil}, das gelöscht werden soll.}
                 }
                 {
                   Löscht das ausgewählte \gls{profil} aus der internen Liste und von der Festplatte.
                 }
          \method{getProfiles}[Set<Profile>]
                 {\none}
                 {
                   Gibt alle \glspl{profil} in der internen Liste zurück.
                 }
        }
  \class{MapManager}
        {Verwaltet die Kartendaten. Hat intern eine Menge von vorhandenen Kartendaten.}
        {\none}
        {
          \method{saveMap}
                 {
                   \param{map}{StreetMap}{Die \gls{karte}, die gespeichert werden soll.}
                 }
                 {
                   Speichert die ausgewählte \gls{karte} in der internen Liste und auf der Festplatte.

                   (Der Speicherort wird vom Manager \gls{opaque} verwaltet.)
                 }
          \method{deleteMap}
                 {
                   \param{map}{StreetMap}{Die \gls{karte}, die gelöscht werden soll.}
                 }
                 {
                   Löscht die ausgewählte \gls{karte} aus der internen Liste und von der Festplatte (die \gls{osm}-Datei, den Graphen und alle \glspl{vorberechnung}).
                 }
          \method{getMaps}[Set<StreetMap>]
                 {\none}
                 {
                   Gibt alle \glspl{karte} in der internen Liste zurück.
                 }
        }

}

\package{Precalculation}{
  Dieses Paket enthält alle Klassen, die an der \gls{vorberechnung} beteiligt sind oder für den Import einer \gls{karte} benötigt werden.
  Beim Importieren einer \gls{karte} werden ein knotenbasierter und ein kantenbasierter Graph aufgebaut und der kantenbasierte Graph wird partitioniert.
  Bei der \gls{vorberechnung} wird der kantenbasierte Graph gewichtet vom \reftype{EdgeWeighter} und danach werden die \gls{arc} vom \reftype{ArcFlagsCalculator} berechnet.
  % TODO kurze erklärung, wie die vorberechnung läuft (gemacht)
}
{
  \class{MapImporter}
        {Stellt die Funktionalität zum Importieren einer neuen \gls{karte} bereit.}
        {\none}
        {
          \method{importMap}[StreetMap]
                 {
                   \param{file}{File}{Die \gls{osm}-Datei, aus der die Kartendaten importiert werden sollen.}
                   \param{name}{String}{Der Name der neuen \reftype{StreetMap}.}
                 }
                 {Importiert eine neue \gls{karte} aus der angegebenen \gls{osm}-Datei. Die vom \reftype{OSMParser} aufgebaute Graphdatenstruktur wird dabei vom \reftype{GraphPartitioner} partitioniert und zurückgegeben.}
        }
  \class{OSMParser}
        {Stellt die Funktionalität zum Parsen einer \gls{osm}-Datei bereit. Dafür werden zur temporären Repräsentation des Graphen im Speicher die Klassen \reftype{MapNode}, \reftype{MapEdge} und \reftype{TurnRestriction} verwendet.}
        {\none}
        {
          \method{parseOSM}[StreetMap]
                 {
                   \param{file}{File}{Die \gls{osm}-Datei, die eingelesen werden soll.}
                   \param{name}{String}{Der Name der neuen \reftype{StreetMap}.}
                 }
                 {Liest eine \gls{osm}-Datei ein und erzeugt daraus einen \reftype{Graph} sowie den zugehörigen (unpartitionierten) \reftype{EdgeBasedGraph} und gibt diese als \reftype{StreetMap} zurück.}
        }
  \class{MapNode}
        {Stellt einen Knoten im Straßengraphen dar. Dies ist nur eine vom \reftype{OSMParser} verwendete Zwischendarstellung.}
        {
          \attr{lat}{float}{Der Längengrad des Knotens.}
          \attr{lon}{float}{Der Breitengrad des Knotens.}
        }
        {
          \method{getOutgoingEdges}[Set<MapEdge>]
                 {\none}
                 {Gibt eine Liste mit allen ausgehenden Kanten des Knotens zurück.}
        }
  \class{MapEdge}
        {Stellt eine Kante im Straßengraphen dar. Dies ist nur eine vom \reftype{OSMParser} verwendete Zwischendarstellung.}
        {\none}
        {\none}
  \class{TurnRestriction}
        {Stellt eine Abbiegebeschränkung dar. Dies ist nur eine vom \reftype{OSMParser} verwendete Zwischendarstellung.}
        {\none}
        {\none}
  \class{GraphPartitioner}
        {Partitioniert einen gegebenen Graphen.}
        {\none}
        {
          \method{partitionGraph}
                 {
                   \param{graph}{EdgeBasedGraph}{Der zu partitionierende Graph.}
                   \param{numberOfPartitions}{int}{Die gewünschte Anzahl an Partitionen.}
                 }
                 {
                   Teilt den Graphen in die gewünschte Anzahl an Partitionen.
                   
                   Die ermittelten Partitionen werden über \refmethod{EdgeBasedGraph}{setPartitions} direkt gesetzt.
                 }
        }
        
  \class{ExternalPartitionerAdapter}
        {Leitet die Partitionierungsanfrage an ein externes Partitionierungsprogramm weiter.}
        {\none}
        {
          \method{partitionGraph}
                 {
                   \param{graph}{EdgeBasedGraph}{Der zu partitionierende Graph.}
                   \param{numberOfPartitions}{int}{Die gewünschte Anzahl an Partitionen.}
                 }
                 {Lässt den Graphen durch das externe Programm in die gewünschte Anzahl an Partitionen teilen.}
        }
              
  \class{PreCalculator}
        {Führt die \gls{vorberechnung} für eine Kombination aus \reftype{Profile}[Profil] und \reftype{StreetMap}[Karte] durch.}
        {\none}
        {
          \method{doPrecalculation}
                 {
                   \param{comb}{ProfileMapCombination}{Die Kombination aus \reftype{Profile}[Profil] und \reftype{StreetMap}[Karte], für die die \gls{vorberechnung} durchgeführt werden soll.}
                 }
                 {
                   Führt die \gls{vorberechnung} für die gegebene Kombination aus \reftype{Profile}[Profil] und \reftype{StreetMap}[Karte] durch.
                   Dabei werden ein \reftype{EdgeWeighter} und ein \reftype{ArcFlagsCalculator} aufgerufen.
                   Die benötigte Zeit wird in \refattr{ProfileMapCombination}{calculationTime} gespeichert.
                 }
        }
        
  \class{EdgeWeighter}
        {
          Versieht den kantenbasierten Graphen (\reftype{EdgeBasedGraph}) mit Kantengewichten.
          
          Die Kantengewichte des kantenbasierten Graphen sind profilabhängig und geben an, wie „teuer“ ein bestimmter Abbiegevorgang ist – Kanten mit niedrigerem Gewicht werden bei der Routenberechnung bevorzugt gewählt.
          Abbiegebeschränkungen werden durch maximale Kantengewichte umgesetzt.
        }
        {\none}
        {
          \method{weightEdges}
                 {
                   \param{combination}{ProfileMapCombination}{Die zu gewichtende Kombination aus \gls{profil} und \gls{karte}.}
                 }
                 {
                   Berechnet die Kantengewichte für die angegebene Kombination und setzt die \reftype{Weights} von \refparam{EdgeWeighter}{weightEdges}{combination} entsprechend.
                 }
        }
        
  \class{ArcFlagsCalculator}
        {Berechnet \gls{arc} für einen partitionierten, gewichteten Graphen.}
        {\none}
        {
          \method{calculateArcFlags}
                 {
                   \param{combination}{ProfileMapCombination}{Die Kombination aus \gls{profil} und \gls{karte}.}
                 }
                 {
                   Berechnet die \gls{arc} für die angegebene Kombination und setzt die \reftype{ArcFlags} von \refparam{ArcFlagsCalculator}{calculateArcFlags}{combination} entsprechend.
                 }
        }
}

\package{RouteCalculator}{
 Dieses Paket enthält alle Klassen, die zur Routenberechnung unter Berücksichtigung von \gls{arc} und Erzeugung der \gls{wegbeschreibung} benötigt werden.
}
{
  \class{RouteCalculator}
        {Stellt ein Interface für einen Algorithmus zur Routenberechnung bereit.}
        {\none}
        {
          \method{calculateRoute}[Route]
                 {
                   \param{start}{PointOnEdge}{Der Startpunkt für die Routenberechnung.}
                   \param{destination}{PointOnEdge}{Der Zielpunkt für die Routenberechnung.}
                   \param{data}{ProfileMapCombination}{Der vorberechnete Graph auf dem die Routenberechnung durchgeführt wird.}
                 }
                 {Berechnet einen Weg vom Startpunkt zum Zielpunkt auf dem gegebenen Graphen.}
        }
  \class{ArcFlagsDijkstra}
        {
          Verwendet \gls{dijkstra}, um die schnellste \gls{route} zwischen Start- und Zielpunkt für die aktuelle Kombination aus \gls{karte} und \gls{profil} zu berechnen.
          Durch \gls{arc} wird die Berechnung beschleunigt.
        }
        {\none}
        {\none}
  \class{Route}
        {Repräsentiert eine berechnete \gls{route}.}
        {
          \attr{start}{PointOnEdge}{Der Startpunkt der \gls{route}.}
          \attr{destination}{PointOnEdge}{Der Zielpunkt der \gls{route}.}
        }
        {
          \method{getTurns}[List<Turn>]
                 {\none}
                 {Liefert eine Liste der Abbiegevorgänge, aus denen die \gls{route} besteht.}
          \method{getNodeIterator}[Iterator<Node>]
                 {\none}
                 {Gibt einen Iterator über die Knoten (\code{Node}) der \gls{route} einschließlich Start- und Zielpunkt zurück. Der Iterator ermittelt diese dynamisch aus der Liste der Abbiegevorgänge.}
        }
  \class{RouteDescriptionGenerator}
        {Stellt die Funktionalität zur Erzeugung einer \gls{wegbeschreibung} bereit.}
        {\none}
        {
          \method{generateRouteDescription}[RouteDescription]
                 {
                   \param{route}{Route}{Die \gls{route}, deren Beschreibung erzeugt werden soll.}
                 }
                 {Erzeugt die zur \refparam{RouteDescriptionGenerator}{generateRouteDescription}{route} gehörende \gls{wegbeschreibung}.}
        }
  \class{RouteDescription}
        {Kapselt die zu einer \reftype{Route} gehörende \gls{wegbeschreibung}.}
        {\none}
        {
          \method{getInstructions}[List<TurnInstruction>]
                 {\none}
                 {Liefert eine Liste der Abbiegeanweisungen.}
        }
  \class{TurnInstruction}
        {Kapselt eine einzelne Abbiegeanweisung, aus welchen eine \reftype{RouteDescription} aufgebaut ist.}
        {\none}
        {
          \method{toString}[String]
                 {\none}
                 {Gibt den Text der Abbiegeanweisung zurück.}
        }
}

\package{MapDisplay}{
  Dieses Paket enthält alle Klassen, die an der Darstellung der \gls{karte} im \gls{gui} beteiligt sind.
  
  Die zentrale Klasse dieses Pakets ist der \reftype{TileCache}, der dafür sorgt, dass Kartenkacheln nicht jedes Mal neu berechnet werden müssen.
  Er berechnet selbst keine Kacheln, sondern erhält diese von einer untergeordneten \reftype{TileSource}, welche die Kacheln synchron berechnet.
  Der Cache stellt diese Kacheln dann asynchron bereit, indem er für nicht gespeicherte Kacheln zunächst eine „Dummy-Kachel“ zurückgibt und bei abgeschlossener Berechnung registrierte \reftype{TileFinishedListener} benachrichtigt.
  Ein beispielhafter Ablauf ist in \abbildung{sequenz_rendern} zu sehen.
  
  Um nicht zu viel Arbeitsspeicher zu beanspruchen, verwaltet der Cache die gespeicherten Kacheln so, dass sie bei Speicherknappheit vom Garbage Collector der JVM freigegeben werden können.
  
  Kartenkacheln werden über \gls{G_smt}-Koordinaten, wie sie auch bei anderen \gls{osm}-Viewern verwendet werden, adressiert.
}
{
 \class{TileSource}
        {Abstrakte Klasse, die ein Interface für das (synchrone) \Gls{rendern} von Kartenkacheln definiert.}
        {\none}
        {
          \method{renderTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{renderTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{renderTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{renderTile}{zoom}}
                 }
                 {Berechnet die angegebene Kachel und gibt sie zurück.}
        }
  \class{TileCache}
        {
          Verwaltet die Berechnung von Kartenkacheln und ist ein Zwischenspeicher für diese.
          Kacheln können angefragt werden, und nachdem die (asynchrone) Berechnung abgeschlossen ist, werden registrierte \reftype{TileFinishedListener} benachrichtigt.
          
          Intern werden die zwischengespeicherten Kacheln so gehalten, dass der Garbage Collector sie bei Speicherknappheit verwerfen kann (etwa durch \code{SoftReference}s).
        }
        {\none}
        {
          \method{TileCache}
                 {\param{target}{TileSource}{Die \code{TileSource}, die die tatsächliche Berechnung durchführt und deren Ergebnisse zwischengespeichert werden.}}
                 {Erstellt einen neuen Cache für die angegebene \reftype{TileSource}.}
          \method{renderTile}[BufferedImage]
                 {
                   \param{x}{int}{Die \gls{smt}-X-Komponente.}
                   \param{y}{int}{Die \gls{smt}-Y-Komponente.}
                   \param{zoom}{int}{Die Zoomstufe.}
                 }
                 {
                   Ist die angeforderte Kachel bereits im Zwischenspeicher vorhanden, so wird sie direkt zurückgegeben;
                   andernfalls wird eine Dummy-Kachel zurückgegeben und die richtige von \refparam{TileCache}{TileCache}{target} angefordert, im Zwischenspeicher gespeichert und dann zurückgegeben. Kacheln von tieferer Zoomstufe und der Umgebung einer Kachel werden von \refparam{TileCache}{TileCache}{target} angefordert und im Zwischenspeicher gespeichert.
                 }

 \method{addTileFinishedListener}
                 {
                   \param{listener}{TileFinishedListener}{Der Listener, der hinzugefügt werden soll.}
                 }
                 {
                   Registriert einen \reftype{TileFinishedListener}, der benachrichtigt wird, wenn eine Kachel fertig berechnet ist.
                   Die Kachel ist Teil der Nachricht.
                 }
}
  \class{TileFinishedListener}
        {Wird benachrichtigt, wenn die Berechnung einer Kartenkachel abgeschlossen ist.}
        {\none}
        {
          \method{tileFinished}
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{renderTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{renderTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{renderTile}{zoom}}
                   \param{tile}{BufferedImage}{Die berechnete Kachel.}
                 }
                 {
                   Wird vom \reftype{TileCache} aufgerufen, wenn die Berechnung einer Kachel abgeschlossen ist.
                   Die übliche Aktion ist, ein \code{repaint} der Kartenansicht im \gls{gui} auszulösen.
                 }
        }
 
  \class{TileRenderer}
        {Eine \reftype{TileSource}, die die Kacheln selbst berechnet.}
        {\none}
        {
          \method{TileRenderer}
	   { 
		\param{graph}{Graph}{Ein Adjazenzfeld.}
	    }
	   {Ein Konstruktor, der einen neuen TileRenderer erzeugt.}
          \method{renderTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{renderTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{renderTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{renderTile}{zoom}}
                 }
                 {Berechnet die angegebene Kachel und gibt sie zurück.}
        }
  \class{OSMRenderer}
        {Eine \reftype{TileSource}, die die \glspl{osmkachel} vom OpenStreetMap-Server herunterlädt.}
        {\none}
        {
          \method{renderTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{renderTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{renderTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{renderTile}{zoom}}
                 }
                 {Lädt die angegebene Kachel herunter und gibt sie zurück.}
        }
}

\package{Models} {
Dieses Paket enthält die Models aus der \gls{mvc}-Architektur. 
}
{  \class{ProfileMapCombination}
        {Eine Kombination aus einem \reftype{Profile}[Profil] und einer \reftype{StreetMap}[Karte].}
        {
          \attr{profile}{Profile}{Das \gls{profil}.}
          \attr{map}{StreetMap}{Die \gls{karte}.}
          \attr{calculationTime}{int}{
            Die Zeit, die für die Vorberechnung dieser Kombination benötigt wurde.
            Die Zeit wird in Millisekunden angegeben.
            Für Kombinationen ohne \gls{vorberechnung} ist dieser Wert \code{0}.
          }
        }
        {
	\method{isCalculated}[boolean]
         	    {\none}
	    {Gibt \code{true} zurück, wenn für eine Kombination aus \gls{profil} und \gls{karte} eine \gls{vorberechnung} der Gewichte und der \gls{arc} existiert.}
         }
  \class{ArcFlags}
        {Enthält die \gls{arc} für den vorberechneten Graphen.}
        {\none}
        {
          \method{getFlags}[int]
                 {
                   \param{turn}{Turn}{Die Nummer eines Abbiegevorgang.}
                 }
                 {Gibt die zum Abbiegevorgang gehörenden \gls{arc} zurück.}
        }
\class{Weights}
        {Enthält die Kantengewichte für den vorberechneten Graphen.}
        {\none}
        {
          \method{getWeight}[int]
                 {
                   \param{turn}{Turn}{Die Nummer eines Abbiegevorgang.}
                 }
                 {Gibt die zum Abbiegevorgang gehörendes Gewicht zurück.}
        }

  \class{RouteModel}
        {Stellt die aktuellen Start- und Zielpunkte, sowie die aktuell berechnete \gls{route} dar. Die Getter liefern dabei immer den aktuellen Zustand (auch \code{null} möglich). Die Setter ändern den Wert und informieren eventuelle \reftype{RouteListener}.}
        {\none}
        {
          \method{addRouteListener}
                 {
                   \param{listener}{RouteModelListener}{Der neue Listener, der über Änderungen informiert werden will.}
                 }
                 {Fügt einen RouteListener dem Modell hinzu, damit er über Änderungen an \gls{route}, Start oder Ziel informiert wird}
        }
  \class{RouteModelListener}
        {Wird bei Änderungen am \reftype{RouteModel} informiert.}
        {\none}
        {
          \method{routeModelChanged}
                 {\none}
                 {Wird bei jeder Änderung am \reftype{RouteModel} aufgerufen.}
        }
}

\package{Views}{
  Dieses Paket enthält die Views nach der \gls{mvc}-Architektur. Alle Views im Klassendiagramm sind Interfaces, die von genau einer Klasse realisiert werden. 
}
{
   \class{MainView}
        {Zeigt das Hauptfenster auf dem Bildschirm an.}
        {\none}
        {
          \method{setCurrentMap}
                 {
                   \param{map}{StreetMap}{Die neue \gls{karte}.}
                 }
                 {Aktualisiert die Anzeige der aktuellen \gls{karte}.}
          \method{setCurrentProfile}
                 {
                   \param{profile}{Profile}{Das neue \gls{profil}.}
                 }
                 {Aktualisiert die Anzeige des aktuellen \glslink{profil}{Profils}.}
        }

  \class{MapView}
        {
          Zeigt einen Kartenausschnitt auf dem Bildschirm an.
          
          Als Kartenprojektion wird die \gls{mercator} verwendet.
        }
        {\none}
        {
          \method{MapView}
                 {
                   \param{source}{TileSource}{Ein Objekt, das die Kartenkacheln liefert, die dann angezeigt werden.}
                 }
                 {
                   Erzeugt eine neue \reftype{MapView}. Die angegebene \reftype{TileSource} wird zum \Gls{rendern} verwendet.
                   
                   Da die Kacheln bei jedem \refmethod{MapView}{paint} synchron angefragt werden, sollte \refparam{MapView}{MapView}{source} ein \reftype{TileCache} sein.
                 }
          \method{paint}
                 {
                   \param{graphics}{Graphics}{Die Java \code{Graphics}, auf welche die \gls{karte} gezeichnet wird.}
                 }
                 {
                   Zeichnet den aktuell sichtbaren Kartenausschnitt.
                   Alle sichtbaren Kacheln werden von \refparam{MapView}{MapView}{source} synchron angefordert.
                 }
        }

  \class{ProfileManagerView}
        {Zeigt das Fenster der Profilverwaltung auf dem Bildschirm an.}
        {\none}
        {
          \method{setCurrentProfile}
                 {
                   \param{profile}{Profile}{Das neue \gls{profil}.}
                 }
                 {
                   Setzt das aktuelle \gls{profil} auf das angegebene \gls{profil}, lädt seine Werte in die Eingabefelder und aktiviert/deaktiviert die Eingabeelemente, je nachdem, ob es sich um ein Standardprofil handelt oder nicht.
                 }
          \method{setAvailableProfiles}
                 {
                   \param{profiles}{List<Profile>}{Die verfügbaren \glspl{profil}.}
                 }
                 {
                   Setzt die \glspl{profil}, die aktuell ausgewählt werden können.
                 }
        }

   \class{MapManagerView}
        {Zeigt das Fenster der Kartenverwaltung auf dem Bildschirm an.}
        {\none}
        {
          \method{setCurrentMap}
                 {
                   \param{map}{StreetMap}{Die neue \gls{karte}.}
                   \param{profiles}{Set<Profile>}{Die \glspl{profil} für die neue \gls{karte}.}
                 }
                 {
                   Setzt die aktuelle \gls{karte} auf die angegebene \gls{karte}, aktualisiert die Liste der \glspl{profil} für die ausgewählte \gls{karte} und aktiviert/deaktiviert die „Import“- und „Löschen“-Buttons, je nachdem, ob es sich um eine Standardkarte handelt oder nicht.
                 }
          \method{setAvailableMaps}
                 {
                   \param{maps}{Set<StreetMap>}{Die verfügbaren \glspl{karte}.}
                 }
                 {
                   Setzt die \glspl{karte}, die aktuell ausgewählt werden können.
                 }
        }

  \class{HistoryView}
        {Zeigt das Fenster mit dem \gls{verlauf} auf dem Bildschirm an.}
        {\none}
        {
          \method{HistoryView}
                 {
                   \param{history}{History}{Der \gls{verlauf}, der angezeigt wird.}
                 }
                 {
                   Erstellt eine HistoryView für den angegebenen \gls{verlauf}.
                   (Der \gls{verlauf} kann später nicht mehr geändert werden.)
                 }
        }

  \class{AboutView}
        {Zeigt das Fenster mit den Informationen über \routeKIT auf dem Bildschirm an.}
        {\none}
        {\none}
}

\package{Profiles}{
  Dieses Paket enthält alle Klassen zu \glslink{profil}{Profilen}.
}
{
  \class{Profile}
        {Ein \glslink{profil}{Fahrzeugprofil}.}
        {
          \attr{name}{String}{Der Name des \glslink{profil}{Profils}.}
          \attr{vehicleType}{VehicleType}{Der Fahrzeugtyp.}
          \attr{height}{int}{Die Höhe des Fahrzeugs, in Zentimetern.}
          \attr{width}{int}{Die Breite des Fahrzeugs, in Zentimetern.}
          \attr{weight}{int}{Das Gewicht des Fahrzeugs, in Kilogramm.}
          \attr{speedHighway}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Autobahn, in Kilometern pro Stunde.}
          \attr{speedRoad}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Landstraße, in Kilometern pro Stunde.}
        }
        {
          \method{isDefault}[boolean]
                 {\none}
                 {Gibt an, ob es sich um ein Standardprofil handelt oder nicht.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die das \gls{profil} gespeichert wird.}
                 }
                 {Speichert das \gls{profil} in die angegebene Datei.}
          \method{load}[Profile]
                 {
                   \param{file}{File}{Die Datei, aus der das \gls{profil} geladen wird.}
                 } 
                 {Lädt ein \gls{profil} aus der angegebenen Datei und gibt es zurück.}
        }
  \enum{VehicleType}
       {
         Ein Fahrzeugtyp.
       }
       {
         \constant{Car}{Ein \gls{pkw}.}
         \constant{Truck}{Ein \gls{lkw}.}
         \constant{Bus}{Ein Omnibus.}
         \constant{Motorcycle}{Ein Motorrad.}
       }
}

\package{Map}{
  Dieses Paket enthält alle Klassen zu Karten und Kartengraphen.
  
  \routeKIT verwendet zwei Datenstrukturen für den Straßengraphen:
  \begin{description}
  \item[\reftype{Graph}] ist ein regulärer, knotenbasierter Graph, gespeichert als Adjazenzfeld. Aus ihm wirden dynamisch geometrische Datenstrukturen \reftype{GraphIndex} für verschiedene Zoomstufen erzeugt. Er wird zum \Gls{rendern} der \gls{karte} verwendet.
  \item[\reftype{EdgeBasedGraph}] ist ein kantenbasierter Graph (ebenfalls gespeichert als Adjazenzfeld). Er wird zur Routenberechnung verwendet.
  \end{description}
Zusammen mit einem Namen ergeben sie \reftype{StreetMap}.
}
{
  \class{StreetMap}
        {Eine \gls{karte}.}
        {
          \attr{name}{String}{Der Name der \gls{karte}.}
          \attr{graph}{Graph}{Der Graph der \gls{karte}, d.\,h. das Straßennetz.}
          \attr{edgeBasedGraph}{EdgeBasedGraph}{Die kantenbasierte Version des Straßennetzes, die zur Routenberechnung verwendet wird.}
        }
        {
          \method{isDefault}[boolean]
                 {\none}
                 {Gibt zurück, ob es sich um eine Standardkarte handelt.}
        }

  \class{Graph}
        {
          Ein Kartengraph/Straßennetz. Beachte: Dieser Graph ist nicht das Ergebnis einer \gls{vorberechnung} für ein \gls{profil} und eine \gls{karte}, sondern nur für eine \gls{karte}.
        }
        {
          \attr{highwayType}{HighwayType}{Der Straßentyp.}
        }
        {
          \method{Graph}
                 {
                   \param{nodes}{Node[]}{Der Knoten-Bestandteil des Adjazenzfeldes.}
                   \param{edges}{Edge[]}{Der Kanten-Bestandteil des Adjazenzfeldes.}
                   \param{nodeProps}{Map<Node, NodeProperties>}
                         {
                           Die \code{NodeProperties} der Knoten des Graphen. Es wird eine \code{Map} anstelle eines Arrays verwendet, da die meisten Knoten keine besonderen Eigenschaften haben und daher das Array zum großen Teil leer wäre.
                         }
                   \param{edgeProps}{EdgeProperties[]}
                         {
                           Die \code{EdgeProperties} der Kanten des Graphen. Hier wird ein Array verwendet, da jede Kante einen Namen und damit ein \code{EdgeProperties}-Objekt hat.
                         }
                   \param{lat}{float[]}{Die geographischen Breiten der Knoten des Graphen.}
                   \param{lon}{float[]}{Die geographischen Längen der Knoten des Graphen.}
                 }
                 {Konstruktor: Erzeugt ein neues Graph-Objekt aus dem gegebenen Adjazenzfeld.}
          \method{getOutgoingEdges}[Set<Edge>]
                 {
                   \param{node}{Node}{Der Knoten, dessen ausgehende Kanten gesucht werden.}
                 }
                 {Gibt alle ausgehenden Kanten des angegebenen Knotens zurück.}
	      \method{getIncomingEdges}[Set<Edge>]
                 {
                   \param{node}{Node}{Der Knoten, dessen eingehende Kanten gesucht werden.}
                 }
                 {Gibt alle in den Knoten eingehende Kanten zurück.}
          \method{getTargetNode}[Node]
                 {
                   \param{edge}{Edge}{Die Kante, dessen Endknoten gesucht wird.}
                 }
                 {Gibt den Endknoten der angegebenen Kante zurück.}
          \method{getStartNode}[Node]
                 {
                   \param{edge}{Edge}{Die Kante, dessen Startknoten gesucht wird.}
                 }
                 {Gibt den Startknoten der angegebenen Kante zurück.}       
          \method{getCoordinates}[Coordinates]
                 {
                   \param{node}{Node}{Der Knoten, dessen Koordinaten gesucht werden.}
                 }
                 {Gibt die Koordinaten des angegebenen Knotens zurück.}
          \method{getNodeProperties}[NodeProperties]
                 {
                   \param{node}{Node}{Der Knoten, dessen \reftype{NodeProperties} gesucht werden.}
                 }
                 {Gibt die \code{NodeProperties} des angegebenen Knotens zurück.}
          \method{getEdgeProperties}[EdgeProperties]
                 {
                   \param{edge}{Edge}{Die Kante, deren \reftype{EdgeProperties} gesucht werden.}
                 }
                 {Gibt die \code{EdgeProperties} der angegebenen Kante zurück.}
	      \method{getIndex}[GraphIndex]
	             {
	               \param{zoom}{int}{Die Zoomstufe.}
	             }
                 {Gibt eine geometrische Datenstruktur zur angegebenen Zoomstufe zurück.}
        }
  \class{GraphIndex}
        {Eine geometrische Datenstruktur zum schnellen Auffinden von Kanten innerhalb eines Kartenausschnitts.}
        {\none}
        {
	      \method{GraphIndex}
		         {
		           \param{graph}{Graph}{Ein Graph.}
		           \param{zoom}{int}{Die Zoomstufe.}
 		         }
		         {Erzeugt die Datenstruktur für den gegebenen Graph und die angegebenen Zoomstufe.}	
	      \method{getEdgesInRectangle} [Edge[]]
		         {
		           \param{leftTop}{Coordinates}{Die Koordinaten der linken oberen Ecke des Ausschnitts.}
 		           \param{rightBottom}{Coordinates}{Die Koordinaten der rechten unteren Ecke des Ausschnitts.}
                 } 
		         {
                   Bestimmt alle Kanten innerhalb eines rechteckigen Kartenausschnitts, der durch \refparam{GraphIndex}{getEdgesInRectangle}{leftTop} und \refparam{GraphIndex}{getEdgesInRectangle}{rightBottom} festgelegt ist.
                 }
	      \method{findNearestPointOnEdge} [PointOnEdge]
                 {
                   \param{coords}{Coordinates}{Die Koordinaten eines Punktes.}
                 }
                 {Sucht zu gegebenen Koordinaten den nächsten Punkt auf einer Kante.}
        }
  \class{NodeProperties}
        {Kapselt die Eigenschaften eines Knotens.}
        {\none}
        {
          \method{isMotorwayJunction}[boolean]
                 {\none}
                 {Bestimmt, ob der Knoten eine Schnellstraßen- oder Autobahnanschlussstelle ist.}
          \method{getJunctionName}[String]
                 {\none}
                 {Gibt den Namen der Anschlussstelle zurück oder \code{null}, falls es sich nicht um eine Anschlussstelle handelt.}
          \method{getJunctionRef}[String]
                 {\none}
                 {Gibt die Nummer der Anschlussstelle zurück oder \code{null}, falls es sich nicht um eine Anschlussstelle handelt.}
          \method{isTrafficLights}[boolean]
                 {\none}
                 {Bestimmt, ob sich an dem Knoten eine Ampel befindet.}
        }
  \class{EdgeProperties}
        {Kapselt die Eigenschaften einer Kante.}
        {\none}
        {
          \method{getName}[String]
                 {\none}
                 {Gibt den Namen der Straße zurück oder \code{null}, falls nicht vorhanden.}
          \method{getRoadRef}[String]
                 {\none}
                 {Gibt die Nummer der Straße zurück oder \code{null}, falls nicht vorhanden.}
          \method{getMaxSpeed}[int]
                 {\param{profile}{Profile}{Das \gls{profil}, für das die Höchstgeschwindigkeit auf dieser Kante bestimmt werden soll.}}
                 {Bestimmt die zulässige Höchstgeschwindigkeit (in Kilometern pro Stunde) auf dieser Kante für das angegebene \gls{profil}.}
        }
  \enum{HighwayType}
       {Ein Straßentyp.}
       {
         \constant{Motorway}{Autobahn}
         \constant{Trunk}{Schnellstraße}
         \constant{Primary}{Bundesstraße}
         \constant{Secondary}{Landesstraße}
         \constant{Tertiary}{Kreisstraße}
         \constant{Unclassified}{Gemeindeverbindungsstraße}
         \constant{Residential}{Ortsstraße}
       }
  \class{EdgeBasedGraph}
        {
          Enthält das Straßennetz als kantenbasierten Graphen. Die Knoten dieses Graphen entsprechen den Kanten des zugehörigen \reftype{Graph}-Objekts und werden daher mit \code{Edge} bezeichnet. Die Kanten dieses Graphen repräsentieren Abbiegemöglichkeiten und werden mit \code{Turn} bezeichnet.
          
          Diese Datenstruktur ist unabhängig vom \gls{profil} und wird wie \reftype{Graph} bei der \gls{vorberechnung} für eine \gls{karte} erstellt.
          Erst in Kombination mit den profilspezifischen \reftype{Weights} kann sie zur Routenberechnung verwendet werden.
        }
        {\none}
        {
          \method{getOutgoingTurns}[Set<Turn>]
                 {
                   \param{edge}{Edge}{Die Kante, deren ausgehende Abbiegemöglichkeiten gesucht werden.}
                 }
                 {Gibt alle Abbiegemöglichkeiten \emph{von} der angegebenen Kante zurück.}
          \method{getIncomingTurns}[Set<Turn>]
                 {
                   \param{edge}{Edge}{Die Kante, deren eingehende Abbiegemöglichkeiten gesucht werden.}
                 }
                 {Gibt alle Abbiegemöglichkeiten \emph{auf} die angegebene Kante zurück.}
          \method{getTargetEdge}[Edge]
                 {
                   \param{turn}{Turn}{Die Abbiegemöglichkeit, deren Endkante gesucht wird.}
                 }
                 {Gibt die Kante zurück, auf die die angegebene Abbiegemöglichkeit führt.}
          \method{getStartEdge}[Edge]
                 {
                   \param{turn}{Turn}{Die Abbiegemöglichkeit, deren Anfangskante gesucht wird.}
                 }
                 {Gibt die Kante zurück, von der die angegebene Abbiegemöglichkeit besteht.}
          \method{getPartition}[Partition]
                 {
                   \param{edge}{Edge}{Die Kante, deren Partition bestimmt werden soll.}
                 }
                 {
                   Gibt die Partition zurück, in der sich die angegebene Kante (der Knoten des kantenbasierten Graphen) befindet.
                   
                   Ist noch keine Partitionierung gegeben, so wird immer eine Standard-Partition zurückgegeben.
                 }
          \method{setPartitions}
                 {
                   \param{partitions}{Partition[]}{Die neuen Partitionen.}
                 }
                 {
                   Setzt die Partitionen des Graphen. Die \code{Edge}s des Graphen sind die Indizes in \refparam{EdgeBasedGraph}{setPartitions}{partitions}.
                 }
          \method{getTurnType}[TurnType]
                 {
                   \param{turn}{Turn}{Der Abbiegevorgang, dessen Art gesucht wird.}
                 }
                 {Gibt die Art des angegebenen Abbiegevorgangs zurück.}
          \method{allowsTurn}[boolean]
                 {
                   \param{turn}{Turn}{Der zu betrachtende Abbiegevorgang.}
                   \param{profile}{Profile}{Das verwendete \gls{profil}.}
                 }
                 {Bestimmt, ob der angegebene Abbiegevorgang unter dem angegeben \gls{profil} zulässig ist.}
        }
  \enum{TurnType}
       {Der Typ einer Abbiegemöglichkeit.}
       {
         \constant{RightTurn}{Rechts abbiegen.}
         \constant{LeftTurn}{Links abbiegen.}
         \constant{HalfRightTurn}{Rechts halten.}
         \constant{HalfLeftTurn}{Links halten.}
         \constant{StraightOn}{Geradeaus.}
         \constant{NoTurn}{Keine echte Abbiegemöglichkeit.}
         \constant{RoundaboutEntry}{Einfahrt in einen Kreisverkehr.}
         \constant{RoundaboutExit}{Ausfahrt aus einem Kreisverkehr.}
         \constant{RoundaboutNoExit}{An einer Ausfahrt im Kreisverkehr bleiben.}
         \constant{MotorwayJunction}{Eine Anschlussstelle einer Autobahn oder Schnellstraße.}
       }
}

\package{Exporter}{
  Dieses Paket enthält alle Klassen, die zum Exportieren der \gls{route} oder ihrer Beschreibung benötigt werden.
}
{
  \class{HTMLExporter}
        {Stellt die Funktionalität zum Export der \gls{wegbeschreibung} einer \gls{route} im HTML-Format bereit.}
        {\none}
        {
          \method{exportRouteDescription}
                 {
                   \param{routeDesc}{RouteDescription}{Die zu exportierende \gls{wegbeschreibung}.}
                   \param{file}{File}{Die HTML-Datei, die geschrieben werden soll.}
                 }
                 {Exportiert die \refparam{HTMLExporter}{exportRouteDescription}{routeDesc} im HTML-Format in die angegebene Datei.}
        }

  \class{GPXExporter}
        {Stellt die Funktionalität zum Export einer \gls{route} im \gls{gpx}-Format bereit.}
        {\none}
        {
          \method{exportRoute}
                 {
                   \param{route}{Route}{Die zu exportierende \gls{route}.}
                   \param{file}{File}{Die \gls{gpx}-Datei, die geschrieben werden soll.}
                 }
                 {Exportiert die Wegpunkte der \refparam{GPXExporter}{exportRoute}{route} im \gls{gpx}-Format in die angegebene Datei.}
        }
}

\package{History}{
  Dieses Paket enthält alle Klassen, die für den \gls{verlauf} benötigt werden.
}
{
  \class{History}
        {Kapselt den \gls{verlauf}.}
        {\none}
        {
          \method{addEntry}
                 {
                   \param{start}{Coordinates}{Der Startpunkt.}
                   \param{destination}{Coordinates}{Der Zielpunkt.}
                 }
                 {Fügt einen Eintrag zum \gls{verlauf} hinzu. Als \refattr{HistoryEntry}{date} des neuen Eintrags wird die aktuelle Zeit verwendet.}
          \method{getEntries}[List<HistoryEntry>]
                 {\none}
                 {Gibt alle Einträge des \gls{verlauf}{Verlaufs} zurück.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die der \gls{verlauf} gespeichert wird.}
                 }
                 {Speichert den \gls{verlauf} in die angegebene Datei.}
          \method{load}[History]
                 {
                   \param{file}{File}{Die Datei, aus der der \gls{verlauf} geladen wird.}
                 }
                 {Lädt einen \gls{verlauf} aus der angegebenen Datei und gibt ihn zurück.}
        }
  \class{HistoryEntry}
        {Ein Eintrag im \gls{verlauf}.}
        {
          \attr{start}{Coordinates}{Der Startpunkt der Anfrage.}
          \attr{destination}{Coordinates}{Der Zielpunkt der Anfrage.}
          \attr{date}{Date}{Der Zeitpunkt der Anfrage.}
        }
        {
          \method{HistoryEntry}
                 {
                   \param{start}{Coordinates}{Der Startpunkt.}
                   \param{dest}{Coordinates}{Der Zielpunkt.}
                   \param{date}{Date}{Der Zeitpunkt.}
                 }
                 {Konstruktor: Erzeugt ein neues Objekt mit den angegebenen Attributen.}
        }
}

\package{Util}{
  Dieses Paket enthält verschiedene nützliche Klassen, die sonst nirgendwo hingehören.
}
{
  \class{Coordinates}
        {Kapselt ein Paar geographischer Koordinaten.}
        {
          \attr{latitude}{float}{Der Breitengrad des Koordinatenpaars.}
          \attr{longitude}{float}{Der Längengrad des Koordinatenpaars.}
        }
        {
          \method{Coordinates}
                 {
                   \param{lat}{float}{Der Breitengrad.}
                   \param{lon}{float}{Der Längengrad.}
                 }
                 {
                   Konstruktor: Erstellt ein neues Objekt aus den gegebenen Koordinaten.
                 }
          \method{distanceTo}[float]
                 {
                   \param{other}{Coordinates}{Die anderen Koordinaten.}
                 }
                 {
                   Berechnet die Entfernung (Luftlinie, in Metern) zwischen den zwei Koordinaten.
                 }
          \method{getSmtX}[float]
                 {
                   \param{zoom}{int}{Die Zoomstufe.}
                 }
                 {
                   Berechnet die \gls{smt}-X-Komponente zu diesen Koordinaten.
                 }
          \method{getSmtY}[float]
                 {
                   \param{zoom}{int}{Die Zoomstufe.}
                 }
                 {
                   Berechnet die \gls{smt}-Y-Komponente zu diesen Koordinaten.
                 }
          \method{fromSmt}[Coordinates]
                 {
                   \param{x}{float}{Die \gls{smt}-X-Komponente.}
                   \param{y}{float}{Die \gls{smt}-Y-Komponente.}
                   \param{zoom}{int}{Die Zoomstufe.}
                 }
                 {
                   Statische Methode.
                   Rechnet \gls{smt}-Koordinaten in Koordinaten um.
                 }
        }
  \class{PointOnEdge}
        {Beschreibt einen Punkt auf der Kante.}
        {
          \attr{edge}{Edge}{Die Kante, auf der sich der Punkt befindet.}
          \attr{position}{float}{Eine Zahl zwischen 0 und 1, die den Anteil der Strecke vom Punkt zum Anfangsknoten an der Gesamtlänge der Kante angibt.}
        }
        {
          \method{PointOnEdge}
                 {
                   \param{edge}{Edge}{Die Kante.}
                   \param{position}{float}{Der Wert für das Attribut \refattr{PointOnEdge}{position}.}
                 }
                 {Konstruktor: Erstellt ein neues Objekt aus den gegebenen Attributen.}
        }
}


\section{Sequenzdiagramme}

\subsection{Programmstart}
\begin{figure}[H]
\centering
\includegraphics[angle=90, width=0.9\textwidth]{StartSequenz}
\caption{Start des Programms}
\label{fig:sequenz_start}
\end{figure}
Beteiligte Klassen: \reftype{RouteKit}, \reftype{Controller}, \reftype{MapManager}, \reftype{ProfileManager}, \reftype{ProfileMapCombination}, \reftype{RouteModel}, \reftype{MainView}, \reftype{TileCache}, \reftype{MapView}

\subsection{Rendern}
\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{RenderSequenz}
\caption{Rendern der Karte}
\label{fig:sequenz_rendern}
\end{figure}
Beteiligte Klassen: \reftype{MapView}, \reftype{TileCache}, \reftype{TileSource}

\subsection{Routenberechnung} % TODO reference
\begin{figure}[H]
\centering
\includegraphics[angle=90, height=\textheight]{RouteCalculationSequenz}
\caption{Berechnen der Route}
\label{fig:sequenz_routeCalculation}
\end{figure}
Beteiligte Klassen: \reftype{MainView}, \reftype{MapView}, \reftype{Controller}, \reftype{RouteModel}, \reftype{RouteCalculator}, \reftype{RouteDescription}, \reftype{Route}, \reftype{RouteDescription}

\subsection{Profilverwaltung}
\begin{figure}[H]
\centering
\includegraphics[height=0.9\textheight]{ProfilSequenz}
\caption{Hinzufügen und Entfernen von Profilen}
\label{fig:sequenz_profilVerwaltung}
\end{figure}
Beteiligte Klassen: \reftype{ProfileManagerView}, \reftype{ProfileManagerController}, \reftype{ProfileManager}, \reftype{MainView}

\subsection{Vorberechnung} % TODO reference
\begin{figure}[H]
\centering
\includegraphics[angle=90, height=0.9\textheight]{PreCalculationSequenz}
\caption{Vorberechnung für eine Karte und ein Profil}
\label{fig:sequenz_vorberechnung}
\end{figure}
Beteiligte Klassen: \reftype{Controller}, \reftype{PreCalculator}, \reftype{EdgeWeighter}, \reftype{ArcFlagsCalculator}, \reftype{ProfileMapCombination}


\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
