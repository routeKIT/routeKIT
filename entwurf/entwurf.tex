% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands
\usepackage{xspace} % \xspace for use in commands: put a space only if no punctuation follows

\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\newcommand{\none}[0]{
%  % see http://tex.stackexchange.com/questions/61155/linespacing-without-packages
%  \setlength\lineskiplimit{-1000pt} % allow overflowing of lines
%  \linespread{0}\selectfont % don’t advance line after empty item
  \item[] keine.
}
% Argumente:
% 1. Name
% 2. Beschreibung
% 3. Klassen (ein oder mehrere \class)
\newcommand{\package}[3]{
  \subsection{Paket #1}
  #2
  \begin{description}
    #3
  \end{description}
}
% Argumente:
% 1. Klassenname
% 2. Beschreibung
% 3. Attribute (ein oder mehrere \attr, oder \none)
% 4. Methoden (ein oder mehrere \method, oder \none)
\newcommand{\class}[4]{
  \newcommand{\currentclass}[0]{#1}
  \item[\namedlabel{K:#1}{\code{#1}}] #2
    \ifstrequal{#3#4}{\none\none}{
      % \none attributes and \none methods, skip
    }{
      \begin{description}
        \ifstrequal{#3}{\none}{
          % \none attributes, skip
        }{
        \item[Attribute] \hfill % \hfill forces the following description into the next line
          \begin{description}
            #3
          \end{description}
        }
        \ifstrequal{#4}{\none}{
          % \none methods, skip
        }{
        \item[Methoden] \hfill % \hfill forces the following description into the next line
          \begin{description}
            #4
          \end{description}
        }
      \end{description}
    }
  \let\currentclass=\undefined
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\attr}[3]{
  \item[\namedlabel{A:\currentclass.#1}{\code{#1}}] #3 Typ:~\code{#2}
}
% Argumente:
% 1. Name
% 2. (optional) Typ – default: void (wird nicht angezeigt)
% 3. Parameter (ein oder mehrere \param, oder \none)
% 4. Beschreibung
\NewDocumentCommand{\method}{m o m +m}{ % the ‘+m’ means that parameter 4 can contain several paragraphs, see http://tex.stackexchange.com/questions/64328/blank-lines-break-xparse-or-ifthen-macro
  \newcommand{\currentmethod}[0]{#1}
  \item[\namedlabel{M:\currentclass.#1}{\code{#1}}] #4\\
    \ifstrequal{#3}{\none}{
      % \none parameters, skip
    }{
      Parameter:
      \begin{description}
        #3
      \end{description}
    }
    \IfValueTF{#2} % if the optional “type” argument is given...
              {Rückgabetyp: \code{#2}} % then show the return type...
              {} % else don’t.
  \let\currentmethod=\undefined
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\param}[3]{
  \item[\namedlabel{P:\currentclass.\currentmethod.#1}{\code{#1}}] #3 Typ:~\code{#2}
}

% Argumente:
% 1. Klasse
% 2. (optional) Text – default: Klasse
\NewDocumentCommand{\refclass}{mO{#1}}{
  \hyperref[K:#1]{\code{#2}}\xspace%
}
% Argumente:
% 1. Klasse
% 2. Attribut
% 3. (optional) Text – default: Attribut innerhalb der Klasse, sonst Klasse.Attribut
\NewDocumentCommand{\refattr}{mmO{__DEFAULT__}}{%
  \hyperref[A:#1.#2]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the attribute name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}
% Argumennte:
% 1. Klasse
% 2. Methode
% 3. (optional) Text – default: Methode innerhalb der Klasse, sonst Klasse.Methode
\NewDocumentCommand{\refmethod}{mmO{__DEFAULT__}}{%
  \hyperref[M:#1.#2]{\code{%
      \ifthenelse{\equal{#3}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          #2% we’re inside the same class, only use the method name
        }{%
          #1.#2%
        }%
      }{%
        #3%
  }}}\xspace%
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. Parameter
% 4. (optional) Text – default: Parameter innerhalb der Methode, sonst Methode.Parameter innerhalb der Klasse, sonst Klasse.Methode.Parameter
\NewDocumentCommand{\refparam}{mmmO{__DEFAULT__}}{%
  \hyperref[P:#1.#2.#3]{\code{%
      \ifthenelse{\equal{#4}{__DEFAULT__}}{%
        \ifthenelse{\equal{\currentclass}{#1}}{%
          \ifthenelse{\equal{\currentmethod}{#2}}{%
            #3% we’re inside the same method, only use the parameter name
          }{%
            #2.#3% we’re inside the same class, only use the method and parameter name
        }}{%
          #1.#2.#3%
      }}{%
        #4%
  }}}\xspace%
}

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{
  \glsdoifexists{#2}{
    \def\@glsnumberformat{glsgobblenumber}
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}
    \setkeys{glossadd}{#1}
    \@gls@saveentrycounter
    \@do@wrglossary{#2}
  }
}
\newcommand{\glsaddallunused}[1][]{
  \edef\@glo@type{\@glo@types}
  \setkeys{glossadd}{#1}
  \forallglsentries[\@glo@type]{\@glo@entry}{
    \ifglsused{\@glo@entry}{}{
      \glsaddnp[#1]{\@glo@entry}}}
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

\makeatletter

\begin{document}
\shorthandoff{"}

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\emph{routeKIT}\xspace}


% alle Glossareinträge
\newacronym[longplural=Personenkraftwagen]{pkw}{PKW}{Personenkraftwagen}
\newacronym[longplural=Lastkraftwagen]{lkw}{LKW}{Lastkraftwagen}
\newacronym{osm}{OSM}{OpenStreetMap}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{gpx}{GPX}{GPS Exchange Format}
\newacronym{smt}{SMT}{Slippy Map Tile}
\newacronym{mvc}{MVC}{Model View Controller}

\newglossaryentry{profil}{
  name={Profil},
  description={enthält für die Routenplanung relevante Informationen, z.\,B. die Höhe und das Gewicht des Fahrzeugs},
  plural={Profile}
}
\newglossaryentry{karte}{
  name={Karte},
  description={enthält die Daten aus \gls{osm} sowie einen Namen.},
  plural={Karten}
}
\newglossaryentry{osmkachel}{
  name={OSM-Kachel},
  description={die öffentlichen gerenderten \gls{osm}-Kacheln z.\,B. auf\\\mbox{\url{http://a.tile.openstreetmap.org/}}},
  plural={OSM-Kacheln}
}
\newglossaryentry{route}{
  name={Route},
  description={ein Weg von einem Start- zu einem Zielpunkt},
  plural={Routen}
}
\newglossaryentry{vorberechnung}{
  name={Vorberechnung},
  description={verbindet die \gls{karte} mit den auf einem \gls{profil} basierenden Informationen und ermöglicht, unter anderem mittels \gls{arc}, später eine Beschleunigung der Berechnung einer \gls{route}; muss für jede neue \gls{karte}/\gls{profil}-Kombination einmal ausgeführt werden},
  plural={Vorberechnungen},
  see={arc}
}
\newglossaryentry{rendern}{
  name={rendern},
  description={Berechnung einer Bildkachel aus den zu rendernden Daten}
}
\newglossaryentry{wegbeschreibung}{
  name={Wegbeschreibung},
  description={Beschreibung einer \gls{route} durch eine Liste von Abbiegeanweisungen}
}
\newglossaryentry{dijkstra}{
  name={Dijkstra’s Algorithmus},
  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
}
\newglossaryentry{arc}{
 name={Arc-Flags},
 description={eine Technik, um eine Routenberechnung zu beschleunigen}
}
\newglossaryentry{verlauf}{
  name={Verlauf},
  description={speichert Routenanfragen für spätere Wiederverwendung. Es existiert nur ein Verlauf für die gesamte Anwendung.}
}
\newglossaryentry{mercator}{
  name={Mercator-Projektion},
  description={die Zylinderprojektion der Weltkugel}
}



\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Entwurf}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage


\section{Einleitung}

Dieses Dokument dokumentiert den Entwurf der Anwendung \routeKIT. % TODO „dieses Dokument dokumentiert“
Es beschreibt ausführlich die verwendeten Pakete, Klassen und Methoden und ihre Beziehungen untereinander (wobei die Beziehungen im Klassendiagramm deutlicher ersichtlich sind).

\routeKIT ist eine Anwendung zur Routenplanung; durch Verwendung von \glslink{profil}{Profilen} kann sie dem Benutzer die optimalen Routen für sein spezielles Fahrzeug angeben.
Um die Routenberechnung zu beschleunigen, wird pro \gls{profil} und \gls{karte} eine zeitaufwändige \gls{vorberechnung} durchgeführt.


\section{Übersicht}

% TODO


\section{Anmerkungen}

\begin{itemize}
\item Für Attribute, die im Klassendiagramm durch Relationen oder explizit angegeben sind, sind implizite Getter und Setter gegeben.
\item Die folgenden Typen aus dem Klassendiagramm sind „typedefs“, keine echten Klassen:
  \begin{itemize}
  \item \code{Node}: \code{int}, die ID des Knotens
  \item \code{Edge}: \code{int}, die ID der Kante
  \item \code{Turn}: \code{int}, die ID der Kante im kantenbasierten Graphen (\refclass{EdgeBasedGraph})
  \item \code{Partition}: \code{int}, die ID einer Partition
  \end{itemize}
\end{itemize}


\section{Pakete und Klassen}

\package{Profiles}{
  Dieses Paket enthält alle Klassen zu \glslink{profil}{Profilen}.
}
{
  \class{Profile}
        {Ein \glslink{profil}{Fahrzeugprofil}.}
        {
          \attr{name}{String}{Der Name des Profils.}
          \attr{vehicleType}{VehicleType}{Der Fahrzeugtyp.}
          \attr{height}{int}{Die Höhe des Fahrzeugs, in Zentimetern.}
          \attr{width}{int}{Die Breite des Fahrzeugs, in Zentimetern.}
          \attr{weight}{int}{Das Gewicht des Fahrzeugs, in Kilogramm.}
          \attr{speedHighway}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Autobahn, in Kilometern pro Stunde.}
          \attr{speedRoad}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Landstraße, in Kilometern pro Stunde.}
        }
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die das Profil gespeichert wird.}
                 }
                 {Speichert das Profil in die angegebene Datei.}
          \method{load}[\refclass{Profile}]
                 {
                   \param{file}{File}{Die Datei, aus der das Profil geladen wird.}
                 } 
                 {Lädt ein Profil aus der angegebenen Datei und gibt es zurück.}
        }
}

\package{Map}{
  Dieses Paket enthält alle Klassen zu Karten und Kartengraphen.
  
  \routeKIT verwendet zwei Datenstrukturen für den Straßengraphen:
  \begin{description}
  \item[\refclass{Graph}] ist ein regulärer, knotenbasierter Graph, gespeichert als Adjazenzfeld. Er wird zum \Gls{rendern} der Karte verwendet.
  \item[\refclass{EdgeBasedGraph}] ist ein kantenbasierter Graph (ebenfalls gespeichert als Adjazenzfeld). Er wird zur Routenberechnung verwendet.
  \end{description}
}
{
  \class{StreetMap}
        {Eine Karte.}
        {
          \attr{name}{String}{Der Name der Karte.}
          \attr{graph}{\refclass{Graph}}{Der Graph der Karte, d.\,h. das Straßennetz.}
        }
        {\none}
   \class{GraphIndex}
        {Eine geometrische Datenstruktur.}
        {\none}
        {
	\method{GraphIndex}
		{
		    \param{graph}{\refclass{Graph}}{Ein Adjazenzfeld.}
 		}
		    {Erzeugt eine geometrische Datenstruktur für einen Graph aus einem Adjazenzfeld.}	
	\method{getEdgesIn}[Edge[]]
		{
		    \param{leftTop}{Coordinates}{Die Koordinaten der linken oberen Ecke des Ausschnitts.}
 		    \param{rightBottom}{Coordinates}{Die Koordinaten der rechten unteren Ecke des Ausschnitts.}
                      } 
		    {
                      Bestimmt alle Kanten in einem Kartenausschnitt, der durch \refparam{GraphIndex}{getEdgesIn}{leftTop} und \refparam{GraphIndex}{getEdgesIn}{rightBottom} festgelegt ist.
                    }
	\method{projectToEdge} [\refclass{PointOnEdge}]
                 {
                   \param{lon}{float}{Die geographische Länge von einem Punkt.}
                   \param{lat}{float}{Die geographische Breite von einem Punkt.}
                 }
                 {Sucht zu gegebenen Koordinaten den nähesten Punkt auf einer Kante.}
         }
  \class{Graph}
        {
          Ein Kartengraph / Straßennetz. Beachte: Dieser Graph ist nicht das Ergebnis einer Vorberechnung für ein Profil und eine Karte, sondern nur für eine Karte.
        }
        {
          \attr{highwayType}{HighwayType}{Der Straßentyp.}
        }
        {
          \method{Graph}
                 {
                   \param{nodes}{Node[]}{Der Knoten-Bestandteil des Adjazenzfeldes.}
                   \param{edges}{Edge[]}{Der Kanten-Bestandteil des Adjazenzfeldes.}
                   \param{nodeProps}{Map<Node, \refclass{NodeProperties}>}
                         {
                           Die \code{NodeProperties} der Knoten des Graphen. Es wird eine \code{Map} anstelle eines Arrays verwendet, da die meisten Knoten keine besonderen Eigenschaften haben und daher das Array zum großen Teil leer wäre.
                         }
                   \param{edgeProps}{\refclass{EdgeProperties}{}[]} % use \refclass{EdgeProperties}{}[] instead of \refclass{EdgeProperties}[]: in the latter form, LaTeX thinks we’re passing an optional argument to \refclass
                         {
                           Die \code{EdgeProperties} der Kanten des Graphen. Hier wird ein Array verwendet, da jede Kante einen Namen und damit ein \code{EdgeProperties}-Objekt hat.
                         }
                   \param{lat}{float[]}{Die geographischen Breiten der Knoten des Graphen.}
                   \param{lon}{float[]}{Die geographischen Längen der Knoten des Graphen.}
                 }
                 {Erstellt ein neues Graph-Objekt aus dem gegebenen Adjazenzfeld.}
          \method{getOutgoingEdges}[Set<Edge>]
                 {\param{node}{Node}{Der Knoten, dessen ausgehende Kanten gesucht werden.}}
                 {Gibt alle ausgehenden Kanten des angegebenen Knotens zurück.}
	      \method{getIncomingEdges}[Set<Edge>]
                 {\param{node}{Node}{Der Knoten, dessen eingehende Kanten gesucht werden.}}
                 {Gibt alle in den Knoten eingehende Kanten zurück.}
          \method{getTargetNode}[Node]
                 {\param{edge}{Edge}{Die Kante, dessen Endknoten gesucht wird.}}
                 {Gibt den Endknoten der angegebenen Kante zurück.}
          \method{getStartNode}[Node]
                 {\param{edge}{Edge}{Die Kante, dessen Startknoten gesucht wird.}}
                 {Gibt den Startknoten der angegebenen Kante zurück.}       
          \method{getLat}[float]
                 {\param{node}{Node}{Der Knoten, dessen geographische Breite gesucht wird.}}
                 {Gibt die geographische Breite des angegebenen Knotens zurück.}
          \method{getLon}[float]
                 {\param{node}{Node}{Der Knoten, dessen geographische Länge gesucht wird.}}
                 {Gibt die geographische Länge des angegebenen Knotens zurück.}
          \method{getNodeProperties}[\refclass{NodeProperties}]
                 {\param{node}{Node}{Der Knoten, dessen \refclass{NodeProperties} gesucht werden.}}
                 {Gibt die \code{NodeProperties} des angegebenen Knotens zurück.}
          \method{getEdgeProperties}[\refclass{EdgeProperties}]
                 {\param{edge}{Edge}{Die Kante, deren \refclass{EdgeProperties} gesucht werden.}}
                 {Gibt die \code{EdgeProperties} de angegebenen Kante zurück.}
        }
  \class{NodeProperties}
        {Kapselt die Eigenschaften eines Knotens.}
        {\none}
        {
          \method{isMotorwayJunction}[boolean]
                 {\none}
                 {Bestimmt, ob der Knoten eine Schnellstraßen- oder Autobahnanschlussstelle ist.}
          \method{getJunctionName}[String]
                 {\none}
                 {Gibt den Namen der Anschlussstelle zurück oder \code{null}, falls es sich nicht um eine Anschlussstelle handelt.}
          \method{getJunctionRef}[String]
                 {\none}
                 {Gibt die Nummer der Anschlussstelle zurück oder \code{null}, falls es sich nicht um eine Anschlussstelle handelt.}
          \method{isTrafficLights}[boolean]
                 {\none}
                 {Bestimmt, ob sich an dem Knoten eine Ampel befindet.}
        }
  \class{EdgeProperties}
        {Kapselt die Eigenschaften einer Kante.}
        {\none}
        {
          \method{getName}[String]
                 {\none}
                 {Gibt den Namen der Straße zurück oder \code{null}, falls nicht vorhanden.}
          \method{getRoadRef}[String]
                 {\none}
                 {Gibt die Nummer der Straße zurück oder \code{null}, falls nicht vorhanden.}
          \method{getMaxSpeed}[int]
                 {\param{profile}{\refclass{Profile}}{Das Profil, für das die Höchstgeschwindigkeit auf dieser Kante bestimmt werden soll.}}
                 {Bestimmt die zulässige Höchstgeschwindigkeit (in Kilometern pro Stunde) auf dieser Kante für das angegebene Profil.}
        }
  \class{EdgeBasedGraph}
        {
          Enthält das Straßennetz als kantenbasierten Graphen. Die Knoten dieses Graphen entsprechen den Kanten des zugehörigen \refclass{Graph}-Objekts und werden daher mit \code{Edge} bezeichnet. Die Kanten dieses Graphen repräsentieren Abbiegemöglichkeiten und werden mit \code{Turn} bezeichnet.
          
          Diese Datenstruktur ist profilunabhängig und wird, wie \refclass{Graph}, bei der Vorberechnung für eine Karte erstellt.
          Erst in Kombination mit den Profil-spezifischen \refclass{Weights} kann sie zur Routenberechnung verwendet werden.
        }
        {\none}
        {
          \method{getOutgoingTurns}[Set<Turn>]
                 {
                   \param{edge}{Edge}{Die Kante, deren ausgehende Abbiegemöglichkeiten gesucht werden.}
                 }
                 {Gibt alle Abbiegemöglichkeiten \emph{von} der angegebenen Kante zurück.}
          \method{getIncomingTurns}[Set<Turn>]
                 {
                   \param{edge}{Edge}{Die Kante, deren eingehende Abbiegemöglichkeiten gesucht werden.}
                 }
                 {Gibt alle Abbiegemöglichkeiten \emph{auf} die angegebene Kante zurück.}
          \method{getTargetEdge}[Edge]
                 {
                   \param{turn}{Turn}{Die Abbiegemöglichkeit, deren Endkante gesucht wird.}
                 }
                 {Gibt die Kante zurück, auf die die angegebene Abbiegemöglichkeit führt.}
          \method{getStartEdge}[Edge]
                 {
                   \param{turn}{Turn}{Die Abbiegemöglichkeit, deren Anfangskante gesucht wird.}
                 }
                 {Gibt die Kante zurück, von der die angegebene Abbiegemöglichkeit besteht.}
          \method{getPartition}[Partition]
                 {
                   \param{edge}{Edge}{Die Kante, deren Partition bestimmt werden soll.}
                 }
                 {
                   Gibt die Partition zurück, in der sich die angegebene Kante (der Knoten des kantenbasierten Graphen) befindet.
                   
                   Ist noch keine Partitionierung gegeben, so wird immer eine Standard-Partition zurückgegeben.
                 }
          \method{setPartitions}
                 {
                   \param{partitions}{Partition[]}{Die neuen Partitionen.}
                 }
                 {
                   Setzt die Partitionen des Graphen. Die \code{Edge}s des Graphen sind die Indizes in \refparam{EdgeBasedGraph}{setPartitions}{partition}.
                 }
          \method{getTurnType}[TurnType]
                 {
                   \param{turn}{Turn}{Der Abbiegevorgang, dessen Art gesucht wird.}
                 }
                 {Gibt die Art des angegebenen Abbiegevorgangs zurück.}
          \method{allowsTurn}[boolean]
                 {
                   \param{turn}{Turn}{Der zu betrachtende Abbiegevorgang.}
                   \param{profile}{\refclass{Profile}}{Das verwendete Profil.}
                 }
                 {Bestimmt, ob der angegebene Abbiegevorgang unter dem angegeben Profil zulässig ist.}
        }
}

\package{TODO}{
  Dieses Paket enthält alle Klassen, die noch in keinem anderen Paket enthalten sind.
  Vor der endgültigen Abgabe sollten alle diese Klassen einen Platz in einem anderen Paket finden.
}
{
  \class{RouteKit}
        {Startet die Anwendung.}
        {\none}
        {
	\method{main}
         	    {
		\param{args}{String[]}{String-Argumente}
               }
	    {Erzeugt einen \refclass{Controller}.}
         }

  \class{ProfileMapCombination}
        {Eine Kombination aus einem \refclass{Profile}[Profil] und einer \refclass{StreetMap}[Karte].}
        {
          \attr{profile}{\refclass{Profile}}{Das \gls{profil}.}
          \attr{map}{\refclass{StreetMap}}{Die Karte.}
        }
        {
	\method{isCalculated}[boolean]
         	    {\none}
	    {Gibt "wahr" zurück, wenn für eine Kombination aus Profil und Karte eine Vorberechnung der Gewichte und der Arc-Flags exestiert.}
         }
  \class{RouteModel}
        {Stellt die aktuellen Start- und Zielpunkte, sowie die aktuell berechnete Route dar. Die getter liefern dabei immer den aktuelle Zustand (auch null möglich). Die setter ändern den Wert und informieren eventuelle \refclass{RouteListener}}
        {\none}
        {
          \method{addRouteListener}
                 {
                   \param{listener}{RouteModelListener}{der neue Listener der über Änderungen informiert werden will}
                 }
                 {fügt einen RouteListener dem Modell hinzu, damit er über Änderungen an Route, Start oder Ziel informiert wird}
        }
  \class{RouteModelListener}
        {Wird bei Änderungen am \refclass{RouteModel} informiert.}
        {\none}
        {
          \method{routeModelChanged}
                 {\none}
                 {Wird bei jeder Änderung aufgerufen}
        }
}

\package{Util}{
  Dieses Paket enthält verschiedene nützliche Klassen, die sonst nirgendwo hingehören.
}
{
  \class{Coordinates}
        {Kapselt ein Paar von geographischen Koordinaten.}
        {
          \attr{lat}{float}{Der Breitengrad der Koordinaten.}
          \attr{lon}{float}{Der Längengrad der Koordinaten.}
        }
        {
          \method{distanceTo}[float]
                 {
                   \param{other}{\refclass{Coordinates}}{Die anderen Koordinaten.}
                 }
                 {
                   Berechnet die Entfernung (Luftlinie, in Metern) zwischen den zwei Koordinaten.
                 }
          \method{getSmtX}[float]
                 {
                   \param{zoom}{int}{Das Zoomlevel.}
                 }
                 {
                   Berechnet die \gls{smt}-X-Komponente zu diesen Koordinaten.
                 }
          \method{getSmtY}[float]
                 {
                   \param{zoom}{int}{Das Zoomlevel.}
                 }
                 {
                   Berechnet die \gls{smt}-Y-Komponente zu diesen Koordinaten.
                 }
          \method{fromSmt}[Coordinates]
                 {
                   \param{x}{float}{Die \gls{smt}-X-Komponente.}
                   \param{y}{float}{Die \gls{smt}-Y-Komponente.}
                   \param{zoom}{int}{Die \gls{smt}-Zoom-Komponente.}
                 }
                 {
                   Statische Methode.
                   Rechnet \gls{smt}-Koordinaten in Koordinaten um.
                 }
        }
  \class{PointOnEdge}
        {Beschreibt einen Punkt auf der Kante.}
        {
          \attr{edgeid}{int}{Die eindeutige Id einer Kante.}
          \attr{pointPosition}{float}{Eine Zahl zwischen 0 und 1, die den Anteil der Strecke vom Punkt zum Ausgangsknoten von der Gesamtlänge der Kante angibt.}
        }
        {\none}
}

\package{RouteCalculator}{
  Dieses Paket enthält alle Klassen, die zur Routenberechnung benötigt werden.
}
{
  \class{RouteCalculator}
        {Stellt ein Interface für einen Algorithmus zur Routenberechnung bereit.}
        {\none}
        {
          \method{calculateRoute}[\refclass{Route}]
                 {
                   \param{start}{\refclass{PointOnEdge}}{Der Startpunkt für die Routenberechnung.}
                   \param{destination}{\refclass{PointOnEdge}}{Der Zielpunkt für die Routenberechnung.}
                   \param{data}{\refclass{ProfileMapCombination}}{Der vorberechnete Graph auf dem die Routenberechnung durchgeführt wird.}
                 }
                 {Berechnet einen Weg vom Startpunkt zum Zielpunkt auf dem gegebenen Graphen.}
        }
  \class{Route}
        {Repräsentiert eine berechnete \gls{route}.}
        {\none} % ?
        {
          \method{getNodes}[Node[]]
                 {\none}
                 {Liefert eine Liste der Knoten, aus denen denen die Route besteht.}
        }
  \class{RouteDescription}
        {Kapselt die zu einer \refclass{Route} gehörende \gls{wegbeschreibung}.}
        {\none} % ?
        {
          \method{getInstructions}[List<\refclass{TurnInstruction}>]
                 {\none}
                 {Liefert eine Liste der Abbiegeanweisungen.}
        }
  \class{RouteDescriptionGenerator}
        {Stellt die Funktionalität zur Erzeugung einer \gls{wegbeschreibung} bereit.}
        {\none}
        {
          \method{generateRouteDescription}[\refclass{RouteDescription}]
                 {
                   \param{route}{\refclass{Route}}{Die Route, deren Beschreibung erzeugt werden soll.}
                   \param{data}{\refclass{ProfileMapCombination}}{Der Graph der zur Generierung der Beschreibung verwendet wird.}
                 }
                 {Erzeugt die zur \refparam{RouteDescriptionGenerator}{generateRouteDescription}{route} gehörende Wegbeschreibung.}
        }
  \class{TurnInstruction}
        {Kapselt eine einzelne Abbiegeanweisung, aus welchen eine \refclass{RouteDescription} aufgebaut ist.}
        {\none} % ?
        {
          \method{toString}[String]
                 {\none}
                 {Gibt den Text der Abbiegeanweisung zurück.}
        }
  \class{ArcFlags}
        {Enthält die Arc-Flags für den vorberechneten Graphen.}
        {\none} % ?
        {
          \method{getFlags}[int]
                 {
                   \param{node}{Node}{Die Nummer eines Knotens.}
                 }
                 {Gibt die zum Knoten gehörenden Arc-Flags zurück.}
        }
   \class{ArcFlagsDijkstra}
       {Führt die Berechnung der schnellsten Route zwischen Start- und Zielpunkt für die aktuelle Kombination aus Karte und Profil durch unter der Beachtung von Arc-Flags.}
       {\none}
       {\none}
}

\package{History}{
  Dieses Paket enthält alle Klassen, die für den \gls{verlauf} benötigt werden.
}
{
  \class{History}
        {Kapselt den \gls{verlauf}.}
        {\none}
        {
          \method{addEntry}
                 {
                   \param{start}{Coordinates}{Der Startpunkt.}
                   \param{destination}{Coordinates}{Der Zielpunkt.}
                 }
                 {Fügt einen Eintrag zum Verlauf hinzu. Als \refattr{HistoryEntry}{date} des neuen Eintrags wird die aktuelle Zeit verwendet.}
          \method{getEntries}[List<\refclass{HistoryEntry}>]
                 {\none}
                 {Gibt alle Einträge des Verlaufs zurück.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die der Verlauf gespeichert wird.}
                 }
                 {Speichert den Verlauf in die angegebene Datei.}
          \method{load}[History]
                 {
                   \param{file}{File}{Die Datei, aus der der Verlauf geladen wird.}
                 }
                 {Lädt einen Verlauf aus der angegebenen Datei und gibt ihn zurück.}
        }
  \class{HistoryEntry}
        {Ein Eintrag im \gls{verlauf}.}
        {
          \attr{start}{Coordinates}{Der Startpunkt der Anfrage.}
          \attr{destination}{Coordinates}{Der Zielpunkt der Anfrage.}
          \attr{date}{Date}{Der Zeitpunkt der Anfrage.}
        }
        {\none}
}

\package{MapDisplay}{
  Dieses Paket enthält alle Klassen, die an der Darstellung der Karte im \gls{gui} beteiligt sind.
  
  Die zentrale Klasse dieses Pakets ist der \refclass{TileCache}, der dafür sorgt, dass Kartenkacheln nicht jedes Mal neu berechnet werden müssen.
  Er berechnet selbst keine Kacheln, sondern erhält diese von einer untergeordneten \refclass{TileSource}, welche die Kacheln synchron berechnet.
  Der Cache stellt diese Kacheln dann asynchron bereit, indem er für nicht gespeicherte Kacheln zunächst eine „Dummy-Kachel“ zurückgibt und bei abgeschlossener Berechnung registrierte \refclass{TileFinishedListener} benachrichtigt.
  
  Um nicht zu viel Arbeitsspeicher zu beanspruchen, verwaltet der Cache die gespeicherten Kacheln so, dass sie bei Speicherknappheit von der JVM garbage-collected werden können.
  
  Kartenkacheln werden über \gls{smt}-Koordinaten, wie sie auch bei anderen \gls{osm}-Viewern verwendet werden, adressiert.
}
{
  \class{TileFinishedListener}
        {Wird benachrichtigt, wenn die Berechnung einer Kartenkachel abgeschlossen ist.}
        {\none}
        {
          \method{tileFinished}
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{getTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{getTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{getTile}{zoom}}
                   \param{tile}{BufferedImage}{Die berechnete Kachel.}
                 }
                 {
                   Wird vom \refclass{TileCache} aufgerufen, wenn die Berechnung einer Kachel abgeschlossen ist.
                   Die übliche Aktion ist, ein \code{repaint} der Kartenansicht im \gls{gui} auszulösen.
                 }
        }
  \class{TileSource}
        {Abstrakte Klasse, die ein Interface für das (synchrone) \Gls{rendern} von Kartenkacheln definiert.}
        {\none}
        {
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{getTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{getTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{getTile}{zoom}}
                 }
                 {Berechnet die angegebene Kachel und gibt sie zurück.}
        }
  \class{TileCache}
        {
          Verwaltet die Berechnung von Kartenkacheln und ist ein Zwischenspeicher für diese.
          Kacheln können angefragt werden, und nachdem die (asynchrone) Berechnung abgeschlossen ist, werden registrierte \refclass{TileFinishedListener} benachrichtigt.
          
          Intern werden die gecacheten Kacheln so gehalten, dass der Garbage Collector sie bei Speicherknappheit verwerfen kann (etwa durch \code{SoftReference}s).
        }
        {\none}
        {
          \method{TileCache}
                 {\param{target}{\refclass{TileSource}}{Die \code{TileSource}, die die tatsächliche Berechnung durchführt und deren Ergebnisse zwischengespeichert werden.}}
                 {Erstellt einen neuen Cache für die angegebene \refclass{TileSource}.}
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{Die \gls{smt}-X-Komponente.}
                   \param{y}{int}{Die \gls{smt}-Y-Komponente.}
                   \param{zoom}{int}{Die \gls{smt}-Zoom-Komponente.}
                 }
                 {
                   Ist die angeforderte Kachel bereits im Zwischenspeicher vorhanden, so wird sie direkt zurückgegeben;
                   andernfalls wird eine Dummy-Kachel zurückgegeben und die richtige von \refparam{TileCache}{TileCache}{target} angefordert, im Zwischenspeicher gespeichert und dann zurückgegeben. Kacheln von tieferer Zoomstufe und der Umgebung einer Kachel werden von \refparam{TileCache}{TileCache}{target} angefordert und im Zwischenspeicher gespeichert.
                 }

 \method{addTileFinishedListener}
                 {\param{listener}{\refclass{TileFinishedListener}}{Der Listener, der hinzugefügt werden soll.}}
                 {
                   Registriert einen \refclass{TileFinishedListener}, der benachrichtigt wird, wenn eine Kachel fertig berechnet ist.
                   Die Kachel ist Teil der Nachricht.
                 }
}
  \class{TileRenderer}
        {Eine \refclass{TileSource}, die die Kacheln selbst berechnet.}
        {\none}
        {
          \method{TileRenderer}
	   { 
		\param{graph}{\refclass{Graph}}{Ein Adjazenzfeld.}
	    }
	   {Ein Konstruktor, der einen neuen TileRenderer erzeugt.}
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{getTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{getTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{getTile}{zoom}}
                 }
                 {Berechnet die angegebene Kachel und gibt sie zurück.}
        }
  \class{OSMRenderer}
        {Eine \refclass{TileSource}, die die \glspl{osmkachel} vom OpenStreetMap-Server herunterlädt.}
        {\none}
        {
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileCache}{getTile}{x}}
                   \param{y}{int}{siehe \refparam{TileCache}{getTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileCache}{getTile}{zoom}}
                 }
                 {Lädt die angegebene Kachel herunter und gibt sie zurück.}
        }
}

\package{View}{
  Dieses Paket enthält die Views nach der \gls{mvc}-Architektur.
}
{
  \class{MapView}
        {Zeigt einen Kartenausschnitt auf dem Bildschirm an.}
        {\none}
        {
          \method{MapView}
                 {
                   \param{s}{\refclass{TileSource}}{eine gerenderte Kachel}
                 }
                 {Ein Konstruktor, der ein Objekt der Klasse \refclass{MapView} erzeugt.}
          \method{paint}
                 {
                   \param{graphics}{Graphics}{ein Objekt vom}
                 }
                 {Zeichnet einen Kartenausschnitt, indem fertige Kacheln richtig platziert werden.}
        }

   \class{MainView}
        {Zeigt das Hauptfenster auf dem Bildschirm an.}
        {\none}
        {\none}

   \class{MapManagerView}
        {Zeigt das Fenster der Kartenverwaltung auf dem Bildschirm an.}
        {\none}
        {\none}

   \class{ProfileManagerView}
        {Zeigt das Fenster der Profilverwaltung auf dem Bildschirm an.}
        {\none}
        {
          \method{setCurrentProfile}
                 {
                   \param{profile}{\refclass{Profile}}{Das neue Profile.}
                 }
                 {
                   Setzt das aktuelle Profil auf das angegebene Profil, lädt seine Werte in die Eingabefelder und aktiviert/deaktiviert die Eingabeelemente, je nachdem, ob es sich um ein Standardprofil handelt oder nicht.
                 }
          \method{setAvailableProfiles}
                 {
                   \param{profiles}{List<\refclass{Profile}>}{Die verfügbaren Profile.}
                 }
                 {
                   Setzt die Profile, die aktuell ausgewählt werden können.
                 }
        }

  \class{HistoryView}
        {Zeigt das Fenster mit dem Verlauf auf dem Bildschirm an.}
        {\none}
        {\none}

  \class{AboutView}
        {Zeigt das Fenster mit den Informationen über \routeKIT auf dem Bildschirm an.}
        {\none}
        {\none}
}
\package{Precalculation}{
  Dieses Paket enthält alle Klassen, die an der \gls{vorberechnung} beteiligt sind.
  
  % TODO kurze erklärung, wie die vorberechnung läuft
}
{
  \class{PreCalculationScheduler}
        {Veranlasst die Vorberechnung für Kombinationen aus \refclass{Profile}[Profil] und \refclass{StreetMap}[Karte].}
        {\attr{calculationQueue}{Queue}{Die Queue, in der geplante Vorberechnungen stehen. Sie wird nacheinander abgearbeitet.}}
        {
          \method{scheduleCalculation}
                 {
                   \param{comb}{ProfileMapCombination}{Die Kombination aus \refclass{Profile}[Profil] und \refclass{StreetMap}[Karte], für die die Vorberechnung durchgeführt werden soll.}
                 }
                 {Fügt die \refclass{ProfileMapCombination} zur späteren Vorberechnung zur Queue hinzu.}
        }
                        
  \class{PreCalculator}
        {Führt die Vorberechnung für eine Kombination aus \refclass{Profile}[Profil] und \refclass{StreetMap}[Karte] durch.}
        {\none}
        {
          \method{doPrecalculation}
                 {
                   \param{comb}{ProfileMapCombination}{Die Kombination aus \refclass{Profile}[Profil] und \refclass{StreetMap}[Karte], für die die Vorberechnung durchgeführt werden soll.}
                 }
                 {
                   Führt die Vorberechnung für die gegebene Kombination aus \refclass{Profile}[Profil] und \refclass{StreetMap}[Karte] durch.
                   Dabei werden ein \refclass{EdgeWeighter} und ein \refclass{ArcFlagsCalculator} aufgerufen.
                 }
        }
  \class{MapImporter}
        {Liest eine OSM-Karte aus dem Dateisystem in ein \refclass{Graph}-Objekt}
        {\none}
        {
          \method{importMap}[\refclass{StreetMap}]
                 {
                   \param{f}{File}{Die Datei aus der die OSM-Daten importiert werden sollen.}
                 }
                 {Importiert und säubert den Straßengraph. Erzeugt das Adjazenzfeld und den kantenbasierten Graphen aus \refclass{MapNode}.}
        }
  \class{OSMParser}
        {Importiert eine neue Karte.}
        {\none}
        {
          \method{parseOSM}[Graph]
                 {
                   \param{f}{File}{}
                 }
                 {Wandelt eine OSM-Karte in eine verlinkte Datenstruktur \refclass{MapNode} um.}
        }
  \class{MapNode}
        {Stellt eine Kreuzung im Straßennetz dar. Diese verknüpfte Darstellung ist nur eine Zwischendarstellung um die OSM-Daten gut einlesen zu können}
        {\none}
        {
          \method{getLon}[float]
                 {\none}
                 {Gibt den Längengrad dieses Knotens aus.}
          \method{getLat}[float]
                 {\none}
                 {Gibt den Breitengrad dieses Knotens aus.}
          \method{getEdges}[Set<MapEdge>]
                 {\none}
                 {Gibt eine Liste mit allen Kanten zu einem Knoten zurück.}
        }
        
  \class{EdgeWeighter}
        {
          Versieht den kantenbasierten Graphen (\refclass{EdgeBasedGraph}) mit Kantengewichten.
          
          Die Kantengewichte des kantenbasierten Graphen sind profilabhängig und geben an, wie „teuer“ ein bestimmter Abbiegevorgang ist.
          Abbiegebeschränkungen werden durch maximale Kantengewichte umgesetzt.
        }
        {\none}
        {
          \method{weightEdges}
                 {
                   \param{combination}{ProfileMapCombination}{Die zu gewichtende Kombination aus Profil und Karte.}
                 }
                 {
                   Berechnet die Kantengewichte für die angegebene Kombination und setzt die \refclass{Weights} von \refparam{EdgeWeighter}{weightEdges}{combination} entsprechend.
                 }
        }
        
  \class{ArcFlagsCalculator}
        {Berechnet Arc-Flags für einen partitionierten, gewichteten Graphen.}
        {\none}
        {
          \method{calculateArcFlags}
                 {
                   \param{combination}{\refclass{ProfileMapCombination}}{Die Kombination aus Profil und Karte.}
                 }
                 {
                   Berechnet die Arc-Flags für die angegebene Kombination und setzt die \refclass{ArcFlags} von \refparam{ArcFlagsCalculator}{calculateArcFlags}{combination} entsprechend.
                 }
        }
        
  \class{GraphPartitioner}
        {Partitioniert einen gegebenen Graphen.}
        {\none}
        {
          \method{partitionGraph}
                 {
                   \param{graph}{\refclass{EdgeBasedGraph}}{Der zu partitionierende Graph.}
                   \param{numberOfPartitions}{int}{Die gewünschte Anzahl an Partitionen.}
                 }
                 {
                   Teilt den Graphen in die gewünschte Anzahl an Partitionen.
                   
                   Die ermittelten Partitionen werden über \refmethod{EdgeBasedGraph}{setPartitions} direkt gesetzt.
                 }
        }
        
  \class{ExternalPartitionerAdapter}
        {Leitet die Partitionierungsanfrage an ein externes Partitionierungsprogramm weiter.}
        {\none}
        {
          \method{partitionGraph}
                 {
                   \param{graph}{\refclass{EdgeBasedGraph}}{Der zu partitionierende Graph.}
                   \param{numberOfPartitions}{int}{Die gewünschte Anzahl an Partitionen.}
                 }
                 {Lässt den Graphen durch das externe Programm in die gewünschte Anzahl an Partitionen teilen.}
        }
}

\package{Controllers}{
  Dieses Paket enthält die Controller aus der \gls{mvc}-Architektur.
}
{
  \class{ProfileManager}
        {Verwaltet die Profile. Hat intern eine Liste von vorhandenen Profilen.} % TODO Liste oder Menge? vgl getProfiles - Lucas
        {\none}
        {
          \method{saveProfile}
                 {
                   \param{p}{\refclass{Profile}}{Das Profil, das gespeichert werden soll.}
                 }
                 {
                   Speichert das ausgewählte Profil in der internen Liste und auf der Festplatte.
                   
                   (Der Speicherort wird vom Manager deckend verwaltet.) % „deckend“ = “opaque”
                 }
          \method{deleteProfile}
                 {
                   \param{p}{\refclass{Profile}}{Das Profil, das gelöscht werden soll.}
                 }
                 {
                   Löscht das ausgewählte Profil aus der internen Liste und von der Festplatte.
                 }
          \method{getProfiles}[Set<\refclass{Profile}>]
                 {\none}
                 {
                   Gibt alle Profile in der internen Liste zurück.
                 }
        }
  \class{MapManager}
        {Verwaltet die Kartendaten. Hat intern eine Liste von vorhandenen Kartendaten.} % TODO siehe ProfileManager
        {\none}
        {
          \method{saveMap}
                 {
                   \param{m}{\refclass{StreetMap}}{Die Karte, die gespeichert werden soll.}
                 }
                 {
                   Speichert die ausgewählte Karte in der internen Liste und auf der Festplatte.

                   (Der Speicherort wird vom Manager deckend verwaltet.)
                 }
          \method{deleteMap}
                 {
                   \param{m}{\refclass{StreetMap}}{Die Karte, die gelöscht werden soll.}
                 }
                 {
                   Löscht die ausgewählte Karte aus der internen Liste und von der Festplatte (die OSM-Datei, den Graphen und alle Vorberechnungen).
                 }
          \method{getMaps}[Set<\refclass{StreetMap}>]
                 {\none}
                 {
                   Gibt alle Karten in der internen Liste zurück.
                 }
        }

  \class{Controller}
        {Steuert die Programmabläufe zur Routenberechnung.}
        {\none}
        {
          \method{Controller}
                 {\none}
                 {Ein Konstruktor, der ein Objekt der Klasse \refclass{Controller} erzeugt.}
                 
          \method{onStartChanged}
                 {
                   \param{start}{Coordinates}{Die Koordinaten des neuen Startpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Startpunkt ändert (z.\,B. durch eine Eingabe des Benutzers).
                   Setzt den neuen Startpunkt in der \refclass{MapView}.
                   Falls bereits ein Zielpunkt ausgewählt ist, wird außerdem ein neuer Eintrag zum Verlauf hinzugefügt (siehe \refmethod{History}{addEntry}) und die Routenberechnung gestartet.
                 }
          \method{onDestinationChanged}
                 {
                   \param{destination}{Coordinates}{Die Koordinaten des neuen Zielpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Zielpunkt ändert (z.\,B. durch eine Eingabe des Benutzers).
                   Setzt den neuen Zielpunkt in der \refclass{MapView}.
                   Falls bereits ein Startpunkt ausgewählt ist, wird außerdem ein neuer Eintrag zum Verlauf hinzugefügt (siehe \refmethod{History}{addEntry}) und die Routenberechnung gestartet.
                 }
          \method{onStartAndDestChanged}
                 {
                   \param{start}{Coordinates}{Die Koordinaten des neuen Startpunkts.}
                   \param{destination}{Coordinates}{Die Koordinaten des neuen Zielpunkts.}
                 }
                 {
                   Wird aufgerufen, wenn sich der Start- und Zielpunkt ändern (z.\,B. durch die Auswahl eines Eintrags aus dem \gls{verlauf}).
                   Die gleichen Aktionen wie für \refmethod{Controller}{onStartChanged} und \refmethod{Controller}{onDestinationChanged} werden ausgeführt, nur nicht doppelt.
                 }
                 
          \method{exportGPX}
                 {
                   \param{target}{File}{Die Datei, in die die Route gespeichert werden soll.}
                 }
                 {
                   Speichert die aktuelle Route im \gls{gpx}-Format in die angegebene Datei.
                   Ist keine aktuelle Route verfügbar (z.\,B. da noch keine Vorberechnung vorliegt), so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{exportHTML}
                 {
                   \param{target}{File}{Die Datei, in die die Wegbeschreibung gespeichert werden soll.}
                 }
                 {
                   Speichert die Wegbeschreibung der aktuellen Route im HTML-Format in die angegeben Datei.
                   Ist keine aktuelle Route verfügbar (z.\,B. da noch keine Vorberechnung vorliegt), so wird eine \code{IllegalStateException} geworfen.
                 }
                 
          \method{selectProfile}
                 {
                   \param{profile}{Profile}{Das aktuelle Profil.} 
                 }
                 {
                   Wählt das angegebe Profil aus.
                 }
          \method{selectMap}
                 {
                   \param{map}{\refclass{StreetMap}}{Die aktuelle Karte.} 
                 }
                 {
                   Wählt die angegebe Karte aus.
                 }

          \method{getHistoryModel}[ListModel]
                 {\none}
                 {
                   Gibt ein \code{javax.swing.ListModel} zurück, das von einer \code{JList} verwendet werden kann, um den Verlauf anzuzeigen.
                 }
                 
          \method{schedulePrecalculate}
                 {
                   \param{profileAndMap}{ProfileMapCombination}{Eine nicht vorberechnete Kombination aus Profil und Karte.} 
                 }
                 {
                   Ruft \refmethod{PreCalculationScheduler}{scheduleCalculation} auf, falls keine Vorberechnung für diese Kombination aus Profil und Karte existiert.
                 }

          \method{setUseOnlineMaps}
                 {
                   \param{useOnlineMaps}{boolean}{\code{true}, um \glspl{osmkachel} zu verwenden, \code{false}, um selbst gerenderte Kacheln zu verwenden.}
                 }
                 {
                   Legt fest, ob \glspl{osmkachel} oder selbst gerenderte Kacheln verwendet werden sollen.
                   Für \glspl{osmkachel} wird der \refclass{OSMRenderer} verwendet, für die eigenen Kacheln der \refclass{TileRenderer}.
                 }
          \method{getTileSource}[\refclass{TileSource}]
                 {\none}
                 {
                   Gibt eine \refclass{TileSource} zurück, die zum Rendern der Karten verwendet werden soll.
                 }
        }

  \class{ProfileManagerController}
        {
          Der Controller für die \refclass{ProfileManagerView}.
        }
        {\none}
        {
          \method{switchProfile}
                 {
                   \param{p}{\refclass{Profile}}{Das neue Profil.}
                 }
                 {
                   Wird aufgerufen, wenn in der \refclass{ProfileManagerView} ein anderes Profil ausgewählt wird.
                   Speichert die Werte aller Eingabeelemente und setzt sie auf die Werte des neuen Profils (ggf. die bereits gespeicherten Werte, falls das Profil schon zuvor einmal ausgewählt war).
                   Aktiviert/Deaktiviert den Löschen-Button und die Eingabeelemente, je nachdem, ob das neue Profil ein Standardprofil ist oder nicht.
                 }
          \method{deleteProfile}
                 {\none}
                 {
                   Markiert das aktuell ausgewählte Profil zur Löschung und entfernt es aus der Auswahlliste.
                   
                   Beachte: Das Profil wird erst in \refmethod{ProfileManagerController}{saveAllChanges} tatsächlich gelöscht.
                   
                   Handelt es sich bei dem aktuell ausgewählten Profil um ein Standardprofil, so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{estimateDeletionAmount}[int]
                 {\none}
                 {
                   Schätzt, wie viel Rechenzeit durch die aktuell erfassten Änderungen verloren gehen würde (durch notwendige Löschung nun veralteter Vorberechnungen).
                   Die geschätzte Dauer wird in Minuten zurückgegeben.
                 }
          \method{saveAllChanges}
                 {\none}
                 {
                   Führt alle vom Benutzer vorgenommenen Änderungen aus.
                   Dazu gehören das Hinzufügen, Ändern und Löschen von Profilen.
                   Für geänderte Profile werden alle Vorberechnungen gelöscht. 
                 }
        }
  \class{MapManagerController}
        {
          Der Controller für die \refclass{MapManagerView}.
        }
        {\none}
        {
          \method{switchMap}
                 {
                   \param{m}{\refclass{StreetMap}}{Die neue Karte.}
                 }
                 {
                   Wird aufgerufen, wenn in der \refclass{MapManagerView} eine andere Karte ausgewählt wird.
                   Speichert die Liste der Profile für diese Karte und setzt sie auf die Liste der neuen Karte (ggf. die bereits gespeicherte Liste, falls die Karte schon zuvor einmal ausgewählt war).
                   Aktiviert/Deaktiviert den Löschen-Button, je nachdem, ob die neue Karte eine Standardkarte ist oder nicht.
                 }
          \method{addProfile}
                 {
                   \param{p}{\refclass{Profile}}{Das neue Profil.}
                 }
                 {
                   Fügt das angegebene Profil zur ausgewählten Karte hinzu.
                 }
          \method{removeProfile}
                 {
                   \param{p}{\refclass{Profile}}{Das Profil, das entfernt werden soll.}
                 }
                 {
                   Entfernt das angegebene Profil von der ausgewählten Karte.
                 }
          \method{importMap}
                 {
                   \param{name}{String}{Der Name der neuen Karte}
                   \param{f}{File}{Die Datei aus der sie geladen werden soll}
                 }
                 {
                   Fügt eine neue Karte mit dem angegebenen Namen hinzu (oder ersetzt eine bestehende mit diesem Namen) und wählt sie aus.

                   Beachte: Die GUI-Aktionen „Importieren“ und „Aktualisieren“ werden beide durch diese Methode implementiert;
                   bei „Importieren“ stellt die GUI sicher, dass kein bereits existierender Name gewählt wird,
                   bei „Aktualisieren“ verwendet sie den Namen der existierenden Karte.
                 }
          \method{deleteCurrentMap} % TODO inkonsistenter name: beim profil ohne „curren“
                 {\none}
                 {
                   Markiert die aktuell ausgewählte Karte zur Löschung und entfernt sie aus der Auswahlliste.
                   
                   Beachte: Die Karte wird erst in \refmethod{MapManagerController}{saveAllChanges} tatsächlich gelöscht.
                   
                   Handelt es sich bei der aktuell ausgewählten Karte um eine Standardkarte, so wird eine \code{IllegalStateException} geworfen.
                 }
          \method{saveAllChanges}
                 {\none}
                 {
                   Führt alle vom Benutzer vorgenommenen Änderungen aus.
                   Dazu gehören das Importieren und Löschen von Karten sowie das Hinzufügen oder Löschen von Profilen je Karte.
                 }
        }
}

\package{Exporter}{
  Dieses Paket enthält alle Klassen, die zum Exportieren der Route oder ihrer Beschreibung benötigt werden.
}
{
  \class{HTMLExporter}
        {Stellt die Funktionalität zum Export der \gls{wegbeschreibung} einer \gls{route} im HTML-Format bereit.}
        {\none}
        {
          \method{exportRouteDescription}
                 {
                   \param{routeDesc}{\refclass{RouteDescription}}{Die zu exportierende Wegbeschreibung.}
                   \param{file}{File}{Die HTML-Datei, die geschrieben werden soll.}
                 }
                 {Exportiert die \refparam{HTMLExporter}{exportRouteDescription}{routeDesc} im HTML-Format in die angegebene Datei.}
        }

  \class{GPXExporter}
        {Stellt die Funktionalität zum Export einer \gls{route} im GPX-Format bereit.}
        {\none}
        {
          \method{exportRoute}
                 {
                   \param{route}{\refclass{Route}}{Die zu exportierende Route.}
                   \param{file}{File}{Die GPX-Datei, die geschrieben werden soll.}
                 }
                 {Exportiert die Wegpunkte der \refparam{GPXExporter}{exportRoute}{route} im GPX-Format in die angegebene Datei.}
        }
}


\glsaddallunused % TODO remove this before final submission. If we don’t use a glossary entry, we obviously don’t need it, and it causes funky line number lists.
\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
