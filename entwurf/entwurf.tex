% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands

\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\newcommand{\keine}[0]{
%  % see http://tex.stackexchange.com/questions/61155/linespacing-without-packages
%  \setlength\lineskiplimit{-1000pt} % allow overflowing of lines
%  \linespread{0}\selectfont % don’t advance line after empty item
  \item[] keine.
}
% Argumente:
% 1. Name
% 2. Klassen (ein oder mehrere \class)
\newcommand{\package}[2]{
  \subsection{Paket #1}
  \begin{description}
    #2
  \end{description}
}
% Argumente:
% 1. Klassenname
% 2. Beschreibung
% 3. Attribute (ein oder mehrere \attr, oder \keine)
% 4. Methoden (ein oder mehrere \method, oder \keine)
\newcommand{\class}[4]{
  \item[\namedlabel{K:#1}{#1}] #2
    \begin{description}
    \newcommand{\currentclass}[0]{#1}
    \item[Attribute] \hfill % \hfill forces the following description into the next line
      \begin{description}
        #3
      \end{description}
    \item[Methoden] \hfill % \hfill forces the following description into the next line
      \begin{description}
        #4
      \end{description}
    \end{description}
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung, ohne Punkt am Ende
\newcommand{\attr}[3]{
  \item[\namedlabel{A:\currentclass.#1}{#1}] #3. Typ: \texttt{#2}
}
% Argumente:
% 1. Name
% 2. Typ
% 3. Parameter (ein oder mehrere \param, oder \keine)
% 4. Beschreibung
\newcommand{\method}[4]{
  \item[\namedlabel{M:\currentclass.#1}{#1}] #4\\
    Parameter:
    \begin{description}
      \newcommand{\currentmethod}[0]{#1}
      #3
    \end{description}
    returns: \texttt{#2}
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung, ohne Punkt am Ende
\newcommand{\param}[3]{
  \item[\namedlabel{P:\currentclass.\currentmethod.#1}{#1}] #3. Typ: \texttt{#2}
}

% Argumente:
% 1. Klasse
% 2. (optional) Text – default: Klasse
\NewDocumentCommand{\refclass}{mO{#1}}{
  \hyperref[K:#1]{\texttt{#2}}
}
% Argumente:
% 1. Klasse
% 2. Attribut
% 3. (optional) Text – default: Klasse.Attribut
\NewDocumentCommand{\refattr}{mmO{#1.#2}}{
  \hyperref[A:#1.#2]{\texttt{#3}}
}
% Argumennte:
% 1. Klasse
% 2. Methode
% 3. (optional) Text – default: Klasse.Methode
\NewDocumentCommand{\refmethod}{mmO{#1.#2}}{
  \hyperref[M:#1.#2]{\texttt{#3}}
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. Parameter
% 4. (optional) Text – default: Klasse.Methode.Parameter
\NewDocumentCommand{\refparam}{mmmO{#1.#2.#3}}{
  \hyperref[P:#1.#2.#3]{\texttt{#4}}
}

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{
  \glsdoifexists{#2}{
    \def\@glsnumberformat{glsgobblenumber}
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}
    \setkeys{glossadd}{#1}
    \@gls@saveentrycounter
    \@do@wrglossary{#2}
  }
}
\newcommand{\glsaddallunused}[1][]{
  \edef\@glo@type{\@glo@types}
  \setkeys{glossadd}{#1}
  \forallglsentries[\@glo@type]{\@glo@entry}{
    \ifglsused{\@glo@entry}{}{
      \glsaddnp[#1]{\@glo@entry}}}
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

% usage: \counteditem{prefix}{refName} -> item `/prefixXX/` with label `prefix:refName` (where XX is counted in increments of 10)
\makeatletter

\begin{document}
\shorthandoff{"}

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\textit{routeKIT} }

\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Entwurf}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage

\section{Klassen}

\package{Profiles}{
  \class{Profile}
        {Ein Fahrzeugprofil.}
        {
          \attr{name}{String}{Der Name des Profils}
          \attr{vehicleType}{VehicleType}{Der Fahrzeugtyp}
          \attr{height}{int}{Die Höhe des Fahrzeugs, in Zentimetern}
          \attr{width}{int}{Die Breite des Fahrzeugs, in Zentimetern}
          \attr{weight}{int}{Das Gewicht des Fahrzeugs, in Kilogramm}
          \attr{speedHighway}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Autobahn, in Kilometern pro Stunde}
          \attr{speedRoad}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Landstraße, in Kilometern pro Stunde}
        }
        {
          \method{save}{void}
                 {
                   \param{file}{File}{Die Datei, in die das Profil gespeichert wird}
                 }
                 {Speichert das Profil in die angegebene Datei.}
          \method{load}{\refclass{Profile}}
                 {
                   \param{file}{File}{Die Datei, aus der das Profil geladen wird}
                 } 
                 {Lädt ein Profil aus der angegebenen Datei und gibt es zurück.}
        }
}

\package{Map}{
  \class{Map}
        {Eine Karte.}
        {
          \attr{name}{String}{Der Name der Karte}
          \attr{graph}{\refclass{Graph}}{Der Graph der Karte, d.~h. das Straßennetz}
        }
        {\keine}
  \class{Graph}
        {
          Ein Kartengraph / Straßennetz. Beachte: Dieser Graph ist nicht das Ergebnis einer Vorberechnung für ein Profil und eine Karte, sondern nur für eine Karte.
          Siehe auch \refclass{GraphPreCalculation}.
        }
        {\keine}
        {
          \method{Graph}{Konstruktor}
                 {
                   \param{nodes}{int[]}{Der Knoten-Bestandteil des Adjazenzfeldes}
                   \param{edges}{int[]}{Der Kanten-Bestandteil des Adjazenzfeldes}
                   \param{nodeProps}{Map<int, \refclass{NodeProperties}>}
                         {
                           Die \code{NodeProperties} der Knoten des Graphen. Es wird eine \code{Map} anstelle eines Arrays verwendet, da die meisten Knoten keine besonderen Eigenschaften haben und daher das Array zum großen Teil leer wäre
                         }
                   \param{edgeProps}{\refclass{EdgeProperties}{}[]} % use \refclass{EdgeProperties}{}[] instead of \refclass{EdgeProperties}[]: in the latter form, LaTeX thinks we’re passing an optional argument to \refclass
                         {
                           Die \code{EdgeProperties} der Kanten des Graphen. Hier wird ein Array verwendet, da jede Kante einen Namen und damit ein \code{EdgeProperties}-Objekt hat
                         }
                   \param{lat}{float[]}{Die geographischen Breiten der Knoten des Graphen}
                   \param{lon}{float[]}{Die geographischen Längen der Knoten des Graphen}
                 }
                 {Erstellt ein neues Graph-Objekt aus dem gegebenen Adjazenzfeld.}
          \method{getEdges}{Set<int>}
                 {\param{node}{int}{Der Knoten, dessen Kanten gesucht werden}}
                 {Gibt alle \emph{ausgehenden} Kanten des angegebenen Knotens zurück.}
          \method{getTargetNode}{int}
                 {\param{edge}{int}{Die Kante, dessen Zielknoten gesucht wird}}
                 {Gibt den Zielknoten der angegebenen Kante zurück.}
          \method{getLat}{float}
                 {\param{node}{int}{Der Knoten, dessen geographische Breite gesucht wird}}
                 {Gibt die geographische Breite des angegebenen Knotens zurück.}
          \method{getLon}{float}
                 {\param{node}{int}{Der Knoten, dessen geographische Länge gesucht wird}}
                 {Gibt die geographische Länge des angegebenen Knotens zurück.}
          \method{getNodeProperties}{\refclass{NodeProperties}}
                 {\param{node}{int}{Der Knoten, dessen \refclass{NodeProperties} gesucht werden}}
                 {Gibt die \code{NodeProperties} des angegebenen Knotens zurück.}
          \method{getEdgeProperties}{\refclass{EdgeProperties}}
                 {\param{edge}{int}{Die Kante, deren \refclass{EdgeProperties} gesucht werden}}
                 {Gibt die \code{EdgeProperties} de angegebenen Kante zurück.}
        }
  \class{NodeProperties}
        {Kapselt die Eigenschaften eines Knotens.}
        {\keine}
        {
          \method{allowsTurn}{boolean}
                 {
                   \param{fromEdge}{int}{Die Kante, über die der Knoten betreten wird}
                   \param{toEdge}{int}{Die Kante, über die der Knoten verlassen wird}
                   \param{profile}{\refclass{Profile}}{Das Profil, für das die Gültigkeit der Route bestimmt werden soll}
                 }
                 {
                   Bestimmt, ob eine Route, die den Knoten über die angegebenen Kanten betritt und verlässt, gültig ist.
                   
                   Wenn der Knoten nicht Endknoten von \refparam{NodeProperties}{allowsTurn}{fromEdge}[fromEdge] und Startknoten von \refparam{NodeProperties}{allowsTurn}{toEdge}[toEdge] ist, wird immer \code{false} zurückgegeben.
                 }
          \method{isMiniRoundabout}{boolean}
                 {\keine}
                 {Bestimmt, ob der Knoten ein kleiner Kreisverkehr ist oder nicht.}
          \method{isHighwayJunction}{boolean}
                 {\keine}
                 {Bestimmt, ob der Knoten ein Autobahnkreuz ist oder nicht.} % TODO
          \method{getJunctionName}{String}
                 {\keine}
                 {Gibt den Namen der Kreuzung zurück.}
          \method{getJunctionRef}{String}
                 {\keine}
                 {Gibt die Referenz der Kreuzung zurück.} % TODO what is this
        }
  \class{EdgeProperties}
        {Kapselt die Eigenschaften einer Kante.}
        {\keine}
        {
          \method{getName}{String}
                 {\keine}
                 {Gibt den Namen der Kante zurück.}
          \method{getRoadRef}{String}
                 {\keine}
                 {Gibt die Referenz der Straße zurück.} % TODO what is this
          \method{allowsRoute}{boolean}
                 {\param{profile}{\refclass{Profile}}{Das Profil, für das die Gültigkeit der Route bestimmt werden soll}}
                 {Bestimmt, ob eine Route, die über diese Kante führt, gültig ist.}
          \method{getMaxSpeed}{int}
                 {\param{profile}{\refclass{Profile}}{Das Profil, für das die Höchstgeschwindigkeit auf dieser Kante bestimmt werden soll}}
                 {Bestimmt die zulässige Höchstgeschwindigkeit auf dieser Kante für das angegebene Profil.}
          \method{isRoundabout}{boolean}
                 {\keine}
                 {Bestimmt, ob die Kante Teil eines Kreisverkehrs ist oder nicht.} % TODO stimmt das?
        }
}

\package{TODO}{ % TODO: holds classes that still need a package
  \class{ProfileMapCombination}
        {Eine Kombination aus einem \refclass{Profile}[Profil] und einer \refclass{Map}[Karte]. Siehe auch \refclass{GraphPreCalculation}.}
        {
          \attr{profile}{\refclass{Profile}}{Das Profil}
          \attr{map}{\refclass{Map}}{Die Karte}
        }
        {\keine}
}

\package{RouteCalculator}{
  \class{GraphPreCalculation}
        {Kapselt ein Profil, eine Karte, und die Ergebnisse einer Vorberechnung für diese Profil-Karte-Kombination.}
        {\keine}
        {\keine} % TODO
}

\package{History}{
  \class{History}
        {Kapselt den Verlauf.}
        {\keine}
        {
          \method{addEntry}{void}
                 {
                   \param{start}{Coordinates}{Der Startpunkt}
                   \param{destination}{Coordinates}{Der Zielpunkt}
                 }
                 {Fügt einen Eintrag zum Verlauf hinzu. Als \refattr{HistoryEntry}{date} des neuen Eintrags wird die aktuelle Zeit verwendet.}
          \method{getEntries}{List<\refclass{HistoryEntry}>}
                 {\keine}
                 {Gibt alle Einträge des Verlaufs zurück.}
          \method{save}{void}
                 {
                   \param{file}{File}{Die Datei, in die der Verlauf gespeichert wird}
                 }
                 {Speichert den Verlauf in die angegebene Datei.}
          \method{load}{Verlauf}
                 {
                   \param{file}{File}{Die Datei, aus der der Verlauf geladen wird}
                 }
                 {Lädt einen Verlauf aus der angegebenen Datei und gibt ihn zurück.}
        }
  \class{HistoryEntry}
        {Ein Eintrag im Verlauf.}
        {
          \attr{start}{Coordinates}{Der Startpunkt der Anfrage}
          \attr{destination}{Coordinates}{Der Zielpunkt der Anfrage}
          \attr{date}{Date}{Der Zeitpunkt der Anfrage}
        }
        {\keine}
}


\glsaddallunused
\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
