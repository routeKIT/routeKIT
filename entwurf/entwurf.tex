% das Papierformat zuerst
\documentclass[a4paper, 11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref} % clickable refs
\usepackage{graphicx}
\usepackage[toc, numberedsection]{glossaries}
\usepackage{float}
\usepackage{xparse} % powerful commands

\makeglossary

%Hack for referencing labels
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother
% End: Hack for referencing labels

\newcommand{\keine}[0]{
%  % see http://tex.stackexchange.com/questions/61155/linespacing-without-packages
%  \setlength\lineskiplimit{-1000pt} % allow overflowing of lines
%  \linespread{0}\selectfont % don’t advance line after empty item
  \item[] keine.
}
% Argumente:
% 1. Name
% 2. Klassen (ein oder mehrere \class)
\newcommand{\package}[2]{
  \subsection{Paket #1}
  \begin{description}
    #2
  \end{description}
}
% Argumente:
% 1. Klassenname
% 2. Beschreibung
% 3. Attribute (ein oder mehrere \attr, oder \keine)
% 4. Methoden (ein oder mehrere \method, oder \keine)
\newcommand{\class}[4]{
  \item[\namedlabel{K:#1}{#1}] #2
    \begin{description}
    \newcommand{\currentclass}[0]{#1}
    \item[Attribute] \hfill % \hfill forces the following description into the next line
      \begin{description}
        #3
      \end{description}
    \item[Methoden] \hfill % \hfill forces the following description into the next line
      \begin{description}
        #4
      \end{description}
    \end{description}
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\attr}[3]{
  \item[\namedlabel{A:\currentclass.#1}{#1}] #3 Typ:~\texttt{#2}
}
% Argumente:
% 1. Name
% 2. (optional) Typ – default: void (wird nicht angezeigt)
% 3. Parameter (ein oder mehrere \param, oder \keine)
% 4. Beschreibung
\NewDocumentCommand{\method}{m o m +m}{ % the ‘+m’ means that parameter 4 can contain several paragraphs, see http://tex.stackexchange.com/questions/64328/blank-lines-break-xparse-or-ifthen-macro
  \item[\namedlabel{M:\currentclass.#1}{#1}] #4\\
    Parameter:
    \begin{description}
      \newcommand{\currentmethod}[0]{#1}
      #3
    \end{description}
    \IfValueTF{#2} % if the optional “type” argument is given...
              {Rückgabetyp: \texttt{#2}} % then show the return type...
              {} % else don’t.
}
% Argumente:
% 1. Name
% 2. Typ
% 3. kurze Beschreibung
\newcommand{\param}[3]{
  \item[\namedlabel{P:\currentclass.\currentmethod.#1}{#1}] #3 Typ:~\texttt{#2}
}

% Argumente:
% 1. Klasse
% 2. (optional) Text – default: Klasse
\NewDocumentCommand{\refclass}{mO{#1}}{
  \hyperref[K:#1]{\texttt{#2}}
}
% Argumente:
% 1. Klasse
% 2. Attribut
% 3. (optional) Text – default: Klasse.Attribut
\NewDocumentCommand{\refattr}{mmO{#1.#2}}{
  \hyperref[A:#1.#2]{\texttt{#3}}
}
% Argumennte:
% 1. Klasse
% 2. Methode
% 3. (optional) Text – default: Klasse.Methode
\NewDocumentCommand{\refmethod}{mmO{#1.#2}}{
  \hyperref[M:#1.#2]{\texttt{#3}}
}
% Argumente:
% 1. Klasse
% 2. Methode
% 3. Parameter
% 4. (optional) Text – default: Klasse.Methode.Parameter
\NewDocumentCommand{\refparam}{mmmO{#1.#2.#3}}{
  \hyperref[P:#1.#2.#3]{\texttt{#4}}
}

\newcommand{\code}[1]{\texttt{#1}}

% Glossar: alle Einträge, aber ohne extra Referenzen
% http://tex.stackexchange.com/questions/115635/glossaries-suppress-pages-when-using-glsaddall
\newcommand*{\glsgobblenumber}[1]{}
\makeatletter
\newcommand*{\glsaddnp}[2][]{
  \glsdoifexists{#2}{
    \def\@glsnumberformat{glsgobblenumber}
    \edef\@gls@counter{\csname glo@#2@counter\endcsname}
    \setkeys{glossadd}{#1}
    \@gls@saveentrycounter
    \@do@wrglossary{#2}
  }
}
\newcommand{\glsaddallunused}[1][]{
  \edef\@glo@type{\@glo@types}
  \setkeys{glossadd}{#1}
  \forallglsentries[\@glo@type]{\@glo@entry}{
    \ifglsused{\@glo@entry}{}{
      \glsaddnp[#1]{\@glo@entry}}}
}
\makeatother

\renewcommand{\glsnamefont}[1]{\mdseries #1} % glossary entries shouldn’t be bold

% Glossar

% So sieht ein Glossar-Eintrag aus:
%
%\newglossaryentry{dijkstra}{
%  name={Dijkstra’s Algorithmus},
%  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
%}
%\newglossaryentry{arc}{
%  name={Arc-Flags},
%  description={eine Technik, um Routenberechnung zu beschleunigen},
%  see={dijkstra}
%}
%
% Und so kann er im Dokument verwendet werden:
%
% lorem ipsum dolor sit \gls{arc}, consectetur
%
% End: Glossar

\makeatletter

\begin{document}
\shorthandoff{"}

% place a symbol before clickable links
% this has to come *after* \begin{document} because hyperref installs a \AtBeginDocument hook that updates the ref command.
\newcommand{\refsymbol}[0]{\scalebox{0.5}{$\nearrow$}}
\let\oldref\ref
\renewcommand{\ref}[1]{\refsymbol\oldref{#1}}
\let\oldgls\gls
\renewcommand{\gls}[1]{\refsymbol\oldgls{#1}}
\let\oldGls\Gls
\renewcommand{\Gls}[1]{\refsymbol\oldGls{#1}}
\let\oldglspl\glspl
\renewcommand{\glspl}[1]{\refsymbol\oldglspl{#1}}
\let\oldGlspl\Glspl
\renewcommand{\Glspl}[1]{\refsymbol\oldGlspl{#1}}
\let\oldglslink\glslink
\renewcommand{\glslink}[2]{\refsymbol\oldglslink{#1}{#2}}
\let\oldhyperref\hyperref
\renewcommand{\hyperref}[2][notActuallyOptional]{\refsymbol\oldhyperref[#1]{#2}}
\let\oldautoref\autoref
\renewcommand{\autoref}[1]{\refsymbol\oldautoref{#1}}

\newcommand{\abbildung}[1]{\autoref{fig:#1}}
\newcommand{\routeKIT}[0]{\textit{routeKIT} }


% alle Glossareinträge
\newacronym[longplural=Personenkraftwagen]{pkw}{PKW}{Personenkraftwagen}
\newacronym[longplural=Lastkraftwagen]{lkw}{LKW}{Lastkraftwagen}
\newacronym{osm}{OSM}{OpenStreetMap}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{gpx}{GPX}{GPS Exchange Format}

\newglossaryentry{profil}{
  name={Profil},
  description={enthält für die Routenplanung relevante Informationen, z.\,B. die Höhe und das Gewicht des Fahrzeugs},
  plural={Profile}
}
\newglossaryentry{osmkachel}{
  name={OSM-Kachel},
  description={die öffentlichen gerenderten \gls{osm}-Kacheln z.\,B. auf \mbox{\url{http://a.tile.openstreetmap.org/}}},
  plural={OSM-Kacheln}
}
\newglossaryentry{route}{
  name={Route},
  description={ein Weg von einem Start- zu einem Zielpunkt},
  plural={Routen}
}
\newglossaryentry{rendern}{
  name={rendern},
  description={Berechnung einer Bildkachel aus den zu rendernden Daten}
}
\newglossaryentry{wegbeschreibung}{
  name={Wegbeschreibung},
  description={Beschreibung einer \gls{route} durch eine Liste von Abbiegeanweisungen}
}
\newglossaryentry{dijkstra}{
  name={Dijkstra’s Algorithmus},
  description={ein Algorithmus, um den optimalen Pfad in einem gerichteten Graphen zu finden}
}
\newglossaryentry{arc}{
 name={Arc-Flags},
 description={eine Technik, um eine Routenberechnung zu beschleunigen}
}
\newglossaryentry{verlauf}{
  name={Verlauf},
  description={speichert Routenanfragen für spätere Wiederverwendung. Es existiert nur ein Verlauf für die gesamte Anwendung.}
}
\newglossaryentry{mercator}{
  name={Mercator-Projektion},
  description={die Zylinderprojektion der Weltkugel}
}



\begin{titlepage}
\makeatletter
\begin{center}
~\\[5em]
{\Huge routeKIT}\\[3em]
{\huge Entwurf}\\[1em]
{\large\today}\\[2.5em]
{\LARGE
Kevin Birke\\
Felix Dörre\\
Fabian Hafner\\
Lucas Werkmeister\\
Dominic Ziegler\\
Anastasia Zinkina\\[3em]}
betreut durch\\[2em]
{\Large
Julian~Arz\\
G.~Veit~Batz\\
Dr.~Dennis~Luxen\\
Dennis~Schieferdecker\\[1em]}
am\\[1em]
{\Large
Karlsruher Institut für~Technologie\\
Institut für Theoretische~Informatik\\
Algorithmik~II\\
\large
Prof.~Dr.~Peter~Sanders}
\end{center}
\makeatother
\end{titlepage}
\tableofcontents
\newpage

\section{Klassen}

\package{Profiles}{
  \class{Profile}
        {Ein \glslink{profil}{Fahrzeugprofil}.}
        {
          \attr{name}{String}{Der Name des Profils.}
          \attr{vehicleType}{VehicleType}{Der Fahrzeugtyp.}
          \attr{height}{int}{Die Höhe des Fahrzeugs, in Zentimetern.}
          \attr{width}{int}{Die Breite des Fahrzeugs, in Zentimetern.}
          \attr{weight}{int}{Das Gewicht des Fahrzeugs, in Kilogramm.}
          \attr{speedHighway}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Autobahn, in Kilometern pro Stunde.}
          \attr{speedRoad}{int}{Die Durchschnittsgeschwindigkeit des Fahrzeugs auf der Landstraße, in Kilometern pro Stunde.}
        }
        {
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die das Profil gespeichert wird.}
                 }
                 {Speichert das Profil in die angegebene Datei.}
          \method{load}[\refclass{Profile}]
                 {
                   \param{file}{File}{Die Datei, aus der das Profil geladen wird.}
                 } 
                 {Lädt ein Profil aus der angegebenen Datei und gibt es zurück.}
        }
}

\package{Map}{
  \class{Map}
        {Eine Karte.}
        {
          \attr{name}{String}{Der Name der Karte.}
          \attr{graph}{\refclass{Graph}}{Der Graph der Karte, d.\,h. das Straßennetz.}
        }
        {\keine}
  \class{Graph}
        {
          Ein Kartengraph / Straßennetz. Beachte: Dieser Graph ist nicht das Ergebnis einer Vorberechnung für ein Profil und eine Karte, sondern nur für eine Karte.
          Siehe auch \refclass{GraphPreCalculation}.
        }
        {\keine}
        {
          \method{Graph}[Konstruktor]
                 {
                   \param{nodes}{int[]}{Der Knoten-Bestandteil des Adjazenzfeldes.}
                   \param{edges}{int[]}{Der Kanten-Bestandteil des Adjazenzfeldes.}
                   \param{nodeProps}{Map<int, \refclass{NodeProperties}>}
                         {
                           Die \code{NodeProperties} der Knoten des Graphen. Es wird eine \code{Map} anstelle eines Arrays verwendet, da die meisten Knoten keine besonderen Eigenschaften haben und daher das Array zum großen Teil leer wäre.
                         }
                   \param{edgeProps}{\refclass{EdgeProperties}{}[]} % use \refclass{EdgeProperties}{}[] instead of \refclass{EdgeProperties}[]: in the latter form, LaTeX thinks we’re passing an optional argument to \refclass
                         {
                           Die \code{EdgeProperties} der Kanten des Graphen. Hier wird ein Array verwendet, da jede Kante einen Namen und damit ein \code{EdgeProperties}-Objekt hat.
                         }
                   \param{lat}{float[]}{Die geographischen Breiten der Knoten des Graphen.}
                   \param{lon}{float[]}{Die geographischen Längen der Knoten des Graphen.}
                 }
                 {Erstellt ein neues Graph-Objekt aus dem gegebenen Adjazenzfeld.}
          \method{getEdges}[Set<int>]
                 {\param{node}{int}{Der Knoten, dessen Kanten gesucht werden.}}
                 {Gibt alle \emph{ausgehenden} Kanten des angegebenen Knotens zurück.}
          \method{getTargetNode}[int]
                 {\param{edge}{int}{Die Kante, dessen Zielknoten gesucht wird.}}
                 {Gibt den Zielknoten der angegebenen Kante zurück.}
          \method{getLat}[float]
                 {\param{node}{int}{Der Knoten, dessen geographische Breite gesucht wird.}}
                 {Gibt die geographische Breite des angegebenen Knotens zurück.}
          \method{getLon}[float]
                 {\param{node}{int}{Der Knoten, dessen geographische Länge gesucht wird.}}
                 {Gibt die geographische Länge des angegebenen Knotens zurück.}
          \method{getNodeProperties}[\refclass{NodeProperties}]
                 {\param{node}{int}{Der Knoten, dessen \refclass{NodeProperties} gesucht werden.}}
                 {Gibt die \code{NodeProperties} des angegebenen Knotens zurück.}
          \method{getEdgeProperties}[\refclass{EdgeProperties}]
                 {\param{edge}{int}{Die Kante, deren \refclass{EdgeProperties} gesucht werden.}}
                 {Gibt die \code{EdgeProperties} de angegebenen Kante zurück.}
        }
  \class{NodeProperties}
        {Kapselt die Eigenschaften eines Knotens einschließlich der zugehörigen Abbiegebeschränkungen.}
        {\keine}
        {
          \method{allowsTurn}[boolean]
                 {
                   \param{fromEdge}{int}{Die eingehende Kante, über die der Knoten betreten wird.}
                   \param{toEdge}{int}{Die ausgehende Kante, über die der Knoten verlassen wird.}
                   \param{profile}{\refclass{Profile}}{Das \gls{profil}, für das die Zulässigkeit des Abbiegevorgangs bestimmt werden soll.}
                 }
                 {
                   Bestimmt, ob ein Abbiegevorgang über den Knoten von der angegebenen eingehenden Kante zur angegebenen ausgehenden Kante zulässig ist.

                   Wenn der Knoten nicht Endknoten von \refparam{NodeProperties}{allowsTurn}{fromEdge}[fromEdge] oder nicht Startknoten von \refparam{NodeProperties}{allowsTurn}{toEdge}[toEdge] ist, wird \code{false} zurückgegeben.
                 }
          \method{isMiniRoundabout}[boolean]
                 {\keine}
                 {Bestimmt, ob der Knoten ein kleiner Kreisverkehr ist.}
          \method{isHighwayJunction}[boolean]
                 {\keine}
                 {Bestimmt, ob der Knoten eine Schnellstraßen- oder Autobahnanschlussstelle ist.}
          \method{getJunctionName}[String]
                 {\keine}
                 {Gibt den Namen der Anschlussstelle zurück oder \code{null}, falls es sich nicht um eine Anschlussstelle handelt.}
          \method{getJunctionRef}[String]
                 {\keine}
                 {Gibt die Nummer der Anschlussstelle zurück oder \code{null}, falls es sich nicht um eine Anschlussstelle handelt.}
        }
  \class{EdgeProperties}
        {Kapselt die Eigenschaften einer Kante.}
        {\keine}
        {
          \method{getName}[String]
                 {\keine}
                 {Gibt den Namen der Straße zurück oder \code{null}, falls nicht vorhanden.}
          \method{getRoadRef}[String]
                 {\keine}
                 {Gibt die Nummer der Straße zurück oder \code{null}, falls nicht vorhanden.}
          \method{allowsRoute}[boolean]
                 {\param{profile}{\refclass{Profile}}{Das Profil, für das die Zulässigkeit der Benutzung bestimmt werden soll.}}
                 {Bestimmt, ob die Benutzung der Kante in einer \gls{route} zulässig ist.}
          \method{getMaxSpeed}[int]
                 {\param{profile}{\refclass{Profile}}{Das Profil, für das die Höchstgeschwindigkeit auf dieser Kante bestimmt werden soll.}}
                 {Bestimmt die zulässige Höchstgeschwindigkeit auf dieser Kante für das angegebene Profil.}
          \method{isRoundabout}[boolean]
                 {\keine}
                 {Bestimmt, ob die Kante Teil eines Kreisverkehrs ist.}
        }
}

\package{TODO}{ % TODO: holds classes that still need a package
  \class{ProfileMapCombination}
        {Eine Kombination aus einem \refclass{Profile}[Profil] und einer \refclass{Map}[Karte]. Siehe auch \refclass{GraphPreCalculation}.}
        {
          \attr{profile}{\refclass{Profile}}{Das \gls{profil}.}
          \attr{map}{\refclass{Map}}{Die Karte.}
        }
        {\keine}
  \class{GPXExporter}
        {Stellt die Funktionalität zum Export einer \gls{route} im GPX-Format bereit.}
        {
          \attr{route}{\refclass{Route}}{Die zu exportierende Route.}
        }
        {
          \method{exportRoute}
                 {
                   \param{file}{File}{Die GPX-Datei, die geschrieben werden soll.}
                 }
                 {Exportiert die Wegpunkte der \refattr{GPXExporter}{route} im GPX-Format in die angegebene Datei.}
        }
}

\package{RouteCalculator}{
  \class{GraphPreCalculation}
        {Kapselt ein Profil, eine Karte, und die Ergebnisse einer Vorberechnung für diese Profil-Karte-Kombination.}
        {\keine}
        {\keine} % TODO
  \class{Route}
        {Repräsentiert eine berechnete \gls{route}.}
        {\keine} % ?
        {
          \method{getNodes}[int[]]
                 {\keine}
                 {Liefert eine Liste der Knoten, aus denen denen die Route besteht.}
          \method{getRouteDescription}[\refclass{RouteDescription}]
                 {\keine}
                 {Gibt die zur Route gehörende \gls{wegbeschreibung} zurück.}
        }
  \class{RouteDescription}
        {Kapselt die zu einer \refclass{Route} gehörende \gls{wegbeschreibung}.}
        {\keine} % ?
        {
          \keine % TODO
        }
  \class{TurnInstruction}
        {Kapselt eine einzelne Abbiegeanweisung, aus welchen eine \gls{wegbeschreibung} aufgebaut ist.}
        {\keine} % ?
        {\keine} % TODO
}

\package{History}{
  \class{History}
        {Kapselt den \gls{verlauf}.}
        {\keine}
        {
          \method{addEntry}
                 {
                   \param{start}{Coordinates}{Der Startpunkt.}
                   \param{destination}{Coordinates}{Der Zielpunkt.}
                 }
                 {Fügt einen Eintrag zum Verlauf hinzu. Als \refattr{HistoryEntry}{date} des neuen Eintrags wird die aktuelle Zeit verwendet.}
          \method{getEntries}[List<\refclass{HistoryEntry}>]
                 {\keine}
                 {Gibt alle Einträge des Verlaufs zurück.}
          \method{save}
                 {
                   \param{file}{File}{Die Datei, in die der Verlauf gespeichert wird.}
                 }
                 {Speichert den Verlauf in die angegebene Datei.}
          \method{load}[History]
                 {
                   \param{file}{File}{Die Datei, aus der der Verlauf geladen wird.}
                 }
                 {Lädt einen Verlauf aus der angegebenen Datei und gibt ihn zurück.}
        }
  \class{HistoryEntry}
        {Ein Eintrag im \gls{verlauf}.}
        {
          \attr{start}{Coordinates}{Der Startpunkt der Anfrage.}
          \attr{destination}{Coordinates}{Der Zielpunkt der Anfrage.}
          \attr{date}{Date}{Der Zeitpunkt der Anfrage.}
        }
        {\keine}
}

\package{MapDisplay}{
  \class{TileDequeue}
        {
          Verwaltet die Berechnung von Kartenkacheln.
          Karten können angefragt werden, und nachdem die (asynchrone) Berechnung abgeschlossen ist, werden registrierte \refclass{TileFinishedListener} benachrichtigt.
          Über das \code{Future}-Interface können Berechnungen auch abgebrochen werden.
        }
        {\keine}
        {
          \method{requestTile}[Future<BufferedImage>]
                 {
                   \param{x}{int}{Die x-Koordinate der angeforderten Kachel.} % TODO skaliert mit dem Zoom? relativ zu was?
                   \param{y}{int}{Die y-Koordinate der angeforderten Kachel.}
                   \param{zoom}{int}{Die Zoomstufe der angeforderten Kachel, zwischen 0 (eine Kachel für die ganze Welt) und 19 (Maßstab 1:1000).}
                 }
                 {
                   Beantragt die asynchrone Berechnung der angegebenen Kachel.
                   Über das zurückgegeben \code{Future}-Object kann die Berechnung abgebrochen werden; zu beachten ist aber, dass die \code{get}-Methode des Objekts niemals \code{null} zurückgeben wird, sondern für noch nicht berechnete Kacheln stattdessen eine „Platzhalter-Kachel“.
                 }
          \method{addTileFinishedListener}
                 {\param{listener}{\refclass{TileFinishedListener}}{Der Listener, der hinzugefügt werden soll.}}
                 {
                   Registriert einen \refclass{TileFinishedListener}, der benachrichtigt wird, wenn eine Kachel fertig berechnet ist.
                   Die Kachel ist Teil der Nachricht, kann aber auch jederzeit über das von \refmethod{TileDequeue}{requestTile}[requestTile] zurückgegebene \code{Future}-Object abgefragt werden.
                 }
        }
  \class{TileFinishedListener} % TODO \class? \interface?
        {Wird benachrichtigt, wenn die Berechnung einer Kartenkachel abgeschlossen ist.}
        {\keine}
        {
          \method{tileFinished}
                 {
                   \param{x}{int}{siehe \refparam{TileDequeue}{requestTile}{x}}
                   \param{y}{int}{siehe \refparam{TileDequeue}{requestTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileDequeue}{requestTile}{zoom}}
                   \param{tile}{BufferedImage}{Die berechnete Kachel.}
                 }
                 {
                   Wird vom \refclass{TileDequeue} aufgerufen, wenn die Berechnung einer Kachel abgeschlossen ist.
                   Die übliche Aktion ist, ein \code{repaint} der Kartenansicht im \gls{gui} auszulösen.
                 }
        }
  \class{TileSource}
        {Abstrakte Klasse, die ein Interface für das (synchrone) \Gls{rendern} von Kartenkacheln definiert.}
        {\keine}
        {
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileDequeue}{requestTile}{x}}
                   \param{y}{int}{siehe \refparam{TileDequeue}{requestTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileDequeue}{requestTile}{zoom}}
                 }
                 {Berechnet die angegebene Kachel und gibt sie zurück.}
        }
  \class{TileCache}
        {Ein Zwischenspeicher für Kacheln, um zu verhindern, dass sie ständig von neuem berechnet werden.}
        {\keine}
        {
          \method{TileCache}[Konstruktor]
                 {\param{target}{\refclass{TileSource}}{Die \code{TileSource}, die die tatsächliche Berechnung durchführt und deren Ergebnisse zwischengespeichert werden.}}
                 {Erstellt einen neuen Cache für die angegebene \refclass{TileSource}.}
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileDequeue}{requestTile}{x}}
                   \param{y}{int}{siehe \refparam{TileDequeue}{requestTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileDequeue}{requestTile}{zoom}}
                 }
                 {
                   Ist die angeforderte Kachel bereits im Zwischenspeicher vorhanden, so wird sie direkt zurückgegeben;
                   andernfalls wird sie von \refparam{TileCache}{TileCache}{target}[target] angefordert, im Zwischenspeicher gespeichert und dann zurückgegeben.
                 }
          \method{deleteTiles}
                 {\param{zoom}{int}{Die Zoomstufe, für die Kacheln gelöscht werden sollen; siehe \refparam{TileDequeue}{requestTile}{zoom}.}}
                 {Veranlasst, dass alle zwischengespeicherten Kacheln der angegebenen Zoomstufe aus dem Zwischenspeicher gelöscht werden, etwa, um Speicher zu sparen.}
        }
  \class{TileRenderer}
        {Eine \refclass{TileSource}, die die Kacheln selbst berechnet.}
        {\keine}
        {
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileDequeue}{requestTile}{x}}
                   \param{y}{int}{siehe \refparam{TileDequeue}{requestTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileDequeue}{requestTile}{zoom}}
                 }
                 {Berechnet die angegebene Kachel und gibt sie zurück.}
        }
  \class{OSMRenderer}
        {Eine \refclass{TileSource}, die die \glspl{osmkachel} vom OpenStreetMap-Server herunterlädt.}
        {\keine}
        {
          \method{getTile}[BufferedImage]
                 {
                   \param{x}{int}{siehe \refparam{TileDequeue}{requestTile}{x}}
                   \param{y}{int}{siehe \refparam{TileDequeue}{requestTile}{y}}
                   \param{zoom}{int}{siehe \refparam{TileDequeue}{requestTile}{zoom}}
                 }
                 {Lädt die angegebene Kachel herunter und gibt sie zurück.}
        }
}

\package{View}{
  \class{MapView}
        {Zeigt einen Kartenausschnitt auf dem Bildschirm an.}
        {\keine}
        {
            \method{paint}
                {
                  \param{x}{Graphics}{ein Objekt vom Typ Graphics}
                }
               {Zeichnet einen Kartenausschnitt, indem fertige Kacheln richtig platziert werden.}
         }

   \class{MainView}
        {Zeigt das Hauptfenster auf dem Bildschirm an.}
        {\keine}
        {\keine}

   \class{MapManagerView}
        {Zeigt das Fenster der Kartenverwaltung auf dem Bildschirm an.}
        {\keine}
        {\keine}

   \class{ProfileManagerView}
        {Zeigt das Fenster der Profilverwaltung auf dem Bildschirm an.}
        {\keine}
        {\keine}

  \class{HistoryView}
        {Zeigt das Fenster mit dem Verlauf auf dem Bildschirm an.}
        {\keine}
        {\keine}

  \class{AboutView}
        {Zeigt das Fenster mit den Informationen über routeKIT auf dem Bildschirm an.}
        {\keine}
        {\keine}
}


\glsaddallunused
\makeatletter
\newglossarystyle{myAltlist}{
  \glossarystyle{altlist} % base this style on altlist
  \renewcommand*{\glossaryentryfield}[5]{
  \item[\glsentryitem{##1}\glstarget{##1}{##2}]
    \mbox{}\par\nobreak\@afterheading
    ##3\glspostdescription\space Auf Seite ##5.
  }
}
\makeatother
\printglossary[type=main, title={Glossar}, toctitle={Glossar}, style=myAltlist]

\end{document}
